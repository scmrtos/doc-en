{"config":{"indexing":"full","lang":["ru"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"scmRTOS \ud83d\udd17 The abbreviation scmRTOS stands for Single-Chip Microcontroller Real Time Operating System . As the name implies, scmRTOS is designed for single-chip microcontrollers (MCUs), although nothing prevents it from being used with processors like Blackfin or Cortex-A. Why? \ud83d\udd17 One of the primary goals behind creating this RTOS was the desire to obtain the simplest, most minimalist, fast, and efficient solution for implementing preemptive multitasking when using single-chip MCUs. Their resources are limited and typically cannot be expanded. Although technological advancements since the emergence of scmRTOS have significantly reduced the demands on RTOS efficiency, simplicity, speed, and small size remain desirable factors in many cases. The second main reason for scmRTOS's development is its use and implementation in the C++ programming language. C++ has become quite complex today, but scmRTOS employs only the most basic concepts and constructs of the language \u2014 essentially what was included in the C++98 standard: classes, templates, inheritance, function overloading. C++ in the embedded field is often seen as a deterrent \u2014 there's a certain mythology surrounding this language (high overhead, poor controllability, etc.). However, in practice, using C++ can simplify, rather than complicate, software development and maintenance (though the opposite effect is possible with the wrong choice of tools for the task). scmRTOS focuses on ease of use, greatly aided by the concept of a class, which encapsulates properties and provides the user only with an interface. This approach reduces the risk of incorrect usage of operating system objects. TIP The history of scmRTOS and some \"philosophical\" remarks on the topic of real-time operating systems are provided in the document scmRTOS.ru.pdf . Supported Platforms \ud83d\udd17 Currently, scmRTOS supports the following platforms (processor/toolchain): MSP430/IAR Systems; MSP430/GCC; AVR/IAR Systems; AVR/GCC; Cortex-M/GCC; Cortex-M/IAR Systems; Cortex-A/GCC; ARM7/GCC; Blackfin/VisualDSP++; Blackfin/GCC; Blackfin/CCES; STM8/IAR Systems.","title":"Instead of a preface"},{"location":"#scmrtos","text":"The abbreviation scmRTOS stands for Single-Chip Microcontroller Real Time Operating System . As the name implies, scmRTOS is designed for single-chip microcontrollers (MCUs), although nothing prevents it from being used with processors like Blackfin or Cortex-A.","title":"scmRTOS"},{"location":"#why","text":"One of the primary goals behind creating this RTOS was the desire to obtain the simplest, most minimalist, fast, and efficient solution for implementing preemptive multitasking when using single-chip MCUs. Their resources are limited and typically cannot be expanded. Although technological advancements since the emergence of scmRTOS have significantly reduced the demands on RTOS efficiency, simplicity, speed, and small size remain desirable factors in many cases. The second main reason for scmRTOS's development is its use and implementation in the C++ programming language. C++ has become quite complex today, but scmRTOS employs only the most basic concepts and constructs of the language \u2014 essentially what was included in the C++98 standard: classes, templates, inheritance, function overloading. C++ in the embedded field is often seen as a deterrent \u2014 there's a certain mythology surrounding this language (high overhead, poor controllability, etc.). However, in practice, using C++ can simplify, rather than complicate, software development and maintenance (though the opposite effect is possible with the wrong choice of tools for the task). scmRTOS focuses on ease of use, greatly aided by the concept of a class, which encapsulates properties and provides the user only with an interface. This approach reduces the risk of incorrect usage of operating system objects. TIP The history of scmRTOS and some \"philosophical\" remarks on the topic of real-time operating systems are provided in the document scmRTOS.ru.pdf .","title":"Why?"},{"location":"#supported-platforms","text":"Currently, scmRTOS supports the following platforms (processor/toolchain): MSP430/IAR Systems; MSP430/GCC; AVR/IAR Systems; AVR/GCC; Cortex-M/GCC; Cortex-M/IAR Systems; Cortex-A/GCC; ARM7/GCC; Blackfin/VisualDSP++; Blackfin/GCC; Blackfin/CCES; STM8/IAR Systems.","title":"Supported Platforms"},{"location":"src/debug/","text":"Debugging \ud83d\udd17 Inspecting Process Stack Consumption \ud83d\udd17 There is a question that is often quite difficult to answer definitively: what volume of RAM allocated for the stack is necessary to meet all the program's needs and ensure its correct and safe operation? In the case of programs running without an OS, where all code executes using a single stack, there are tools for estimating the memory volume allocated to the stack that is necessary for correct operation. They are based on building a function call tree and known information about how much stack each function consumes. The compiler itself can perform this work, placing the results in the listing file after compiling the source file. To get the final result, one must add the stack requirements of the most consuming interrupt handler to the result of the most consuming function itself. Unfortunately, the described method only gives an approximate estimate, because the compiler cannot accurately build the call tree of functions that arise in practice \u2014 in particular, indirect function calls, which include calls via pointer or virtual function calls, cannot be accounted for, as nothing is known at compile time about which specific function will be called. In specific cases where the programmer knows which functions can be called indirectly, stack consumption calculation can be done manually. But this method is inconvenient \u2014 it must be done with every significant program change, and it is error-prone. In general, the compiler is not obligated to provide such information, and third-party tools performing this work also cannot overcome the difficulties described above, which is why they have not gained popularity. All this presents the program developer with a choice: what stack size to specify. On one hand, there is a desire to save RAM; on the other, it is necessary to specify a sufficient size to avoid program runtime errors, especially since errors arising from incorrect memory handling are typically very difficult to catch, as their manifestation is always individual and poorly predictable. Therefore, in practice, one has to specify the stack size with some margin, which allows for accounting for errors in underestimating its size. When using an operating system, the situation is exacerbated because there is not one stack in the program, but their number equals the number of processes specified during OS configuration. This creates a greater RAM deficit and forces the developer to economize even more on memory and specify stack sizes with a smaller margin. To solve the problems described above, a method of practical measurement of stack consumption by processes can be applied. This capability, like other system debugging capabilities, is enabled in scmRTOS during configuration by setting the macro scmRTOS_DEBUG_ENABLE to 1. The essence of the method is to fill the stack space with some predetermined known value (pattern) during the stack frame preparation stage. Then, when checking the result, scan the memory area allocated for the process stack, starting from the end opposite the stack top (TOS), and find the location where the pattern filling ends. The number of cells where the pattern was not overwritten during program execution shows the actual stack size margin for the process. Filling the stack with the pattern is performed in the platform-dependent function init_stack_frame() when debug mode is enabled. Information about the stack margin of a process can be obtained at any time by calling the function ``` for the process object, which returns an integer indicating the desired value. Based on this, the program developer can adjust stack sizes and thereby eliminate errors arising from stack overflow. Handling Stuck Processes \ud83d\udd17 During development, a characteristic situation often arises where the program works incorrectly for unclear reasons, and by indirect signs it's easy to determine that a particular process is not working. This usually happens if a process is waiting for some service, and to find the cause of the hang, it's necessary to determine which specific service caused the wait. To identify the service a process is waiting for, scmRTOS includes special debugging tools \u2014 in particular, when a process transitions to a waiting state, the address of the service whose call triggered the transition to waiting is stored. If necessary, the user can call the process's waiting_for() function, which returns a pointer to the service. Knowing this address, one can always determine the service object's name using the linker map file. Process Profiling \ud83d\udd17 Sometimes it is very useful to know the distribution of the processing load among program processes. This information allows assessing the correctness of the program's algorithms and identifying a number of elusive logical errors. Several methods exist for obtaining information about process load by determining the relative time of their active work; this is called process profiling. In scmRTOS , profiling is implemented as an extension and is not part of the core OS. The profiler is an extension class that implements basic functions for collecting information about relative execution time and processing it. Collecting this information can be implemented in two ways, each with its own advantages and disadvantages: Statistical; Measurement-based. Statistical Method \ud83d\udd17 The statistical method does not require any additional resources for its operation, except those provided by the operating system. Its working principle is based on periodically sampling the kernel variable CurProcPriority , which indicates which process is active at a given moment. Sampling can be conveniently organized, for example, in the system timer interrupt handler \u2014 the more CPU time a process occupies, the more often it will be active during sampling. The disadvantage of this method is its low accuracy, allowing only a qualitative picture of what is happening. Measurement-based Method \ud83d\udd17 This method is free from the main drawback of statistical profiling \u2014 low accuracy in determining process load time. The principle of the measurement-based method is based on measuring the execution time of processes (hence the name). For this, the user must provide means for measuring execution time \u2014 this could be one of the MCU's hardware timers or some other means \u2014 for example, a processor cycle counter, if available. This is the price for using this method. Usage \ud83d\udd17 To use the profiler in a user project, it is necessary to define a time measurement function and connect the profiler to the project. For more details, see the example in the Process Profiling appendix . Process Names \ud83d\udd17 To increase debugging convenience, the ability to assign string names to processes is provided. The name is assigned in the usual way for C++ \u2014 through a constructor argument: MainProc main_proc ( \u201c Main Process \u201d ); This string argument can always be described, but the utilization of the name is available only in the debug configuration. For access from a user program, the class TBaseProcess defines the function: const char * name (); Usage is trivial and no different from working with C-strings in C/C++. An example of debug information output can be seen in \"Listing 1. Example of Debug Information Output\". 01 //------------------------------------------------------------------------- 02 void ProcProfiler :: get_results () 03 { 04 print ( \"------------------------------ \\n \" ); 05 for ( uint_fast8_t i = 0 ; i < OS :: PROCESS_COUNT ; ++ i ) 06 { 07 # if scmRTOS_DEBUG_ENABLE == 1 08 printf ( \"#%d | CPU %5.2f | Slack %d | %s \\n \" , i , 09 Profiler . get_result ( i ) / 100.0 , 10 OS :: get_proc ( i ) -> stack_slack (), 11 OS :: get_proc ( i ) -> name () ); 12 # endif 13 } 14 } 15 //------------------------------------------------------------------------- Listing 1. Example of Debug Information Output The provided code generates the following output: ------------------------------ #0 | CPU 82.52 | Slack 164 | Idle #1 | CPU 0.00 | Slack 178 | Background #2 | CPU 0.07 | Slack 387 | GUI #3 | CPU 0.23 | Slack 259 | Video #4 | CPU 0.00 | Slack 148 | BiasReg #5 | CPU 17.09 | Slack 165 | RefFrame #6 | CPU 0.03 | Slack 204 | TempMon #7 | CPU 0.00 | Slack 151 | Terminal #8 | CPU 0.01 | Slack 129 | Test #9 | CPU 0.01 | Slack 301 | IBoard","title":"Debug"},{"location":"src/debug/#debugging","text":"","title":"Debugging"},{"location":"src/debug/#inspecting-process-stack-consumption","text":"There is a question that is often quite difficult to answer definitively: what volume of RAM allocated for the stack is necessary to meet all the program's needs and ensure its correct and safe operation? In the case of programs running without an OS, where all code executes using a single stack, there are tools for estimating the memory volume allocated to the stack that is necessary for correct operation. They are based on building a function call tree and known information about how much stack each function consumes. The compiler itself can perform this work, placing the results in the listing file after compiling the source file. To get the final result, one must add the stack requirements of the most consuming interrupt handler to the result of the most consuming function itself. Unfortunately, the described method only gives an approximate estimate, because the compiler cannot accurately build the call tree of functions that arise in practice \u2014 in particular, indirect function calls, which include calls via pointer or virtual function calls, cannot be accounted for, as nothing is known at compile time about which specific function will be called. In specific cases where the programmer knows which functions can be called indirectly, stack consumption calculation can be done manually. But this method is inconvenient \u2014 it must be done with every significant program change, and it is error-prone. In general, the compiler is not obligated to provide such information, and third-party tools performing this work also cannot overcome the difficulties described above, which is why they have not gained popularity. All this presents the program developer with a choice: what stack size to specify. On one hand, there is a desire to save RAM; on the other, it is necessary to specify a sufficient size to avoid program runtime errors, especially since errors arising from incorrect memory handling are typically very difficult to catch, as their manifestation is always individual and poorly predictable. Therefore, in practice, one has to specify the stack size with some margin, which allows for accounting for errors in underestimating its size. When using an operating system, the situation is exacerbated because there is not one stack in the program, but their number equals the number of processes specified during OS configuration. This creates a greater RAM deficit and forces the developer to economize even more on memory and specify stack sizes with a smaller margin. To solve the problems described above, a method of practical measurement of stack consumption by processes can be applied. This capability, like other system debugging capabilities, is enabled in scmRTOS during configuration by setting the macro scmRTOS_DEBUG_ENABLE to 1. The essence of the method is to fill the stack space with some predetermined known value (pattern) during the stack frame preparation stage. Then, when checking the result, scan the memory area allocated for the process stack, starting from the end opposite the stack top (TOS), and find the location where the pattern filling ends. The number of cells where the pattern was not overwritten during program execution shows the actual stack size margin for the process. Filling the stack with the pattern is performed in the platform-dependent function init_stack_frame() when debug mode is enabled. Information about the stack margin of a process can be obtained at any time by calling the function ``` for the process object, which returns an integer indicating the desired value. Based on this, the program developer can adjust stack sizes and thereby eliminate errors arising from stack overflow.","title":"Inspecting Process Stack Consumption"},{"location":"src/debug/#handling-stuck-processes","text":"During development, a characteristic situation often arises where the program works incorrectly for unclear reasons, and by indirect signs it's easy to determine that a particular process is not working. This usually happens if a process is waiting for some service, and to find the cause of the hang, it's necessary to determine which specific service caused the wait. To identify the service a process is waiting for, scmRTOS includes special debugging tools \u2014 in particular, when a process transitions to a waiting state, the address of the service whose call triggered the transition to waiting is stored. If necessary, the user can call the process's waiting_for() function, which returns a pointer to the service. Knowing this address, one can always determine the service object's name using the linker map file.","title":"Handling Stuck Processes"},{"location":"src/debug/#process-profiling","text":"Sometimes it is very useful to know the distribution of the processing load among program processes. This information allows assessing the correctness of the program's algorithms and identifying a number of elusive logical errors. Several methods exist for obtaining information about process load by determining the relative time of their active work; this is called process profiling. In scmRTOS , profiling is implemented as an extension and is not part of the core OS. The profiler is an extension class that implements basic functions for collecting information about relative execution time and processing it. Collecting this information can be implemented in two ways, each with its own advantages and disadvantages: Statistical; Measurement-based.","title":"Process Profiling"},{"location":"src/debug/#statistical-method","text":"The statistical method does not require any additional resources for its operation, except those provided by the operating system. Its working principle is based on periodically sampling the kernel variable CurProcPriority , which indicates which process is active at a given moment. Sampling can be conveniently organized, for example, in the system timer interrupt handler \u2014 the more CPU time a process occupies, the more often it will be active during sampling. The disadvantage of this method is its low accuracy, allowing only a qualitative picture of what is happening.","title":"Statistical Method"},{"location":"src/debug/#measurement-based-method","text":"This method is free from the main drawback of statistical profiling \u2014 low accuracy in determining process load time. The principle of the measurement-based method is based on measuring the execution time of processes (hence the name). For this, the user must provide means for measuring execution time \u2014 this could be one of the MCU's hardware timers or some other means \u2014 for example, a processor cycle counter, if available. This is the price for using this method.","title":"Measurement-based Method"},{"location":"src/debug/#usage","text":"To use the profiler in a user project, it is necessary to define a time measurement function and connect the profiler to the project. For more details, see the example in the Process Profiling appendix .","title":"Usage"},{"location":"src/debug/#process-names","text":"To increase debugging convenience, the ability to assign string names to processes is provided. The name is assigned in the usual way for C++ \u2014 through a constructor argument: MainProc main_proc ( \u201c Main Process \u201d ); This string argument can always be described, but the utilization of the name is available only in the debug configuration. For access from a user program, the class TBaseProcess defines the function: const char * name (); Usage is trivial and no different from working with C-strings in C/C++. An example of debug information output can be seen in \"Listing 1. Example of Debug Information Output\". 01 //------------------------------------------------------------------------- 02 void ProcProfiler :: get_results () 03 { 04 print ( \"------------------------------ \\n \" ); 05 for ( uint_fast8_t i = 0 ; i < OS :: PROCESS_COUNT ; ++ i ) 06 { 07 # if scmRTOS_DEBUG_ENABLE == 1 08 printf ( \"#%d | CPU %5.2f | Slack %d | %s \\n \" , i , 09 Profiler . get_result ( i ) / 100.0 , 10 OS :: get_proc ( i ) -> stack_slack (), 11 OS :: get_proc ( i ) -> name () ); 12 # endif 13 } 14 } 15 //------------------------------------------------------------------------- Listing 1. Example of Debug Information Output The provided code generates the following output: ------------------------------ #0 | CPU 82.52 | Slack 164 | Idle #1 | CPU 0.00 | Slack 178 | Background #2 | CPU 0.07 | Slack 387 | GUI #3 | CPU 0.23 | Slack 259 | Video #4 | CPU 0.00 | Slack 148 | BiasReg #5 | CPU 17.09 | Slack 165 | RefFrame #6 | CPU 0.03 | Slack 204 | TempMon #7 | CPU 0.00 | Slack 151 | Terminal #8 | CPU 0.01 | Slack 129 | Test #9 | CPU 0.01 | Slack 301 | IBoard","title":"Process Names"},{"location":"src/glossary/","text":"Terms and Abbreviations \ud83d\udd17 C \ud83d\udd17 A general-purpose, low-level procedural programming language. C++ \ud83d\udd17 A general-purpose programming language supporting procedural, object-based, and object-oriented programming paradigms. Critical Section \ud83d\udd17 A code fragment during whose execution control transfer is prohibited. In scmRTOS, this is currently implemented in the simplest way by globally disabling interrupts. EC++ \ud83d\udd17 Embedded C++, a subset of C++. It does not support namespaces, templates, multiple inheritance, RTTI, exception handling, or the new explicit type conversion syntax. Idle Process (Background Process) \ud83d\udd17 A system process that gains control when all user processes are in a state of waiting for events. This process cannot transition to a waiting state and may execute a user hook if enabled during configuration. Inter-Process Communication (IPC) Services \ud83d\udd17 Objects and/or OS extensions designed for safe interaction (synchronization of work and data exchange) between different processes, as well as for organizing event-driven program execution based on events occurring in interrupts and processes. Interrupt Stack \ud83d\udd17 A specially allocated RAM area intended for use as a stack during the execution of interrupt handler code. If an interrupt stack is used in the program, the processor's stack pointer is switched to the interrupt stack upon entering an interrupt handler and switched back to the process stack upon exit. ISR \ud83d\udd17 Interrupt Service Routine \u2013 an interrupt handler. Kernel \ud83d\udd17 The most important and central part of the operating system, performing functions related to organizing processes, scheduling their execution, supporting inter-process communication, system time, and OS extensions. MCU \ud83d\udd17 Microcontroller. Operating System Process \ud83d\udd17 An object that implements the execution of a complete, independent program fragment asynchronous to others, including support for control transfer both at the process level and at the interrupt level. OS Extensions \ud83d\udd17 Software objects that extend the functionality of the operating system but are not part of the core OS. An example of an extension is the system process activity profiler. OS \ud83d\udd17 Operating System. OS Configuration \ud83d\udd17 The set of macros, types, other definitions, and declarations that specify the quantitative and qualitative characteristics and properties of the operating system in a specific project. Configuration is performed by defining the contents of special header configuration files, as well as by some user code executed before OS startup. OS Port \ud83d\udd17 The combination of common and platform-dependent OS code tailored to a specific software and hardware platform. Preemption \ud83d\udd17 The set of actions performed by operating system components aimed at forcibly transferring control from one process to another. Process Context \ud83d\udd17 The software and hardware environment of the executing code, including processor registers, stack pointers, and other resources necessary for program execution. Since control transfer from one process to another in a preemptive OS can occur at an unpredictable moment, the process context must be saved until the next time this process gains control. Because each process executes independently and asynchronously relative to other processes, to ensure the correct operation of a preemptive OS, each process must have its own context. Process Executable Function \ud83d\udd17 A static member function of the process class that implements an independent, asynchronous program execution flow in the form of an infinite loop. Process Map \ud83d\udd17 An operating system object containing one or more process tags. Physically implemented based on an integer variable. Each bit in the process map corresponds to one process and uniquely maps to the process priority. Process Priority \ud83d\udd17 A property of a process (an integer-type object) that determines the order of process selection during operations in the scheduler and other OS components. Serves as a unique process identifier. Process Stack \ud83d\udd17 A memory area in the form of an array that is a data member of the process object, used as a stack in the process's executable function. Also serves as the location where the process context is saved during control transfer. Process Tag \ud83d\udd17 A binary number mask containing only one non-zero bit, whose position is uniquely related to the process priority number. Like the process priority, the tag is a unique identifier but has a different representation than the process priority. Each representation (priority or tag) is used where it is more appropriate from the perspective of program efficiency. Profiler \ud83d\udd17 An object that measures, by one means or another, the distribution of processor time among processes and has facilities for providing this information to the user. RAM \ud83d\udd17 Random Access Memory. Ring Buffer \ud83d\udd17 A data object representing a queue. It has two data ports (access functions) \u2013 an input for writing and an output for reading. Implemented using an array and two indices (pointers) denoting the start and end of the queue. Upon reaching the physical end of the array, writing/reading starts from the beginning again, meaning the indices move in a ring, hence the object's name. RTOS \ud83d\udd17 Real-Time Operating System. Scheduler \ud83d\udd17 A core component of the OS kernel responsible for managing the order of process execution. Stack Frame \ud83d\udd17 Represents a set of data placed in the process stack exactly as it is when the process context is saved during control transfer. System Timer \ud83d\udd17 A hardware timer of the target processor selected as the source for generating interrupts at a specified period, as well as the OS function called from the timer's ISR that implements the logic for handling process timeouts. User Hook \ud83d\udd17 A function called from the OS code, whose body must be defined by the user. This allows user-defined code to be executed directly from within the operating system's internal functions without modifying its code. To avoid forcing the user to define the bodies of hooks they do not use, the hook is called only if enabled during configuration. That is, if a user wishes to use a particular hook, they must enable its use and define its body. Timeout \ud83d\udd17 A time interval, specified by an integer-type object, used for organizing conditional or unconditional event waiting by processes. TOS \ud83d\udd17 Top Of Stack. The address of the stack element pointed to by the processor's hardware stack pointer.","title":"Glossary"},{"location":"src/glossary/#terms-and-abbreviations","text":"","title":"Terms and Abbreviations"},{"location":"src/glossary/#c","text":"A general-purpose, low-level procedural programming language.","title":"C"},{"location":"src/glossary/#c_1","text":"A general-purpose programming language supporting procedural, object-based, and object-oriented programming paradigms.","title":"C++"},{"location":"src/glossary/#critical-section","text":"A code fragment during whose execution control transfer is prohibited. In scmRTOS, this is currently implemented in the simplest way by globally disabling interrupts.","title":"Critical Section"},{"location":"src/glossary/#ec","text":"Embedded C++, a subset of C++. It does not support namespaces, templates, multiple inheritance, RTTI, exception handling, or the new explicit type conversion syntax.","title":"EC++"},{"location":"src/glossary/#idle-process-background-process","text":"A system process that gains control when all user processes are in a state of waiting for events. This process cannot transition to a waiting state and may execute a user hook if enabled during configuration.","title":"Idle Process (Background Process)"},{"location":"src/glossary/#inter-process-communication-ipc-services","text":"Objects and/or OS extensions designed for safe interaction (synchronization of work and data exchange) between different processes, as well as for organizing event-driven program execution based on events occurring in interrupts and processes.","title":"Inter-Process Communication (IPC) Services"},{"location":"src/glossary/#interrupt-stack","text":"A specially allocated RAM area intended for use as a stack during the execution of interrupt handler code. If an interrupt stack is used in the program, the processor's stack pointer is switched to the interrupt stack upon entering an interrupt handler and switched back to the process stack upon exit.","title":"Interrupt Stack"},{"location":"src/glossary/#isr","text":"Interrupt Service Routine \u2013 an interrupt handler.","title":"ISR"},{"location":"src/glossary/#kernel","text":"The most important and central part of the operating system, performing functions related to organizing processes, scheduling their execution, supporting inter-process communication, system time, and OS extensions.","title":"Kernel"},{"location":"src/glossary/#mcu","text":"Microcontroller.","title":"MCU"},{"location":"src/glossary/#operating-system-process","text":"An object that implements the execution of a complete, independent program fragment asynchronous to others, including support for control transfer both at the process level and at the interrupt level.","title":"Operating System Process"},{"location":"src/glossary/#os-extensions","text":"Software objects that extend the functionality of the operating system but are not part of the core OS. An example of an extension is the system process activity profiler.","title":"OS Extensions"},{"location":"src/glossary/#os","text":"Operating System.","title":"OS"},{"location":"src/glossary/#os-configuration","text":"The set of macros, types, other definitions, and declarations that specify the quantitative and qualitative characteristics and properties of the operating system in a specific project. Configuration is performed by defining the contents of special header configuration files, as well as by some user code executed before OS startup.","title":"OS Configuration"},{"location":"src/glossary/#os-port","text":"The combination of common and platform-dependent OS code tailored to a specific software and hardware platform.","title":"OS Port"},{"location":"src/glossary/#preemption","text":"The set of actions performed by operating system components aimed at forcibly transferring control from one process to another.","title":"Preemption"},{"location":"src/glossary/#process-context","text":"The software and hardware environment of the executing code, including processor registers, stack pointers, and other resources necessary for program execution. Since control transfer from one process to another in a preemptive OS can occur at an unpredictable moment, the process context must be saved until the next time this process gains control. Because each process executes independently and asynchronously relative to other processes, to ensure the correct operation of a preemptive OS, each process must have its own context.","title":"Process Context"},{"location":"src/glossary/#process-executable-function","text":"A static member function of the process class that implements an independent, asynchronous program execution flow in the form of an infinite loop.","title":"Process Executable Function"},{"location":"src/glossary/#process-map","text":"An operating system object containing one or more process tags. Physically implemented based on an integer variable. Each bit in the process map corresponds to one process and uniquely maps to the process priority.","title":"Process Map"},{"location":"src/glossary/#process-priority","text":"A property of a process (an integer-type object) that determines the order of process selection during operations in the scheduler and other OS components. Serves as a unique process identifier.","title":"Process Priority"},{"location":"src/glossary/#process-stack","text":"A memory area in the form of an array that is a data member of the process object, used as a stack in the process's executable function. Also serves as the location where the process context is saved during control transfer.","title":"Process Stack"},{"location":"src/glossary/#process-tag","text":"A binary number mask containing only one non-zero bit, whose position is uniquely related to the process priority number. Like the process priority, the tag is a unique identifier but has a different representation than the process priority. Each representation (priority or tag) is used where it is more appropriate from the perspective of program efficiency.","title":"Process Tag"},{"location":"src/glossary/#profiler","text":"An object that measures, by one means or another, the distribution of processor time among processes and has facilities for providing this information to the user.","title":"Profiler"},{"location":"src/glossary/#ram","text":"Random Access Memory.","title":"RAM"},{"location":"src/glossary/#ring-buffer","text":"A data object representing a queue. It has two data ports (access functions) \u2013 an input for writing and an output for reading. Implemented using an array and two indices (pointers) denoting the start and end of the queue. Upon reaching the physical end of the array, writing/reading starts from the beginning again, meaning the indices move in a ring, hence the object's name.","title":"Ring Buffer"},{"location":"src/glossary/#rtos","text":"Real-Time Operating System.","title":"RTOS"},{"location":"src/glossary/#scheduler","text":"A core component of the OS kernel responsible for managing the order of process execution.","title":"Scheduler"},{"location":"src/glossary/#stack-frame","text":"Represents a set of data placed in the process stack exactly as it is when the process context is saved during control transfer.","title":"Stack Frame"},{"location":"src/glossary/#system-timer","text":"A hardware timer of the target processor selected as the source for generating interrupts at a specified period, as well as the OS function called from the timer's ISR that implements the logic for handling process timeouts.","title":"System Timer"},{"location":"src/glossary/#user-hook","text":"A function called from the OS code, whose body must be defined by the user. This allows user-defined code to be executed directly from within the operating system's internal functions without modifying its code. To avoid forcing the user to define the bodies of hooks they do not use, the hook is called only if enabled during configuration. That is, if a user wishes to use a particular hook, they must enable its use and define its body.","title":"User Hook"},{"location":"src/glossary/#timeout","text":"A time interval, specified by an integer-type object, used for organizing conditional or unconditional event waiting by processes.","title":"Timeout"},{"location":"src/glossary/#tos","text":"Top Of Stack. The address of the stack element pointed to by the processor's hardware stack pointer.","title":"TOS"},{"location":"src/ipcs/","text":"Interprocess Communication Services \ud83d\udd17 Introduction \ud83d\udd17 Starting with version 4, scmRTOS employs a fundamentally different mechanism for implementing interprocess communication services compared to previous versions. Previously, each service class was developed individually and had no connection to the others, and to access kernel resources, service classes were declared as \"friends\" of the kernel. This approach did not allow for code reuse 1 and offered no possibility to extend the set of services, which led to the decision to abandon it and design a variant free from both shortcomings. The implementation is based on the concept of extending OS functionality by defining extension classes through inheritance from TKernelAgent (see \"TKernelAgent and Extensions\" ). The key class for building interprocess communication services is the TService class, which implements the common functionality for all service classes. All of them are descendants of TService . This applies both to the standard set of services included in the OS distribution and to those developed 2 as extensions to the standard range of services. The interprocess communication services included in scmRTOS are: OS::TEventFlag ; OS::TMutex ; OS::message ; OS::channel ; TService \ud83d\udd17 Class Definition \ud83d\udd17 The code for the base class used to build service types: 01 class TService : protected TKernelAgent 02 { 03 protected : 04 TService () : TKernelAgent () { } 05 06 INLINE static TProcessMap cur_proc_prio_tag () { return get_prio_tag ( cur_proc_priority ()); } 07 INLINE static TProcessMap highest_prio_tag ( TProcessMap map ) 08 { 09 # if scmRTOS_PRIORITY_ORDER == 0 10 return map & ( ~ static_cast < unsigned > ( map ) + 1 ); // Isolate rightmost 1-bit. 11 # else // scmRTOS_PRIORITY_ORDER == 1 12 return get_prio_tag ( highest_priority ( map )); 13 # endif 14 } 15 16 //---------------------------------------------------------------------- 17 // 18 // Base API 19 // 20 21 // add prio_tag proc to waiters map, reschedule 22 INLINE void suspend ( TProcessMap volatile & waiters_map ); 23 24 // returns false if waked-up by timeout or TBaseProcess::wake_up() | force_wake_up() 25 INLINE static bool is_timeouted ( TProcessMap volatile & waiters_map ); 26 27 // wake-up all processes from waiters map 28 // return false if no one process was waked-up 29 static bool resume_all ( TProcessMap volatile & waiters_map ); 30 INLINE static bool resume_all_isr ( TProcessMap volatile & waiters_map ); 31 32 // wake-up next ready (most priority) process from waiters map if any 33 // return false if no one process was waked-up 34 static bool resume_next_ready ( TProcessMap volatile & waiters_map ); 35 INLINE static bool resume_next_ready_isr ( TProcessMap volatile & waiters_map ); 36 }; Listing 1. TService Similar to its ancestor class TKernelAgent , the TService class does not allow objects of its own type to be created: its purpose is to provide a base for building specific types\u2014interprocess communication services. The interface of this class consists of a set of functions that express the common actions of any service class within the context of control transfer between processes. Logically, these functions can be divided into two parts: core functions and utility functions. The utility functions are: TService::cur_proc_prio_tag() . Returns the tag 3 corresponding to the currently active process. This tag is actively used by the core service functions to record the identifiers 4 of processes when placing the current process into a waiting state. TService::highest_prio_tag() . Returns the tag of the highest-priority process from the process map passed as an argument. It is used primarily to obtain the identifier (of the process) from the process map of a service object, corresponding to the process that should be transitioned to the ready state. The core functions are: TService::suspend() . Transfers the process to a not-ready state, records the process identifier in the service's process map, and calls the OS scheduler. This function forms the basis of the service member functions used for waiting for an event ( wait() , pop() , read() ) or actions that might cause waiting for a resource to be released ( lock() , push() , write() ). TService::is_timeouted() . This function returns false if the process was transitioned to the ready state by calling a service member function; however, if the process was transitioned to the ready state due to a timeout 5 or forcibly using the TBaseProcess member functions wake_up() and force_wake_up() , then the function returns true . The result of this function is used to determine whether the process received the event (resource release) it was waiting for or not. TService::resume_all() . This function checks for the presence of processes \"recorded\" in the service's process map but currently in a not-ready state 6 ; if such processes exist, all of them are transitioned to the ready state and the scheduler is called. In this case, the function returns true ; otherwise, it returns false . TService::resume_next_ready() . This function performs actions similar to the resume_all() function described above, with the difference that if there are waiting processes, not all of them are transitioned to the ready state, but only one\u2014the highest-priority one. For the resume_all() and resume_next_ready() functions, there are versions optimized for use inside interrupt handlers\u2014these are resume_all_isr() and resume_next_ready_isr() . In purpose and meaning, they are similar to the main variants 7 ; the key difference is that they do not call the scheduler. Usage \ud83d\udd17 Preliminary Remarks \ud83d\udd17 Any service class is created from TService through inheritance. To illustrate the usage of TService and the creation of a service class based on it, we will examine one of the standard interprocess communication services\u2014 TEventFlag : class TEventFlag : public TService { ... } The service class TEventFlag itself will be described in detail later. For the continuity of the narrative at this point, it should be noted that this interprocess communication service is used to synchronize the work of processes in accordance with occurring events. The main idea of its usage is: one process waits for an event using the class member function TEventFlag::wait() , while another process 8 , upon the occurrence of an event that should be handled by the waiting process, signals the flag using the member function TEventFlag::signal() . Given the above, the main focus when examining the usage example will be on these two functions, as they carry the primary semantic load of the service class 9 , and its development essentially boils down to the development of such functions. Requirements for the Functions of the Class Being Developed \ud83d\udd17 Requirements for the event flag waiting function. The function must check whether the event has occurred at the moment of the function call. If the event has not occurred, it must be able to wait 10 for the event either unconditionally or with a timeout condition. If the function returns due to the event, the return value should be true ; if it returns due to a timeout, the return value should be false . Requirements for the event flag signaling function. The function must transition all processes waiting for the event flag to the ready state and transfer control to the scheduler. Implementation \ud83d\udd17 Inside the member function wait() (see \"Listing 2. Function TEventFlag::wait()\"), the first step is to check if the event has already been signaled. If it has, the function returns true . If the event has not been signaled (i.e., it needs to be waited for), preparatory actions are performed\u2014in particular, the waiting timeout value is written to the Timeout variable of the current process, and the suspend() function, defined in the base class TService , is called. This function writes the tag of the current process into the process map of the event flag object (passed to suspend() as an argument), transitions this process to a not-ready state, and yields control to other processes by calling the scheduler. Upon returning from suspend() , which means this process has been transitioned back to the ready state, a check is performed to determine what caused the \"wake-up\" of this process. This is done by calling the is_timeouted() function. It returns false if the process was \"awakened\" via a call to TEventFlag::signal() \u2014i.e., the awaited event occurred (and no timeout happened). It returns true if the process \"wake-up\" occurred due to the expiration of the timeout specified in the TEventFlag::wait() argument, or if it was forced. This logic of the TEventFlag::wait() member function allows it to be effectively used in user code when organizing process work synchronized with the occurrence of required events 11 . Moreover, the implementation code of this function is simple and transparent. 01 bool OS :: TEventFlag :: wait ( timeout_t timeout ) 02 { 03 TCritSect cs ; 04 05 if ( Value ) // if flag already signaled 06 { 07 Value = efOff ; // clear flag 08 return true ; 09 } 10 else 11 { 12 cur_proc_timeout () = timeout ; 13 14 suspend ( ProcessMap ); 15 16 if ( is_timeouted ( ProcessMap )) 17 return false ; // waked up by timeout or by externals 18 19 cur_proc_timeout () = 0 ; 20 return true ; // otherwise waked up by signal() or signal_isr() 21 } 22 } Listing 2. Function TEventFlag::wait() 1 void OS :: TEventFlag :: signal () 2 { 3 TCritSect cs ; 4 if ( ! resume_all ( ProcessMap )) // if no one process was waiting for flag 5 Value = efOn ; 6 } Listing 3. Function TEventFlag::signal() The code for the TEventFlag::signal() function (see \"Listing 3. Function TEventFlag::signal()\") is extremely simple: inside it, all processes waiting for this event flag are transitioned to the ready state, and rescheduling is performed. If no such processes were found, the internal flag variable Value is set to efOn (true), which means the event occurred but hasn't been handled by anyone yet. Any interprocess communication service can be designed and defined in a similar manner. During its development, it is only necessary to have a clear understanding of what the member functions of the TService class do and to use them appropriately. OS::TEventFlag \ud83d\udd17 During program execution, there is often a need for synchronization between processes. For example, one of the processes may need to wait for an event to perform its work. It can handle this in different ways: it can simply poll a global flag in a loop or do the same with some periodicity\u2014i.e., poll, \"go to sleep\" with a timeout, \"wake up,\" poll again, etc. The first method is bad because all processes with lower priority will not gain control, as due to their lower priorities, they cannot preempt the process polling the global flag in a loop. The second method is also bad\u2014the polling period becomes quite large (i.e., time resolution is low), and during polling, the process will occupy the CPU with context switches, even though it is unknown whether the event has occurred. A proper solution in this situation is to transition the process to a state of waiting for the event and transfer control to the process only when the event occurs. This functionality in scmRTOS is implemented using OS::TEventFlag objects (event flag). The class definition is shown in \"Listing 4. OS::TEventFlag\". 01 class TEventFlag : public TService 02 { 03 public : 04 enum TValue { efOn = 1 , efOff = 0 }; // prefix 'ef' means: \"Event Flag\" 05 06 public : 07 INLINE TEventFlag ( TValue init_val = efOff ); 08 09 bool wait ( timeout_t timeout = 0 ); 10 INLINE void signal (); 11 INLINE void clear () { TCritSect cs ; Value = efOff ; } 12 INLINE void signal_isr (); 13 INLINE bool is_signaled () { TCritSect cs ; return Value == efOn ; } 14 15 private : 16 volatile TProcessMap ProcessMap ; 17 volatile TValue Value ; 18 }; Listing 4. OS::TEventFlag Interface \ud83d\udd17 wait \ud83d\udd17 Prototype \ud83d\udd17 bool OS::TEventFlag::wait ( timeout_t timeout ); Description \ud83d\udd17 Waits for an event. When the wait() function is called, the following occurs: it checks if the flag is set. If it is set, the flag is cleared and the function returns true , meaning the event had already occurred at the time of the check. If the flag is not set (i.e., the event has not yet occurred), the process is transitioned to a state of waiting for this flag (event) and control is yielded to the kernel, which, after rescheduling processes, will run the next one. If the function is called without arguments (or with an argument equal to 0), the process will remain in the waiting state until the event flag is \"signaled\" by another process or an interrupt handler (using the signal() function) or is brought out of the inactive state using the TBaseProcess::force_wake_up() function (in the latter case, extreme caution is required). If wait() is called without an argument, it always returns true . If the function is called with an argument (an integer greater than 0) specifying the waiting timeout in system timer ticks, the process will wait for the event as in the case of a call without an argument. However, if the event flag is not \"signaled\" within the specified period, the process will be \"awakened\" by the timer and the function will return false . This implements both unconditional waiting and waiting with a timeout. signal \ud83d\udd17 Prototype \ud83d\udd17 INLINE void OS :: TEventFlag :: signal (); Description \ud83d\udd17 A process that wishes to notify other processes via a TEventFlag object that a particular event has occurred must call the signal() function. As a result, all processes waiting for the specified event will be transitioned to the ready state, and the highest-priority among them will gain control (the others will follow in order of their priorities). signal from ISR \ud83d\udd17 Prototype \ud83d\udd17 INLINE void OS :: TEventFlag :: signal_isr (); Description \ud83d\udd17 A variant of the above function optimized for use in interrupts. The function is inline and uses a special lightweight inline version of the scheduler. This variant must not be used outside of interrupt handler code. clear \ud83d\udd17 Prototype \ud83d\udd17 INLINE void OS :: TEventFlag :: clear (); Description \ud83d\udd17 Clears the flag. Sometimes, for synchronization, it is necessary to wait for the next event, not to handle an already occurred one. In this case, the event flag must be cleared before proceeding to wait. The clear() function is used for this purpose. check if signaled \ud83d\udd17 Prototype \ud83d\udd17 INLINE bool OS :: TEventFlag :: is_signaled (); Description \ud83d\udd17 Checks the state of the flag. It is not always necessary to wait for an event by yielding control. Sometimes, based on the program's logic, it is only necessary to check whether the event has occurred. Usage Example \ud83d\udd17 An example of using an event flag is shown in \"Listing 5. Using TEventFlag\". In this example, process Proc1 waits for an event with a timeout of 10 system timer ticks (9). The second process, Proc2 , \"signals\" the flag when a condition is met (27). If the first process has higher priority, it will gain control immediately. 01 OS :: TEventFlag eflag ; 02 ... 03 //---------------------------------------------------------------- 04 template <> void Proc1 :: exec () 05 { 06 for (;;) 07 { 08 ... 09 if ( eflag . wait ( 10 ) ) // wait event for 10 ticks 10 { 11 ... // do something 12 } 13 else 14 { 15 ... // do something else 16 } 17 ... 18 } 19 } 20 ... 21 //---------------------------------------------------------------- 22 template <> void Proc2 :: exec () 23 { 24 for (;;) 25 { 26 ... 27 if ( ... ) eflag . signal (); 28 ... 29 } 30 } 31 //---------------------------------------------------------------- Listing 5. Using TEventFlag NOTE When an event occurs and a process \"signals\" the flag, all processes that were waiting for this flag will be transitioned to the ready state. In other words, everyone who was waiting has now received the event. They will, of course, gain control in the order of their priorities, but the event will not be missed by any process that managed to start waiting, regardless of its priority. Thus, an event flag exhibits broadcast behavior , which is very useful for organizing notifications and synchronizing multiple processes based on a single event. Of course, nothing prevents using an event flag in a \"point-to-point\" scheme where there is only one process waiting for the event. OS::TMutex \ud83d\udd17 The Mutex semaphore (from Mutual Exclusion), as the name suggests, is designed to organize mutual exclusion of access. That is, at any given moment, no more than one process can hold this semaphore. If any process attempts to lock a Mutex that is already held by another process, the attempting process will wait until the semaphore is released. The primary use of Mutex semaphores is to organize mutual exclusion when accessing a particular resource. For example, a static array with global visibility 12 is used by two processes to exchange data. To avoid errors during the exchange, it is necessary to prevent one process from having access to the array during the period when another process is working with it. Using a critical section for this is not the best approach, as interrupts would be disabled for the entire time the process accesses the array. This time might be significant, and during it, the system would be unable to respond to events. In this situation, a mutual exclusion semaphore is perfectly suitable: a process planning to work with a shared resource must first lock the Mutex semaphore. After that, it can safely work with the resource. Upon completion of the work, the semaphore must be released so that other processes can access it. It goes without saying that all processes working with the shared resource should behave this way, i.e., access it through the semaphore 13 . These same considerations fully apply to calling a non-reentrant 14 function. WARNING When using mutual exclusion semaphores, a situation may arise where one process, having locked a semaphore and working with the corresponding resource, attempts to access another resource, which is also accessed by locking another semaphore. This second semaphore is already locked by another process, which, in turn, is trying to access the resource already being used by the first process. As a result, both processes are waiting for each other to release the locked resource, and until that happens, neither can continue its work. This situation is called a \"deadlock\" 15 . In English-language literature, it is denoted by the word \"Deadlock.\" To avoid it, the programmer must carefully monitor access to shared resources. A good rule to prevent the situation described above is to lock no more than one mutual exclusion semaphore at a time. In any case, success here is based on the attentiveness and discipline of the program developer. For implementing binary semaphores of this type, scmRTOS defines the OS::TMutex class. See \"Listing 6. OS::TMutex\". 01 class TMutex : public TService 02 { 03 public : 04 INLINE TMutex () : ProcessMap ( 0 ), ValueTag ( 0 ) { } 05 void lock (); 06 void unlock (); 07 void unlock_isr (); 08 09 INLINE bool try_lock () { TCritSect cs ; if ( ValueTag ) return false ; 10 else lock (); return true ; } 11 INLINE bool is_locked () const { TCritSect cs ; return ValueTag != 0 ; } 12 13 private : 14 volatile TProcessMap ProcessMap ; 15 volatile TProcessMap ValueTag ; 16 17 }; Listing 6. OS::TMutex Obviously, before use, the semaphore must be created. Due to the specifics of its application, the semaphore should have the same storage class and scope as the resource it serves, i.e., it should be a static object with global visibility 16 . Interface \ud83d\udd17 lock \ud83d\udd17 Prototype \ud83d\udd17 void TMutex::lock (); Description \ud83d\udd17 Performs a blocking lock: if the semaphore was not previously locked by another process, its internal state is set to \"locked,\" and the execution flow returns to the calling function. If the semaphore was already locked, the process will transition to a waiting state until the semaphore is released, and control is yielded to the kernel. unlock \ud83d\udd17 Prototype \ud83d\udd17 void TMutex::unlock (); Description \ud83d\udd17 The function sets the internal state to \"unlocked\" and checks if any other process is waiting for this semaphore. If there is, control is yielded to the kernel, which will reschedule processes so that if the waiting process had higher priority, it will immediately gain control. If several processes were waiting for the semaphore, the highest-priority one among them will gain control. Only the process that locked the semaphore can unlock it\u2014i.e., if this function is executed in a process that did not lock the mutex object, it will have no effect, and the object will remain in the same state. unlock from ISR \ud83d\udd17 Prototype \ud83d\udd17 INLINE void TMutex :: unlock_isr (); Description \ud83d\udd17 Sometimes a situation arises where a mutex is locked within a process, but work with the corresponding protected resource is performed in an interrupt handler (and this work is initiated in the process simultaneously with locking the mutex). In this case, it is convenient to perform the unlock directly in the interrupt handler upon completion of work with the resource. For this purpose, TMutex includes the unlock_isr() function for unlocking the semaphore directly within an interrupt. try to lock \ud83d\udd17 Prototype \ud83d\udd17 INLINE bool TMutex :: try_lock (); Description \ud83d\udd17 Non-blocking lock. The difference from lock() is that the lock will only occur if the semaphore is free. For example, a process needs to work with a resource but also has a lot of other work. Attempting to lock with lock() might cause it to wait until the semaphore is freed, whereas that time could be spent on other work if available, and work with the shared resource could be performed only when access to it is not blocked. This approach can be relevant for a high-priority process: if the semaphore is locked by a low-priority process, it is reasonable for the high-priority process not to yield control to the low-priority one if it has other work. Only when there is nothing left to do does it make sense to attempt to lock the semaphore in the usual way\u2014by yielding control (since the low-priority process must also eventually gain control to finish its tasks and release the semaphore). Considering the above, this function should be used with caution, as it could lead to a situation where a low-priority process never gains control because the high-priority one does not yield it. try to lock with timeout \ud83d\udd17 Prototype \ud83d\udd17 OS :: TMutex :: try_lock ( timeout_t timeout ); Description \ud83d\udd17 A blocking version of the previous function with a specified time interval\u2014attempts to lock the semaphore within the specified timeout. If the lock is successful, returns true ; otherwise, returns false . check if locked \ud83d\udd17 Prototype \ud83d\udd17 INLINE bool TMutex :: is_locked () Description \ud83d\udd17 The function checks the state and returns true if the semaphore is locked, and false otherwise. It is sometimes convenient to use a semaphore as a status flag, where one process sets this flag (by locking the semaphore), and other processes check it and perform actions according to the state of that process. Usage Example \ud83d\udd17 See \"Listing 7. Example of Using OS::TMutex\" for a usage example. 01 OS :: TMutex Mutex ; 02 byte buf [ 16 ]; 03 ... 04 template <> void TSlon :: exec () 05 { 06 for (;;) 07 { 08 ... // some code 09 // 10 Mutex . lock (); // resource access lock 11 for ( byte i = 0 ; i < 16 ; i ++ ) // 12 { // 13 ... // do something with buf 14 } // 15 Mutex . unlock (); // resource access unlock 16 // 17 ... // some code 18 } 19 } Listing 7. Example of Using OS::TMutex For convenience when using a mutual exclusion semaphore, the already mentioned wrapper class technique can be applied. In this case, it is implemented using the TMutexLocker class, included in the OS distribution. See \"Listing 8. Wrapper Class OS::TMutexLocker\". 01 template < typename Mutex > 02 class TScopedLock 03 { 04 public : 05 TScopedLock ( Mutex & m ) : mx ( m ) { mx . lock (); } 06 ~ TScopedLock () { mx . unlock (); } 07 private : 08 Mutex & mx ; 09 }; 10 11 typedef TScopedLock < OS :: TMutex > TMutexLocker ; Listing 8. Wrapper Class OS::TMutexLocker The methodology for using objects of this class is no different from using other wrapper classes\u2014 TCritSect , TISRW . ABOUT PRIORITY INVERSION A few words should be said about a mechanism related to mutual exclusion semaphores: priority inversion. The idea of priority inversion arises from the following situation. For example, a system has several processes, and processes with priorities N 17 and N+n, where n>1, use the same resource, sharing work via a mutual exclusion semaphore. At some point, the process with priority N+n locks the semaphore and is working with the shared resource. During this, an event occurs that activates the process with priority N, which attempts to access the shared resource and, in trying to lock the semaphore, transitions to a waiting state. It will remain in this state until the process with priority N+n unlocks the semaphore. The delay of the higher-priority process in this situation is forced, as it is impossible to take control away from the process with priority N+n without violating the logic of its work and the integrity of access to the shared resource. Knowing this, the developer typically tries to minimize the time spent working with the resource so that the low-priority process does not block the work of the high-priority one. However, there is an unpleasant aspect to this situation: if at the moment described above a process with priority, for example, N+1, becomes active, it will preempt the process with priority N+n (since n>1) and thereby introduce an additional delay for the waiting higher-priority process with priority N. The situation is aggravated by the fact that the program developer usually does not connect the work of the process with priority N+1 with the manipulations of processes with priorities N and N+n on the shared resource. Therefore, they might not consider optimizing the work of the process with priority N+1 in relation to this, which could completely block the work of the process with priority N for an unpredictable amount of time. This is a highly undesirable situation. To avoid this, a technique called \"priority inversion\" is used. Its essence is that if a high-priority process attempts to lock a mutual exclusion semaphore that is already locked by a low-priority process, a temporary exchange of priorities occurs until the semaphore is unlocked. In effect, the low-priority process runs with the priority of the process that attempted to lock the semaphore. In this case, the situation described above, where a low-priority process blocks the work of a high-priority one, becomes impossible. Despite the coherence and elegance of the priority inversion method, it is not without drawbacks. The main one is that its technical implementation incurs overhead comparable to or exceeding the cost of implementing the mutual exclusion semaphore functionality itself. It might turn out that switching process priorities and everything associated with it\u2014requiring consideration of all OS elements related to the priorities of processes involved in the inversion\u2014slows down the system to an unacceptable level. In connection with this, the priority inversion mechanism is not used in the current version of scmRTOS . Instead, to solve the aforementioned problem of a high-priority process being blocked by a low-priority one, a task delegation mechanism is proposed, discussed in detail in \"Appendix A Usage Examples, A.1 Task Queue.\" This represents a unified method for redistributing the execution of contextually related code among processes with different priorities. OS::message \ud83d\udd17 OS::message is a C++ template for creating objects that implement inter-process communication by transmitting structured data. OS::message is similar to OS::TEventFlag and differs mainly in that, besides the flag itself, it also contains an object of an arbitrary type constituting the actual message body. The template definition is shown in \"Listing 9 OS::message\". As can be seen from the listing, the message template is built upon the TBaseMessage class. This is done for efficiency reasons, to avoid duplicating common code in template instances\u2014the code common to all messages is moved to the level of the base class 18 . 01 class TBaseMessage : public TService 02 { 03 public : 04 INLINE TBaseMessage () : ProcessMap ( 0 ), NonEmpty ( false ) { } 05 06 bool wait ( timeout_t timeout = 0 ); 07 INLINE void send (); 08 INLINE void send_isr (); 09 INLINE bool is_non_empty () const { TCritSect cs ; return NonEmpty ; } 10 INLINE void reset () { TCritSect cs ; NonEmpty = false ; } 11 12 private : 13 volatile TProcessMap ProcessMap ; 14 volatile bool NonEmpty ; 15 }; 16 17 template < typename T > 18 class message : public TBaseMessage 19 { 20 public : 21 INLINE message () : TBaseMessage () { } 22 INLINE const T & operator = ( const T & msg ) 23 { 24 TCritSect cs ; 25 * ( const_cast < T *> ( & Msg )) = msg ; return const_cast < const T &> ( Msg ); 26 } 27 INLINE operator T () const 28 { 29 TCritSect cs ; 30 return const_cast < const T &> ( Msg ); 31 } 32 INLINE void out ( T & msg ) { TCritSect cs ; msg = const_cast < T &> ( Msg ); } 33 34 private : 35 volatile T Msg ; 36 }; Listing 9. OS::message Interface \ud83d\udd17 send \ud83d\udd17 Prototype \ud83d\udd17 INLINE void OS :: TBaseMessage :: send (); Description \ud83d\udd17 Sends a message 19 . The operation involves transitioning processes waiting for the message to the ready state and calling the scheduler. send from ISR \ud83d\udd17 Prototype \ud83d\udd17 INLINE void OS :: TBaseMessage :: send_isr (); Description \ud83d\udd17 A variant of the above function optimized for use in interrupts. The function is inline and uses a special lightweight inline version of the scheduler. This variant must not be used outside of interrupt handler code . wait \ud83d\udd17 Prototype \ud83d\udd17 bool OS::TBaseMessage::wait ( timeout_t timeout ); Description \ud83d\udd17 Waits for a message 20 . The function checks if the message is non-empty. If it is non-empty, it returns true . If it is empty, it transitions the current process from the ready state to a state of waiting for this message. If no argument is specified during the call or if the argument is 0, waiting will continue until some process sends a message or the current process is \"awakened\" using the TBaseProcess::force_wake_up() function 21 . If an integer is specified as an argument, representing the timeout value expressed in system timer ticks, then waiting for the message will occur with a timeout, i.e., the process will be \"awakened\" in any case. If this happens before the timeout expires, meaning a message arrives before the timeout, the function returns true . Otherwise, i.e., if the timeout expires before the message is sent, the function returns false . check if non-empty \ud83d\udd17 Prototype \ud83d\udd17 INLINE bool OS :: TBaseMessage :: is_non_empty (); Description \ud83d\udd17 The function returns true if a message has been sent, and false otherwise. reset \ud83d\udd17 Prototype \ud83d\udd17 INLINE OS::TBaseMessage::reset (); Description \ud83d\udd17 The function resets the message, i.e., transitions it to the empty state. The message body remains unchanged. write message contents \ud83d\udd17 Prototype \ud83d\udd17 template < typename T > INLINE const T & OS :: message < T >:: operator = ( const T & msg ); Description \ud83d\udd17 Writes the actual message contents into the message object. The standard way to use OS::message is to write the message body and send the message using the TBaseMessage::send() function\u2014see \"Listing 10. Using OS::message\". access message body by reference \ud83d\udd17 Prototype \ud83d\udd17 template < typename T > INLINE OS :: message < T >:: operator T () const ; Description \ud83d\udd17 Returns a constant reference to the message body. This facility should be used with caution, bearing in mind that while accessing the message body via a reference, it might be modified in another process (or interrupt handler). Therefore, it is recommended to use the message::out() function for reading the message body. read message contents \ud83d\udd17 Prototype \ud83d\udd17 template < typename T > INLINE OS :: message < T >:: out ( T & msg ); Description \ud83d\udd17 The function is intended for reading the message body. For efficiency, to avoid unnecessary copying of the message body, a reference to an external message body object is passed to the function. Inside the function, the message contents are copied into this external object. Usage Example \ud83d\udd17 01 struct TMamont { ... } // data type for sending by message 02 03 OS :: message < Mamont > mamont_msg ; // OS::message object 04 05 template <> void Proc1 :: exec () 06 { 07 for (;;) 08 { 09 Mamont mamont ; 10 mamont_msg . wait (); // wait for message 11 mamont_msg . out ( mamont ); // read message contents to the external object 12 ... // using the Mamont contents 13 } 14 } 15 16 template <> void Proc2 :: exec () 17 { 18 for (;;) 19 { 20 ... 21 Mamont m ; // create message content 22 23 m ... = // message body filling 24 mamont_msg = m ; // put the content to the OS::message object 25 mamont_msg . send (); // send the message 26 ... 27 } 28 } Listing 10. Using OS::message OS::channel \ud83d\udd17 OS::channel is a C++ template for creating objects that implement ring buffers 22 for the safe transmission of data of arbitrary types within a preemptive OS. Like any other interprocess communication service, OS::channel solves synchronization problems. The specific buffer type is specified during the template instantiation 23 in the user code. The OS::channel template is based on the ring buffer template defined in the library included in the scmRTOS distribution: usr :: ring_buffer < class T , uint16_t size , class S = uint8_t > ` Building channels using C++ templates provides an efficient means for constructing message queues of arbitrary types. Unlike the dangerous, non-transparent, and inflexible method of organizing message queues based on void * pointers, the OS::channel queue offers: Safety through static type checking , both when creating the queue/channel and when writing data to it or reading from it. Ease of use \u2014no need for manual type casting, which requires keeping extra information in mind about the real data types transmitted through the channel for their correct use. Significantly greater flexibility \u2014queue objects can be of any type, not just pointers. Regarding the last point, a few words should be said: one drawback of using void * pointers as a basis for message passing is that the user must allocate memory for the messages themselves somewhere. This is extra work, and the target object becomes distributed\u2014the queue is in one place, while the actual content of the queue elements is elsewhere. The main advantages of the pointer-based message mechanism are high efficiency for large message bodies and the ability to transmit messages of varying formats. However, if, for example, messages are small\u2014a few bytes\u2014and all have the same format, there is no need for pointers. It's much simpler to create a queue of the required number of such messages, and that's it. In this case, as mentioned, there's no need to allocate memory for the message bodies\u2014since messages are placed entirely into the channel queue, memory for them will be automatically allocated by the compiler directly when creating the channel. The channel template definition is shown in \"Listing 11. Definition of the OS::channel Template\". 01 template < typename T , uint16_t Size , typename S = uint8_t > 02 class channel : public TService 03 { 04 public : 05 INLINE channel () : ProducersProcessMap ( 0 ) 06 , ConsumersProcessMap ( 0 ) 07 , pool () 08 { 09 } 10 11 //---------------------------------------------------------------- 12 // 13 // Data transfer functions 14 // 15 void write ( const T * data , const S cnt ); 16 bool read ( T * const data , const S cnt , timeout_t timeout = 0 ); 17 18 void push ( const T & item ); 19 void push_front ( const T & item ); 20 21 bool pop ( T & item , timeout_t timeout = 0 ); 22 bool pop_back ( T & item , timeout_t timeout = 0 ); 23 24 //---------------------------------------------------------------- 25 // 26 // Service functions 27 // 28 INLINE S get_count () const ; 29 INLINE S get_free_size () const ; 30 void flush (); 31 32 private : 33 volatile TProcessMap ProducersProcessMap ; 34 volatile TProcessMap ConsumersProcessMap ; 35 usr :: ring_buffer < T , Size , S > pool ; 36 }; Listing 11. Definition of the OS::channel Template OS::channel is used as follows: first, define the type of objects to be transmitted through the channel, then define the channel type or create a channel object. For example, suppose the data transmitted through the channel is a structure: struct Data { int a ; char * p ; }; Now, you can create a channel object by instantiating the OS::channel template: OS :: channel < Data , 8 > data_queue ; This code declares a channel object data_queue for transmitting objects of type Data , with a channel capacity of 8 objects. The channel is now ready for use. OS::channel provides the ability to write data not only to the end of the queue but also to the beginning, and to read data not only from the beginning but also from the end of the queue. When reading, it is also possible to specify a timeout value. The following interface is provided for operating on a channel object: Interface \ud83d\udd17 push \ud83d\udd17 Prototype \ud83d\udd17 template < typename T , uint16_t Size , typename S > void OS :: channel < T , Size , S >:: push ( const T & item ); Description \ud83d\udd17 Pushes one element to the end of the queue 24 . If there was space in the channel at the time of writing, the element is written to the queue and the scheduler is called. If there was no space, the process transitions to a waiting state until space becomes available in the channel. When space appears, the element will be written, followed by a call to the scheduler. push front \ud83d\udd17 Prototype \ud83d\udd17 template < typename T , uint16_t Size , typename S > void OS :: channel < T , Size , S >:: push_front ( const T & item ); Description \ud83d\udd17 Pushes an element to the beginning of the queue. In all other respects, the logic of operation is exactly the same as for channel::push() . pop \ud83d\udd17 Prototype \ud83d\udd17 template < typename T , uint16_t Size , typename S > bool OS :: channel < T , Size , S >:: pop ( T & item , timeout_t timeout ); Description \ud83d\udd17 Pops one element from the beginning of the queue if the channel was not empty. If the channel was empty, the process transitions to a waiting state until data appears in it or until the timeout expires, if a timeout was specified 25 . In case of a call with a timeout: if data arrives before the timeout expires, the function returns true ; otherwise, it returns false . If the call was made without a timeout, the function always returns true , except when awakened by OS::TBaseProcess::wake_up() or OS::TBaseProcess::force_wake_up() . In all cases, when an element is popped, the scheduler is called. Note that when calling this function, the data popped from the channel is not returned by copying from the function but is passed via a reference to an object. This is because the return value is used to convey the timeout result. pop back \ud83d\udd17 Prototype \ud83d\udd17 template < typename T , uint16_t Size , typename S > bool OS :: channel < T , Size , S >:: pop_back ( T & item , timeout_t timeout ); Description \ud83d\udd17 Pops one element from the end of the queue if the channel was not empty. All functionality is exactly the same as for channel::pop() . write \ud83d\udd17 Prototype \ud83d\udd17 template < typename T , uint16_t Size , typename S > void OS :: channel < T , Size , S >:: write ( const T * data , const S count ); Description \ud83d\udd17 Writes several elements from memory at the given address to the end of the queue. Essentially, this is the same as pushing one element to the end of the queue ( push ), except that not one but the specified number of elements are written. In case of waiting, it continues until enough space becomes available in the channel. write inside ISR \ud83d\udd17 Prototype \ud83d\udd17 template < typename T , uint16_t Size , typename S > S OS :: channel < T , Size , S >:: write_isr ( const T * data , const S count ); Description \ud83d\udd17 A special version for use inside interrupt handlers. The function writes as many elements as the free space in the channel allows (but no more than the specified count) and returns the number of elements written. Processes waiting for data from the channel are transitioned to the ready state. The call is non-blocking . The scheduler is not called. read \ud83d\udd17 Prototype \ud83d\udd17 template < typename T , uint16_t Size , typename S > bool OS :: channel < T , Size , S >:: read ( T * const data , const S count , timeout_t timeout ); Description \ud83d\udd17 Pops several elements from the channel. This is the same as channel::pop() , except that not one but the specified number of elements are popped. If waiting occurs, it continues until the required number of elements is available in the channel or until the timeout triggers (if used). read inside ISR \ud83d\udd17 Prototype \ud83d\udd17 template < typename T , uint16_t Size , typename S > S OS :: channel < T , Size , S >:: read_isr ( T * const data , const S max_size ); Description \ud83d\udd17 A special version for use inside interrupt handlers. The function reads as many elements as are present in the channel (but no more than the specified count) and returns the number of elements written. Processes waiting for free space to appear in the channel are transitioned to the ready state. The call is non-blocking . The scheduler is not called. get item count \ud83d\udd17 Prototype \ud83d\udd17 template < typename T , uint16_t Size , typename S > S OS :: channel < T , Size , S >:: get_count (); Description \ud83d\udd17 Returns the number of elements currently in the channel. The function is inline , so its efficiency is maximized. get free size \ud83d\udd17 Prototype \ud83d\udd17 template < typename T , uint16_t Size , typename S > S OS :: channel < T , Size , S >:: get_free_size (); Description \ud83d\udd17 Returns the amount of free space available in the channel. flush \ud83d\udd17 Prototype \ud83d\udd17 template < typename T , uint16_t Size , typename S > S OS :: channel < T , Size , S >:: flush (); Description \ud83d\udd17 Clears the channel. The function clears the buffer by calling usr::ring_buffer<>::flush() and calls the scheduler. Usage Example \ud83d\udd17 A simple usage example is shown in \"Listing 12. Example of Using a Queue Based on a Channel\". 01 //--------------------------------------------------------------------- 02 struct Cmd 03 { 04 enum CmdName { cmdSetCoeff1 , cmdSetCoeff2 , cmdCheck } CmdName ; 05 int Value ; 06 }; 07 08 OS :: channel < Cmd , 10 > cmd_q ; // Queue for Commands with 10 items depth 09 //--------------------------------------------------------------------- 10 template <> void Proc1 :: exec () 11 { 12 ... 13 Cmd cmd = { cmdSetCoeff2 , 12 }; 14 cmd_q . push ( cmd ); 15 ... 16 } 17 //--------------------------------------------------------------------- 18 template <> void Proc2 :: exec () 19 { 20 ... 21 Cmd cmd ; 22 if ( cmd_q . pop ( cmd , 10 ) ) // wait for data, timeout 10 system ticks 23 { 24 ... // data incoming, do something 25 } 26 else 27 { 28 ... // timeout expires, do something else 29 } 30 ... 31 } 32 //--------------------------------------------------------------------- Listing 12. Example of Using a Queue Based on a Channel. As can be seen, usage is quite simple and transparent. In one process (Proc1), a command message cmd is created (13), initialized with the required values, and written to the channel queue (14). In another process (Proc2), there is a wait for data from the queue (22). If data arrives, the corresponding code is executed (23)-(25); if the timeout expires, different code is executed (27)-(29). Final Remarks \ud83d\udd17 There is a certain invariant relationship among different interprocess communication services. That is, using some services (or, more often, a combination thereof), you can accomplish the same task as with others. For example, instead of using a channel, you could create a static array and exchange data through it using mutual exclusion semaphores to prevent concurrent access and event flags to notify the waiting process that data is ready for it. In some cases, such an implementation might be more efficient, albeit less convenient. You could use messages for event synchronization instead of event flags\u2014this approach makes sense if you also need to transmit some information along with the flag. In fact, that's precisely what OS::message is designed for. The variety of uses is great, and which option is best suited for a particular situation is determined primarily by the situation itself. TIP It is necessary to understand and remember that any interprocess communication service, while performing its functions, does so within a critical section, i.e., with interrupts disabled. Therefore, you should not overuse interprocess communication services where they can be avoided. For example, using a mutual exclusion semaphore when accessing a static variable of a built-in type is not a good idea compared to simply using a critical section, because the semaphore also uses critical sections when locking and unlocking, and the time spent in them is longer than during simple variable access. There are certain peculiarities when using services within interrupts. For example, it is obvious that using TMutex::lock() inside an interrupt handler is a rather bad idea because, firstly, mutual exclusion semaphores are intended for resource sharing at the process level, not the interrupt level. Secondly, waiting for a resource to be released inside an interrupt handler will not work anyway and will only lead to the process interrupted by this interrupt being transitioned to a waiting state at an inappropriate and unpredictable point. Effectively, the process will be placed in an inactive state, from which it can only be recovered using the TBaseProcess::force_wake_up() function. In any case, nothing good will come of this. A somewhat similar situation can arise when using channel objects in an interrupt handler. You cannot wait for data from a channel inside an ISR, and the consequences will be similar to those described above. Writing data to a channel is also not entirely safe. If, for instance, there is insufficient space in the channel when writing, the program's behavior will be far from what the user expects. RECOMMENDATION For work inside interrupts, you should use the service member functions with the _isr suffix\u2014these are specially developed versions that ensure efficiency and safe use of interprocess communication services within interrupts. And, of course, if the existing set of interprocess communication services does not meet the needs of a particular project for some reason, it is always possible to design a custom service class based on the provided foundation in the form of TService . In doing so, the standard set of services can serve as design examples. Since interprocess communication services perform similar actions when interacting with kernel resources, they contain, in places, nearly identical code. \u21a9 Or can be developed by the user for their project's needs. \u21a9 A process tag is technically a mask of type TProcessMap with only one non-zero bit. The position of this bit in the mask corresponds to the process priority. Process tags are used for manipulating TProcessMap objects, which define the ready/not-ready state of processes, and also serve to record process tags. \u21a9 Along with the process priority number, the tag can also serve as a process identifier\u2014there is a one-to-one correspondence between the priority number and the process tag. Each type of identifier has advantages in terms of efficiency in specific situations, so both types are used extensively in the OS code. \u21a9 In other words, \"awakened\" in the system timer interrupt handler. \u21a9 That is, processes whose waiting state has not been interrupted by a timeout and/or forcibly using TBaseProcess::wake_up() and TBaseProcess::force_wake_up() . \u21a9 Therefore, a full description of them is not provided. \u21a9 Or an interrupt handler\u2014depending on the source of the events. For interrupt handlers, there is a special version of the function that signals the flag, but in the context of the current description, this nuance is omitted as non-essential. \u21a9 The rest of its representation is auxiliary in nature and serves to give completeness to the class and improve its user characteristics. \u21a9 I.e., yield control to the system kernel and remain in passive waiting. \u21a9 Including when such events do not occur within the specified time interval. \u21a9 So that various parts of the program have access to it. \u21a9 General rule: all processes working with a shared resource must behave this way, i.e., perform access through the semaphore. \u21a9 A function that uses objects with non-local storage class during its operation. Therefore, to prevent disruption of the program's integrity, such a function must not be called if an instance of the same function is already running. \u21a9 Sometimes translated as \"deadly embrace.\" \u21a9 Although nothing prevents placing a Mutex outside the process code's scope and using a pointer or reference, either directly or through wrapper classes that automate the resource unlocking process via the automatic call of the wrapper class's destructor. \u21a9 It is assumed that process execution priority is inversely related to priority numbers\u2014i.e., the process with priority 0 is the highest priority, and as priority numbers increase, process priority decreases. \u21a9 The same technique is used when building the process template: the pair class TBaseProcess \u2013 template process<> . \u21a9 Analogous to the OS::TEventFlag::signal() function. \u21a9 Analogous to the OS::TEventFlag::wait() function. \u21a9 In the latter case, extreme caution is required. \u21a9 Functionally, it's a FIFO, i.e., a queue object for data transmission following the First In, First Out scheme. \u21a9 Creation of a class instance. \u21a9 Refers to the channel's queue. Functionally, since a channel is a FIFO, the end of the queue corresponds to the FIFO input, and the beginning of the channel corresponds to the FIFO output. \u21a9 I.e., the call included a second argument\u2014an integer specifying the timeout value in system timer ticks. \u21a9","title":"Interprocess Communications"},{"location":"src/ipcs/#interprocess-communication-services","text":"","title":"Interprocess Communication Services"},{"location":"src/ipcs/#introduction","text":"Starting with version 4, scmRTOS employs a fundamentally different mechanism for implementing interprocess communication services compared to previous versions. Previously, each service class was developed individually and had no connection to the others, and to access kernel resources, service classes were declared as \"friends\" of the kernel. This approach did not allow for code reuse 1 and offered no possibility to extend the set of services, which led to the decision to abandon it and design a variant free from both shortcomings. The implementation is based on the concept of extending OS functionality by defining extension classes through inheritance from TKernelAgent (see \"TKernelAgent and Extensions\" ). The key class for building interprocess communication services is the TService class, which implements the common functionality for all service classes. All of them are descendants of TService . This applies both to the standard set of services included in the OS distribution and to those developed 2 as extensions to the standard range of services. The interprocess communication services included in scmRTOS are: OS::TEventFlag ; OS::TMutex ; OS::message ; OS::channel ;","title":"Introduction"},{"location":"src/ipcs/#tservice","text":"","title":"TService"},{"location":"src/ipcs/#class-definition","text":"The code for the base class used to build service types: 01 class TService : protected TKernelAgent 02 { 03 protected : 04 TService () : TKernelAgent () { } 05 06 INLINE static TProcessMap cur_proc_prio_tag () { return get_prio_tag ( cur_proc_priority ()); } 07 INLINE static TProcessMap highest_prio_tag ( TProcessMap map ) 08 { 09 # if scmRTOS_PRIORITY_ORDER == 0 10 return map & ( ~ static_cast < unsigned > ( map ) + 1 ); // Isolate rightmost 1-bit. 11 # else // scmRTOS_PRIORITY_ORDER == 1 12 return get_prio_tag ( highest_priority ( map )); 13 # endif 14 } 15 16 //---------------------------------------------------------------------- 17 // 18 // Base API 19 // 20 21 // add prio_tag proc to waiters map, reschedule 22 INLINE void suspend ( TProcessMap volatile & waiters_map ); 23 24 // returns false if waked-up by timeout or TBaseProcess::wake_up() | force_wake_up() 25 INLINE static bool is_timeouted ( TProcessMap volatile & waiters_map ); 26 27 // wake-up all processes from waiters map 28 // return false if no one process was waked-up 29 static bool resume_all ( TProcessMap volatile & waiters_map ); 30 INLINE static bool resume_all_isr ( TProcessMap volatile & waiters_map ); 31 32 // wake-up next ready (most priority) process from waiters map if any 33 // return false if no one process was waked-up 34 static bool resume_next_ready ( TProcessMap volatile & waiters_map ); 35 INLINE static bool resume_next_ready_isr ( TProcessMap volatile & waiters_map ); 36 }; Listing 1. TService Similar to its ancestor class TKernelAgent , the TService class does not allow objects of its own type to be created: its purpose is to provide a base for building specific types\u2014interprocess communication services. The interface of this class consists of a set of functions that express the common actions of any service class within the context of control transfer between processes. Logically, these functions can be divided into two parts: core functions and utility functions. The utility functions are: TService::cur_proc_prio_tag() . Returns the tag 3 corresponding to the currently active process. This tag is actively used by the core service functions to record the identifiers 4 of processes when placing the current process into a waiting state. TService::highest_prio_tag() . Returns the tag of the highest-priority process from the process map passed as an argument. It is used primarily to obtain the identifier (of the process) from the process map of a service object, corresponding to the process that should be transitioned to the ready state. The core functions are: TService::suspend() . Transfers the process to a not-ready state, records the process identifier in the service's process map, and calls the OS scheduler. This function forms the basis of the service member functions used for waiting for an event ( wait() , pop() , read() ) or actions that might cause waiting for a resource to be released ( lock() , push() , write() ). TService::is_timeouted() . This function returns false if the process was transitioned to the ready state by calling a service member function; however, if the process was transitioned to the ready state due to a timeout 5 or forcibly using the TBaseProcess member functions wake_up() and force_wake_up() , then the function returns true . The result of this function is used to determine whether the process received the event (resource release) it was waiting for or not. TService::resume_all() . This function checks for the presence of processes \"recorded\" in the service's process map but currently in a not-ready state 6 ; if such processes exist, all of them are transitioned to the ready state and the scheduler is called. In this case, the function returns true ; otherwise, it returns false . TService::resume_next_ready() . This function performs actions similar to the resume_all() function described above, with the difference that if there are waiting processes, not all of them are transitioned to the ready state, but only one\u2014the highest-priority one. For the resume_all() and resume_next_ready() functions, there are versions optimized for use inside interrupt handlers\u2014these are resume_all_isr() and resume_next_ready_isr() . In purpose and meaning, they are similar to the main variants 7 ; the key difference is that they do not call the scheduler.","title":"Class Definition"},{"location":"src/ipcs/#usage","text":"","title":"Usage"},{"location":"src/ipcs/#preliminary-remarks","text":"Any service class is created from TService through inheritance. To illustrate the usage of TService and the creation of a service class based on it, we will examine one of the standard interprocess communication services\u2014 TEventFlag : class TEventFlag : public TService { ... } The service class TEventFlag itself will be described in detail later. For the continuity of the narrative at this point, it should be noted that this interprocess communication service is used to synchronize the work of processes in accordance with occurring events. The main idea of its usage is: one process waits for an event using the class member function TEventFlag::wait() , while another process 8 , upon the occurrence of an event that should be handled by the waiting process, signals the flag using the member function TEventFlag::signal() . Given the above, the main focus when examining the usage example will be on these two functions, as they carry the primary semantic load of the service class 9 , and its development essentially boils down to the development of such functions.","title":"Preliminary Remarks"},{"location":"src/ipcs/#requirements-for-the-functions-of-the-class-being-developed","text":"Requirements for the event flag waiting function. The function must check whether the event has occurred at the moment of the function call. If the event has not occurred, it must be able to wait 10 for the event either unconditionally or with a timeout condition. If the function returns due to the event, the return value should be true ; if it returns due to a timeout, the return value should be false . Requirements for the event flag signaling function. The function must transition all processes waiting for the event flag to the ready state and transfer control to the scheduler.","title":"Requirements for the Functions of the Class Being Developed"},{"location":"src/ipcs/#implementation","text":"Inside the member function wait() (see \"Listing 2. Function TEventFlag::wait()\"), the first step is to check if the event has already been signaled. If it has, the function returns true . If the event has not been signaled (i.e., it needs to be waited for), preparatory actions are performed\u2014in particular, the waiting timeout value is written to the Timeout variable of the current process, and the suspend() function, defined in the base class TService , is called. This function writes the tag of the current process into the process map of the event flag object (passed to suspend() as an argument), transitions this process to a not-ready state, and yields control to other processes by calling the scheduler. Upon returning from suspend() , which means this process has been transitioned back to the ready state, a check is performed to determine what caused the \"wake-up\" of this process. This is done by calling the is_timeouted() function. It returns false if the process was \"awakened\" via a call to TEventFlag::signal() \u2014i.e., the awaited event occurred (and no timeout happened). It returns true if the process \"wake-up\" occurred due to the expiration of the timeout specified in the TEventFlag::wait() argument, or if it was forced. This logic of the TEventFlag::wait() member function allows it to be effectively used in user code when organizing process work synchronized with the occurrence of required events 11 . Moreover, the implementation code of this function is simple and transparent. 01 bool OS :: TEventFlag :: wait ( timeout_t timeout ) 02 { 03 TCritSect cs ; 04 05 if ( Value ) // if flag already signaled 06 { 07 Value = efOff ; // clear flag 08 return true ; 09 } 10 else 11 { 12 cur_proc_timeout () = timeout ; 13 14 suspend ( ProcessMap ); 15 16 if ( is_timeouted ( ProcessMap )) 17 return false ; // waked up by timeout or by externals 18 19 cur_proc_timeout () = 0 ; 20 return true ; // otherwise waked up by signal() or signal_isr() 21 } 22 } Listing 2. Function TEventFlag::wait() 1 void OS :: TEventFlag :: signal () 2 { 3 TCritSect cs ; 4 if ( ! resume_all ( ProcessMap )) // if no one process was waiting for flag 5 Value = efOn ; 6 } Listing 3. Function TEventFlag::signal() The code for the TEventFlag::signal() function (see \"Listing 3. Function TEventFlag::signal()\") is extremely simple: inside it, all processes waiting for this event flag are transitioned to the ready state, and rescheduling is performed. If no such processes were found, the internal flag variable Value is set to efOn (true), which means the event occurred but hasn't been handled by anyone yet. Any interprocess communication service can be designed and defined in a similar manner. During its development, it is only necessary to have a clear understanding of what the member functions of the TService class do and to use them appropriately.","title":"Implementation"},{"location":"src/ipcs/#osteventflag","text":"During program execution, there is often a need for synchronization between processes. For example, one of the processes may need to wait for an event to perform its work. It can handle this in different ways: it can simply poll a global flag in a loop or do the same with some periodicity\u2014i.e., poll, \"go to sleep\" with a timeout, \"wake up,\" poll again, etc. The first method is bad because all processes with lower priority will not gain control, as due to their lower priorities, they cannot preempt the process polling the global flag in a loop. The second method is also bad\u2014the polling period becomes quite large (i.e., time resolution is low), and during polling, the process will occupy the CPU with context switches, even though it is unknown whether the event has occurred. A proper solution in this situation is to transition the process to a state of waiting for the event and transfer control to the process only when the event occurs. This functionality in scmRTOS is implemented using OS::TEventFlag objects (event flag). The class definition is shown in \"Listing 4. OS::TEventFlag\". 01 class TEventFlag : public TService 02 { 03 public : 04 enum TValue { efOn = 1 , efOff = 0 }; // prefix 'ef' means: \"Event Flag\" 05 06 public : 07 INLINE TEventFlag ( TValue init_val = efOff ); 08 09 bool wait ( timeout_t timeout = 0 ); 10 INLINE void signal (); 11 INLINE void clear () { TCritSect cs ; Value = efOff ; } 12 INLINE void signal_isr (); 13 INLINE bool is_signaled () { TCritSect cs ; return Value == efOn ; } 14 15 private : 16 volatile TProcessMap ProcessMap ; 17 volatile TValue Value ; 18 }; Listing 4. OS::TEventFlag","title":"OS::TEventFlag"},{"location":"src/ipcs/#interface","text":"","title":"Interface"},{"location":"src/ipcs/#wait","text":"","title":"wait"},{"location":"src/ipcs/#prototype","text":"bool OS::TEventFlag::wait ( timeout_t timeout );","title":"Prototype"},{"location":"src/ipcs/#description","text":"Waits for an event. When the wait() function is called, the following occurs: it checks if the flag is set. If it is set, the flag is cleared and the function returns true , meaning the event had already occurred at the time of the check. If the flag is not set (i.e., the event has not yet occurred), the process is transitioned to a state of waiting for this flag (event) and control is yielded to the kernel, which, after rescheduling processes, will run the next one. If the function is called without arguments (or with an argument equal to 0), the process will remain in the waiting state until the event flag is \"signaled\" by another process or an interrupt handler (using the signal() function) or is brought out of the inactive state using the TBaseProcess::force_wake_up() function (in the latter case, extreme caution is required). If wait() is called without an argument, it always returns true . If the function is called with an argument (an integer greater than 0) specifying the waiting timeout in system timer ticks, the process will wait for the event as in the case of a call without an argument. However, if the event flag is not \"signaled\" within the specified period, the process will be \"awakened\" by the timer and the function will return false . This implements both unconditional waiting and waiting with a timeout.","title":"Description"},{"location":"src/ipcs/#signal","text":"","title":"signal"},{"location":"src/ipcs/#prototype_1","text":"INLINE void OS :: TEventFlag :: signal ();","title":"Prototype"},{"location":"src/ipcs/#description_1","text":"A process that wishes to notify other processes via a TEventFlag object that a particular event has occurred must call the signal() function. As a result, all processes waiting for the specified event will be transitioned to the ready state, and the highest-priority among them will gain control (the others will follow in order of their priorities).","title":"Description"},{"location":"src/ipcs/#signal-from-isr","text":"","title":"signal from ISR"},{"location":"src/ipcs/#prototype_2","text":"INLINE void OS :: TEventFlag :: signal_isr ();","title":"Prototype"},{"location":"src/ipcs/#description_2","text":"A variant of the above function optimized for use in interrupts. The function is inline and uses a special lightweight inline version of the scheduler. This variant must not be used outside of interrupt handler code.","title":"Description"},{"location":"src/ipcs/#clear","text":"","title":"clear"},{"location":"src/ipcs/#prototype_3","text":"INLINE void OS :: TEventFlag :: clear ();","title":"Prototype"},{"location":"src/ipcs/#description_3","text":"Clears the flag. Sometimes, for synchronization, it is necessary to wait for the next event, not to handle an already occurred one. In this case, the event flag must be cleared before proceeding to wait. The clear() function is used for this purpose.","title":"Description"},{"location":"src/ipcs/#check-if-signaled","text":"","title":"check if signaled"},{"location":"src/ipcs/#prototype_4","text":"INLINE bool OS :: TEventFlag :: is_signaled ();","title":"Prototype"},{"location":"src/ipcs/#description_4","text":"Checks the state of the flag. It is not always necessary to wait for an event by yielding control. Sometimes, based on the program's logic, it is only necessary to check whether the event has occurred.","title":"Description"},{"location":"src/ipcs/#usage-example","text":"An example of using an event flag is shown in \"Listing 5. Using TEventFlag\". In this example, process Proc1 waits for an event with a timeout of 10 system timer ticks (9). The second process, Proc2 , \"signals\" the flag when a condition is met (27). If the first process has higher priority, it will gain control immediately. 01 OS :: TEventFlag eflag ; 02 ... 03 //---------------------------------------------------------------- 04 template <> void Proc1 :: exec () 05 { 06 for (;;) 07 { 08 ... 09 if ( eflag . wait ( 10 ) ) // wait event for 10 ticks 10 { 11 ... // do something 12 } 13 else 14 { 15 ... // do something else 16 } 17 ... 18 } 19 } 20 ... 21 //---------------------------------------------------------------- 22 template <> void Proc2 :: exec () 23 { 24 for (;;) 25 { 26 ... 27 if ( ... ) eflag . signal (); 28 ... 29 } 30 } 31 //---------------------------------------------------------------- Listing 5. Using TEventFlag NOTE When an event occurs and a process \"signals\" the flag, all processes that were waiting for this flag will be transitioned to the ready state. In other words, everyone who was waiting has now received the event. They will, of course, gain control in the order of their priorities, but the event will not be missed by any process that managed to start waiting, regardless of its priority. Thus, an event flag exhibits broadcast behavior , which is very useful for organizing notifications and synchronizing multiple processes based on a single event. Of course, nothing prevents using an event flag in a \"point-to-point\" scheme where there is only one process waiting for the event.","title":"Usage Example"},{"location":"src/ipcs/#ostmutex","text":"The Mutex semaphore (from Mutual Exclusion), as the name suggests, is designed to organize mutual exclusion of access. That is, at any given moment, no more than one process can hold this semaphore. If any process attempts to lock a Mutex that is already held by another process, the attempting process will wait until the semaphore is released. The primary use of Mutex semaphores is to organize mutual exclusion when accessing a particular resource. For example, a static array with global visibility 12 is used by two processes to exchange data. To avoid errors during the exchange, it is necessary to prevent one process from having access to the array during the period when another process is working with it. Using a critical section for this is not the best approach, as interrupts would be disabled for the entire time the process accesses the array. This time might be significant, and during it, the system would be unable to respond to events. In this situation, a mutual exclusion semaphore is perfectly suitable: a process planning to work with a shared resource must first lock the Mutex semaphore. After that, it can safely work with the resource. Upon completion of the work, the semaphore must be released so that other processes can access it. It goes without saying that all processes working with the shared resource should behave this way, i.e., access it through the semaphore 13 . These same considerations fully apply to calling a non-reentrant 14 function. WARNING When using mutual exclusion semaphores, a situation may arise where one process, having locked a semaphore and working with the corresponding resource, attempts to access another resource, which is also accessed by locking another semaphore. This second semaphore is already locked by another process, which, in turn, is trying to access the resource already being used by the first process. As a result, both processes are waiting for each other to release the locked resource, and until that happens, neither can continue its work. This situation is called a \"deadlock\" 15 . In English-language literature, it is denoted by the word \"Deadlock.\" To avoid it, the programmer must carefully monitor access to shared resources. A good rule to prevent the situation described above is to lock no more than one mutual exclusion semaphore at a time. In any case, success here is based on the attentiveness and discipline of the program developer. For implementing binary semaphores of this type, scmRTOS defines the OS::TMutex class. See \"Listing 6. OS::TMutex\". 01 class TMutex : public TService 02 { 03 public : 04 INLINE TMutex () : ProcessMap ( 0 ), ValueTag ( 0 ) { } 05 void lock (); 06 void unlock (); 07 void unlock_isr (); 08 09 INLINE bool try_lock () { TCritSect cs ; if ( ValueTag ) return false ; 10 else lock (); return true ; } 11 INLINE bool is_locked () const { TCritSect cs ; return ValueTag != 0 ; } 12 13 private : 14 volatile TProcessMap ProcessMap ; 15 volatile TProcessMap ValueTag ; 16 17 }; Listing 6. OS::TMutex Obviously, before use, the semaphore must be created. Due to the specifics of its application, the semaphore should have the same storage class and scope as the resource it serves, i.e., it should be a static object with global visibility 16 .","title":"OS::TMutex"},{"location":"src/ipcs/#interface_1","text":"","title":"Interface"},{"location":"src/ipcs/#lock","text":"","title":"lock"},{"location":"src/ipcs/#prototype_5","text":"void TMutex::lock ();","title":"Prototype"},{"location":"src/ipcs/#description_5","text":"Performs a blocking lock: if the semaphore was not previously locked by another process, its internal state is set to \"locked,\" and the execution flow returns to the calling function. If the semaphore was already locked, the process will transition to a waiting state until the semaphore is released, and control is yielded to the kernel.","title":"Description"},{"location":"src/ipcs/#unlock","text":"","title":"unlock"},{"location":"src/ipcs/#prototype_6","text":"void TMutex::unlock ();","title":"Prototype"},{"location":"src/ipcs/#description_6","text":"The function sets the internal state to \"unlocked\" and checks if any other process is waiting for this semaphore. If there is, control is yielded to the kernel, which will reschedule processes so that if the waiting process had higher priority, it will immediately gain control. If several processes were waiting for the semaphore, the highest-priority one among them will gain control. Only the process that locked the semaphore can unlock it\u2014i.e., if this function is executed in a process that did not lock the mutex object, it will have no effect, and the object will remain in the same state.","title":"Description"},{"location":"src/ipcs/#unlock-from-isr","text":"","title":"unlock from ISR"},{"location":"src/ipcs/#prototype_7","text":"INLINE void TMutex :: unlock_isr ();","title":"Prototype"},{"location":"src/ipcs/#description_7","text":"Sometimes a situation arises where a mutex is locked within a process, but work with the corresponding protected resource is performed in an interrupt handler (and this work is initiated in the process simultaneously with locking the mutex). In this case, it is convenient to perform the unlock directly in the interrupt handler upon completion of work with the resource. For this purpose, TMutex includes the unlock_isr() function for unlocking the semaphore directly within an interrupt.","title":"Description"},{"location":"src/ipcs/#try-to-lock","text":"","title":"try to lock"},{"location":"src/ipcs/#prototype_8","text":"INLINE bool TMutex :: try_lock ();","title":"Prototype"},{"location":"src/ipcs/#description_8","text":"Non-blocking lock. The difference from lock() is that the lock will only occur if the semaphore is free. For example, a process needs to work with a resource but also has a lot of other work. Attempting to lock with lock() might cause it to wait until the semaphore is freed, whereas that time could be spent on other work if available, and work with the shared resource could be performed only when access to it is not blocked. This approach can be relevant for a high-priority process: if the semaphore is locked by a low-priority process, it is reasonable for the high-priority process not to yield control to the low-priority one if it has other work. Only when there is nothing left to do does it make sense to attempt to lock the semaphore in the usual way\u2014by yielding control (since the low-priority process must also eventually gain control to finish its tasks and release the semaphore). Considering the above, this function should be used with caution, as it could lead to a situation where a low-priority process never gains control because the high-priority one does not yield it.","title":"Description"},{"location":"src/ipcs/#try-to-lock-with-timeout","text":"","title":"try to lock with timeout"},{"location":"src/ipcs/#prototype_9","text":"OS :: TMutex :: try_lock ( timeout_t timeout );","title":"Prototype"},{"location":"src/ipcs/#description_9","text":"A blocking version of the previous function with a specified time interval\u2014attempts to lock the semaphore within the specified timeout. If the lock is successful, returns true ; otherwise, returns false .","title":"Description"},{"location":"src/ipcs/#check-if-locked","text":"","title":"check if locked"},{"location":"src/ipcs/#prototype_10","text":"INLINE bool TMutex :: is_locked ()","title":"Prototype"},{"location":"src/ipcs/#description_10","text":"The function checks the state and returns true if the semaphore is locked, and false otherwise. It is sometimes convenient to use a semaphore as a status flag, where one process sets this flag (by locking the semaphore), and other processes check it and perform actions according to the state of that process.","title":"Description"},{"location":"src/ipcs/#usage-example_1","text":"See \"Listing 7. Example of Using OS::TMutex\" for a usage example. 01 OS :: TMutex Mutex ; 02 byte buf [ 16 ]; 03 ... 04 template <> void TSlon :: exec () 05 { 06 for (;;) 07 { 08 ... // some code 09 // 10 Mutex . lock (); // resource access lock 11 for ( byte i = 0 ; i < 16 ; i ++ ) // 12 { // 13 ... // do something with buf 14 } // 15 Mutex . unlock (); // resource access unlock 16 // 17 ... // some code 18 } 19 } Listing 7. Example of Using OS::TMutex For convenience when using a mutual exclusion semaphore, the already mentioned wrapper class technique can be applied. In this case, it is implemented using the TMutexLocker class, included in the OS distribution. See \"Listing 8. Wrapper Class OS::TMutexLocker\". 01 template < typename Mutex > 02 class TScopedLock 03 { 04 public : 05 TScopedLock ( Mutex & m ) : mx ( m ) { mx . lock (); } 06 ~ TScopedLock () { mx . unlock (); } 07 private : 08 Mutex & mx ; 09 }; 10 11 typedef TScopedLock < OS :: TMutex > TMutexLocker ; Listing 8. Wrapper Class OS::TMutexLocker The methodology for using objects of this class is no different from using other wrapper classes\u2014 TCritSect , TISRW . ABOUT PRIORITY INVERSION A few words should be said about a mechanism related to mutual exclusion semaphores: priority inversion. The idea of priority inversion arises from the following situation. For example, a system has several processes, and processes with priorities N 17 and N+n, where n>1, use the same resource, sharing work via a mutual exclusion semaphore. At some point, the process with priority N+n locks the semaphore and is working with the shared resource. During this, an event occurs that activates the process with priority N, which attempts to access the shared resource and, in trying to lock the semaphore, transitions to a waiting state. It will remain in this state until the process with priority N+n unlocks the semaphore. The delay of the higher-priority process in this situation is forced, as it is impossible to take control away from the process with priority N+n without violating the logic of its work and the integrity of access to the shared resource. Knowing this, the developer typically tries to minimize the time spent working with the resource so that the low-priority process does not block the work of the high-priority one. However, there is an unpleasant aspect to this situation: if at the moment described above a process with priority, for example, N+1, becomes active, it will preempt the process with priority N+n (since n>1) and thereby introduce an additional delay for the waiting higher-priority process with priority N. The situation is aggravated by the fact that the program developer usually does not connect the work of the process with priority N+1 with the manipulations of processes with priorities N and N+n on the shared resource. Therefore, they might not consider optimizing the work of the process with priority N+1 in relation to this, which could completely block the work of the process with priority N for an unpredictable amount of time. This is a highly undesirable situation. To avoid this, a technique called \"priority inversion\" is used. Its essence is that if a high-priority process attempts to lock a mutual exclusion semaphore that is already locked by a low-priority process, a temporary exchange of priorities occurs until the semaphore is unlocked. In effect, the low-priority process runs with the priority of the process that attempted to lock the semaphore. In this case, the situation described above, where a low-priority process blocks the work of a high-priority one, becomes impossible. Despite the coherence and elegance of the priority inversion method, it is not without drawbacks. The main one is that its technical implementation incurs overhead comparable to or exceeding the cost of implementing the mutual exclusion semaphore functionality itself. It might turn out that switching process priorities and everything associated with it\u2014requiring consideration of all OS elements related to the priorities of processes involved in the inversion\u2014slows down the system to an unacceptable level. In connection with this, the priority inversion mechanism is not used in the current version of scmRTOS . Instead, to solve the aforementioned problem of a high-priority process being blocked by a low-priority one, a task delegation mechanism is proposed, discussed in detail in \"Appendix A Usage Examples, A.1 Task Queue.\" This represents a unified method for redistributing the execution of contextually related code among processes with different priorities.","title":"Usage Example"},{"location":"src/ipcs/#osmessage","text":"OS::message is a C++ template for creating objects that implement inter-process communication by transmitting structured data. OS::message is similar to OS::TEventFlag and differs mainly in that, besides the flag itself, it also contains an object of an arbitrary type constituting the actual message body. The template definition is shown in \"Listing 9 OS::message\". As can be seen from the listing, the message template is built upon the TBaseMessage class. This is done for efficiency reasons, to avoid duplicating common code in template instances\u2014the code common to all messages is moved to the level of the base class 18 . 01 class TBaseMessage : public TService 02 { 03 public : 04 INLINE TBaseMessage () : ProcessMap ( 0 ), NonEmpty ( false ) { } 05 06 bool wait ( timeout_t timeout = 0 ); 07 INLINE void send (); 08 INLINE void send_isr (); 09 INLINE bool is_non_empty () const { TCritSect cs ; return NonEmpty ; } 10 INLINE void reset () { TCritSect cs ; NonEmpty = false ; } 11 12 private : 13 volatile TProcessMap ProcessMap ; 14 volatile bool NonEmpty ; 15 }; 16 17 template < typename T > 18 class message : public TBaseMessage 19 { 20 public : 21 INLINE message () : TBaseMessage () { } 22 INLINE const T & operator = ( const T & msg ) 23 { 24 TCritSect cs ; 25 * ( const_cast < T *> ( & Msg )) = msg ; return const_cast < const T &> ( Msg ); 26 } 27 INLINE operator T () const 28 { 29 TCritSect cs ; 30 return const_cast < const T &> ( Msg ); 31 } 32 INLINE void out ( T & msg ) { TCritSect cs ; msg = const_cast < T &> ( Msg ); } 33 34 private : 35 volatile T Msg ; 36 }; Listing 9. OS::message","title":"OS::message"},{"location":"src/ipcs/#interface_2","text":"","title":"Interface"},{"location":"src/ipcs/#send","text":"","title":"send"},{"location":"src/ipcs/#prototype_11","text":"INLINE void OS :: TBaseMessage :: send ();","title":"Prototype"},{"location":"src/ipcs/#description_11","text":"Sends a message 19 . The operation involves transitioning processes waiting for the message to the ready state and calling the scheduler.","title":"Description"},{"location":"src/ipcs/#send-from-isr","text":"","title":"send from ISR"},{"location":"src/ipcs/#prototype_12","text":"INLINE void OS :: TBaseMessage :: send_isr ();","title":"Prototype"},{"location":"src/ipcs/#description_12","text":"A variant of the above function optimized for use in interrupts. The function is inline and uses a special lightweight inline version of the scheduler. This variant must not be used outside of interrupt handler code .","title":"Description"},{"location":"src/ipcs/#wait_1","text":"","title":"wait"},{"location":"src/ipcs/#prototype_13","text":"bool OS::TBaseMessage::wait ( timeout_t timeout );","title":"Prototype"},{"location":"src/ipcs/#description_13","text":"Waits for a message 20 . The function checks if the message is non-empty. If it is non-empty, it returns true . If it is empty, it transitions the current process from the ready state to a state of waiting for this message. If no argument is specified during the call or if the argument is 0, waiting will continue until some process sends a message or the current process is \"awakened\" using the TBaseProcess::force_wake_up() function 21 . If an integer is specified as an argument, representing the timeout value expressed in system timer ticks, then waiting for the message will occur with a timeout, i.e., the process will be \"awakened\" in any case. If this happens before the timeout expires, meaning a message arrives before the timeout, the function returns true . Otherwise, i.e., if the timeout expires before the message is sent, the function returns false .","title":"Description"},{"location":"src/ipcs/#check-if-non-empty","text":"","title":"check if non-empty"},{"location":"src/ipcs/#prototype_14","text":"INLINE bool OS :: TBaseMessage :: is_non_empty ();","title":"Prototype"},{"location":"src/ipcs/#description_14","text":"The function returns true if a message has been sent, and false otherwise.","title":"Description"},{"location":"src/ipcs/#reset","text":"","title":"reset"},{"location":"src/ipcs/#prototype_15","text":"INLINE OS::TBaseMessage::reset ();","title":"Prototype"},{"location":"src/ipcs/#description_15","text":"The function resets the message, i.e., transitions it to the empty state. The message body remains unchanged.","title":"Description"},{"location":"src/ipcs/#write-message-contents","text":"","title":"write message contents"},{"location":"src/ipcs/#prototype_16","text":"template < typename T > INLINE const T & OS :: message < T >:: operator = ( const T & msg );","title":"Prototype"},{"location":"src/ipcs/#description_16","text":"Writes the actual message contents into the message object. The standard way to use OS::message is to write the message body and send the message using the TBaseMessage::send() function\u2014see \"Listing 10. Using OS::message\".","title":"Description"},{"location":"src/ipcs/#access-message-body-by-reference","text":"","title":"access message body by reference"},{"location":"src/ipcs/#prototype_17","text":"template < typename T > INLINE OS :: message < T >:: operator T () const ;","title":"Prototype"},{"location":"src/ipcs/#description_17","text":"Returns a constant reference to the message body. This facility should be used with caution, bearing in mind that while accessing the message body via a reference, it might be modified in another process (or interrupt handler). Therefore, it is recommended to use the message::out() function for reading the message body.","title":"Description"},{"location":"src/ipcs/#read-message-contents","text":"","title":"read message contents"},{"location":"src/ipcs/#prototype_18","text":"template < typename T > INLINE OS :: message < T >:: out ( T & msg );","title":"Prototype"},{"location":"src/ipcs/#description_18","text":"The function is intended for reading the message body. For efficiency, to avoid unnecessary copying of the message body, a reference to an external message body object is passed to the function. Inside the function, the message contents are copied into this external object.","title":"Description"},{"location":"src/ipcs/#usage-example_2","text":"01 struct TMamont { ... } // data type for sending by message 02 03 OS :: message < Mamont > mamont_msg ; // OS::message object 04 05 template <> void Proc1 :: exec () 06 { 07 for (;;) 08 { 09 Mamont mamont ; 10 mamont_msg . wait (); // wait for message 11 mamont_msg . out ( mamont ); // read message contents to the external object 12 ... // using the Mamont contents 13 } 14 } 15 16 template <> void Proc2 :: exec () 17 { 18 for (;;) 19 { 20 ... 21 Mamont m ; // create message content 22 23 m ... = // message body filling 24 mamont_msg = m ; // put the content to the OS::message object 25 mamont_msg . send (); // send the message 26 ... 27 } 28 } Listing 10. Using OS::message","title":"Usage Example"},{"location":"src/ipcs/#oschannel","text":"OS::channel is a C++ template for creating objects that implement ring buffers 22 for the safe transmission of data of arbitrary types within a preemptive OS. Like any other interprocess communication service, OS::channel solves synchronization problems. The specific buffer type is specified during the template instantiation 23 in the user code. The OS::channel template is based on the ring buffer template defined in the library included in the scmRTOS distribution: usr :: ring_buffer < class T , uint16_t size , class S = uint8_t > ` Building channels using C++ templates provides an efficient means for constructing message queues of arbitrary types. Unlike the dangerous, non-transparent, and inflexible method of organizing message queues based on void * pointers, the OS::channel queue offers: Safety through static type checking , both when creating the queue/channel and when writing data to it or reading from it. Ease of use \u2014no need for manual type casting, which requires keeping extra information in mind about the real data types transmitted through the channel for their correct use. Significantly greater flexibility \u2014queue objects can be of any type, not just pointers. Regarding the last point, a few words should be said: one drawback of using void * pointers as a basis for message passing is that the user must allocate memory for the messages themselves somewhere. This is extra work, and the target object becomes distributed\u2014the queue is in one place, while the actual content of the queue elements is elsewhere. The main advantages of the pointer-based message mechanism are high efficiency for large message bodies and the ability to transmit messages of varying formats. However, if, for example, messages are small\u2014a few bytes\u2014and all have the same format, there is no need for pointers. It's much simpler to create a queue of the required number of such messages, and that's it. In this case, as mentioned, there's no need to allocate memory for the message bodies\u2014since messages are placed entirely into the channel queue, memory for them will be automatically allocated by the compiler directly when creating the channel. The channel template definition is shown in \"Listing 11. Definition of the OS::channel Template\". 01 template < typename T , uint16_t Size , typename S = uint8_t > 02 class channel : public TService 03 { 04 public : 05 INLINE channel () : ProducersProcessMap ( 0 ) 06 , ConsumersProcessMap ( 0 ) 07 , pool () 08 { 09 } 10 11 //---------------------------------------------------------------- 12 // 13 // Data transfer functions 14 // 15 void write ( const T * data , const S cnt ); 16 bool read ( T * const data , const S cnt , timeout_t timeout = 0 ); 17 18 void push ( const T & item ); 19 void push_front ( const T & item ); 20 21 bool pop ( T & item , timeout_t timeout = 0 ); 22 bool pop_back ( T & item , timeout_t timeout = 0 ); 23 24 //---------------------------------------------------------------- 25 // 26 // Service functions 27 // 28 INLINE S get_count () const ; 29 INLINE S get_free_size () const ; 30 void flush (); 31 32 private : 33 volatile TProcessMap ProducersProcessMap ; 34 volatile TProcessMap ConsumersProcessMap ; 35 usr :: ring_buffer < T , Size , S > pool ; 36 }; Listing 11. Definition of the OS::channel Template OS::channel is used as follows: first, define the type of objects to be transmitted through the channel, then define the channel type or create a channel object. For example, suppose the data transmitted through the channel is a structure: struct Data { int a ; char * p ; }; Now, you can create a channel object by instantiating the OS::channel template: OS :: channel < Data , 8 > data_queue ; This code declares a channel object data_queue for transmitting objects of type Data , with a channel capacity of 8 objects. The channel is now ready for use. OS::channel provides the ability to write data not only to the end of the queue but also to the beginning, and to read data not only from the beginning but also from the end of the queue. When reading, it is also possible to specify a timeout value. The following interface is provided for operating on a channel object:","title":"OS::channel"},{"location":"src/ipcs/#interface_3","text":"","title":"Interface"},{"location":"src/ipcs/#push","text":"","title":"push"},{"location":"src/ipcs/#prototype_19","text":"template < typename T , uint16_t Size , typename S > void OS :: channel < T , Size , S >:: push ( const T & item );","title":"Prototype"},{"location":"src/ipcs/#description_19","text":"Pushes one element to the end of the queue 24 . If there was space in the channel at the time of writing, the element is written to the queue and the scheduler is called. If there was no space, the process transitions to a waiting state until space becomes available in the channel. When space appears, the element will be written, followed by a call to the scheduler.","title":"Description"},{"location":"src/ipcs/#push-front","text":"","title":"push front"},{"location":"src/ipcs/#prototype_20","text":"template < typename T , uint16_t Size , typename S > void OS :: channel < T , Size , S >:: push_front ( const T & item );","title":"Prototype"},{"location":"src/ipcs/#description_20","text":"Pushes an element to the beginning of the queue. In all other respects, the logic of operation is exactly the same as for channel::push() .","title":"Description"},{"location":"src/ipcs/#pop","text":"","title":"pop"},{"location":"src/ipcs/#prototype_21","text":"template < typename T , uint16_t Size , typename S > bool OS :: channel < T , Size , S >:: pop ( T & item , timeout_t timeout );","title":"Prototype"},{"location":"src/ipcs/#description_21","text":"Pops one element from the beginning of the queue if the channel was not empty. If the channel was empty, the process transitions to a waiting state until data appears in it or until the timeout expires, if a timeout was specified 25 . In case of a call with a timeout: if data arrives before the timeout expires, the function returns true ; otherwise, it returns false . If the call was made without a timeout, the function always returns true , except when awakened by OS::TBaseProcess::wake_up() or OS::TBaseProcess::force_wake_up() . In all cases, when an element is popped, the scheduler is called. Note that when calling this function, the data popped from the channel is not returned by copying from the function but is passed via a reference to an object. This is because the return value is used to convey the timeout result.","title":"Description"},{"location":"src/ipcs/#pop-back","text":"","title":"pop back"},{"location":"src/ipcs/#prototype_22","text":"template < typename T , uint16_t Size , typename S > bool OS :: channel < T , Size , S >:: pop_back ( T & item , timeout_t timeout );","title":"Prototype"},{"location":"src/ipcs/#description_22","text":"Pops one element from the end of the queue if the channel was not empty. All functionality is exactly the same as for channel::pop() .","title":"Description"},{"location":"src/ipcs/#write","text":"","title":"write"},{"location":"src/ipcs/#prototype_23","text":"template < typename T , uint16_t Size , typename S > void OS :: channel < T , Size , S >:: write ( const T * data , const S count );","title":"Prototype"},{"location":"src/ipcs/#description_23","text":"Writes several elements from memory at the given address to the end of the queue. Essentially, this is the same as pushing one element to the end of the queue ( push ), except that not one but the specified number of elements are written. In case of waiting, it continues until enough space becomes available in the channel.","title":"Description"},{"location":"src/ipcs/#write-inside-isr","text":"","title":"write inside ISR"},{"location":"src/ipcs/#prototype_24","text":"template < typename T , uint16_t Size , typename S > S OS :: channel < T , Size , S >:: write_isr ( const T * data , const S count );","title":"Prototype"},{"location":"src/ipcs/#description_24","text":"A special version for use inside interrupt handlers. The function writes as many elements as the free space in the channel allows (but no more than the specified count) and returns the number of elements written. Processes waiting for data from the channel are transitioned to the ready state. The call is non-blocking . The scheduler is not called.","title":"Description"},{"location":"src/ipcs/#read","text":"","title":"read"},{"location":"src/ipcs/#prototype_25","text":"template < typename T , uint16_t Size , typename S > bool OS :: channel < T , Size , S >:: read ( T * const data , const S count , timeout_t timeout );","title":"Prototype"},{"location":"src/ipcs/#description_25","text":"Pops several elements from the channel. This is the same as channel::pop() , except that not one but the specified number of elements are popped. If waiting occurs, it continues until the required number of elements is available in the channel or until the timeout triggers (if used).","title":"Description"},{"location":"src/ipcs/#read-inside-isr","text":"","title":"read inside ISR"},{"location":"src/ipcs/#prototype_26","text":"template < typename T , uint16_t Size , typename S > S OS :: channel < T , Size , S >:: read_isr ( T * const data , const S max_size );","title":"Prototype"},{"location":"src/ipcs/#description_26","text":"A special version for use inside interrupt handlers. The function reads as many elements as are present in the channel (but no more than the specified count) and returns the number of elements written. Processes waiting for free space to appear in the channel are transitioned to the ready state. The call is non-blocking . The scheduler is not called.","title":"Description"},{"location":"src/ipcs/#get-item-count","text":"","title":"get item count"},{"location":"src/ipcs/#prototype_27","text":"template < typename T , uint16_t Size , typename S > S OS :: channel < T , Size , S >:: get_count ();","title":"Prototype"},{"location":"src/ipcs/#description_27","text":"Returns the number of elements currently in the channel. The function is inline , so its efficiency is maximized.","title":"Description"},{"location":"src/ipcs/#get-free-size","text":"","title":"get free size"},{"location":"src/ipcs/#prototype_28","text":"template < typename T , uint16_t Size , typename S > S OS :: channel < T , Size , S >:: get_free_size ();","title":"Prototype"},{"location":"src/ipcs/#description_28","text":"Returns the amount of free space available in the channel.","title":"Description"},{"location":"src/ipcs/#flush","text":"","title":"flush"},{"location":"src/ipcs/#prototype_29","text":"template < typename T , uint16_t Size , typename S > S OS :: channel < T , Size , S >:: flush ();","title":"Prototype"},{"location":"src/ipcs/#description_29","text":"Clears the channel. The function clears the buffer by calling usr::ring_buffer<>::flush() and calls the scheduler.","title":"Description"},{"location":"src/ipcs/#usage-example_3","text":"A simple usage example is shown in \"Listing 12. Example of Using a Queue Based on a Channel\". 01 //--------------------------------------------------------------------- 02 struct Cmd 03 { 04 enum CmdName { cmdSetCoeff1 , cmdSetCoeff2 , cmdCheck } CmdName ; 05 int Value ; 06 }; 07 08 OS :: channel < Cmd , 10 > cmd_q ; // Queue for Commands with 10 items depth 09 //--------------------------------------------------------------------- 10 template <> void Proc1 :: exec () 11 { 12 ... 13 Cmd cmd = { cmdSetCoeff2 , 12 }; 14 cmd_q . push ( cmd ); 15 ... 16 } 17 //--------------------------------------------------------------------- 18 template <> void Proc2 :: exec () 19 { 20 ... 21 Cmd cmd ; 22 if ( cmd_q . pop ( cmd , 10 ) ) // wait for data, timeout 10 system ticks 23 { 24 ... // data incoming, do something 25 } 26 else 27 { 28 ... // timeout expires, do something else 29 } 30 ... 31 } 32 //--------------------------------------------------------------------- Listing 12. Example of Using a Queue Based on a Channel. As can be seen, usage is quite simple and transparent. In one process (Proc1), a command message cmd is created (13), initialized with the required values, and written to the channel queue (14). In another process (Proc2), there is a wait for data from the queue (22). If data arrives, the corresponding code is executed (23)-(25); if the timeout expires, different code is executed (27)-(29).","title":"Usage Example"},{"location":"src/ipcs/#final-remarks","text":"There is a certain invariant relationship among different interprocess communication services. That is, using some services (or, more often, a combination thereof), you can accomplish the same task as with others. For example, instead of using a channel, you could create a static array and exchange data through it using mutual exclusion semaphores to prevent concurrent access and event flags to notify the waiting process that data is ready for it. In some cases, such an implementation might be more efficient, albeit less convenient. You could use messages for event synchronization instead of event flags\u2014this approach makes sense if you also need to transmit some information along with the flag. In fact, that's precisely what OS::message is designed for. The variety of uses is great, and which option is best suited for a particular situation is determined primarily by the situation itself. TIP It is necessary to understand and remember that any interprocess communication service, while performing its functions, does so within a critical section, i.e., with interrupts disabled. Therefore, you should not overuse interprocess communication services where they can be avoided. For example, using a mutual exclusion semaphore when accessing a static variable of a built-in type is not a good idea compared to simply using a critical section, because the semaphore also uses critical sections when locking and unlocking, and the time spent in them is longer than during simple variable access. There are certain peculiarities when using services within interrupts. For example, it is obvious that using TMutex::lock() inside an interrupt handler is a rather bad idea because, firstly, mutual exclusion semaphores are intended for resource sharing at the process level, not the interrupt level. Secondly, waiting for a resource to be released inside an interrupt handler will not work anyway and will only lead to the process interrupted by this interrupt being transitioned to a waiting state at an inappropriate and unpredictable point. Effectively, the process will be placed in an inactive state, from which it can only be recovered using the TBaseProcess::force_wake_up() function. In any case, nothing good will come of this. A somewhat similar situation can arise when using channel objects in an interrupt handler. You cannot wait for data from a channel inside an ISR, and the consequences will be similar to those described above. Writing data to a channel is also not entirely safe. If, for instance, there is insufficient space in the channel when writing, the program's behavior will be far from what the user expects. RECOMMENDATION For work inside interrupts, you should use the service member functions with the _isr suffix\u2014these are specially developed versions that ensure efficiency and safe use of interprocess communication services within interrupts. And, of course, if the existing set of interprocess communication services does not meet the needs of a particular project for some reason, it is always possible to design a custom service class based on the provided foundation in the form of TService . In doing so, the standard set of services can serve as design examples. Since interprocess communication services perform similar actions when interacting with kernel resources, they contain, in places, nearly identical code. \u21a9 Or can be developed by the user for their project's needs. \u21a9 A process tag is technically a mask of type TProcessMap with only one non-zero bit. The position of this bit in the mask corresponds to the process priority. Process tags are used for manipulating TProcessMap objects, which define the ready/not-ready state of processes, and also serve to record process tags. \u21a9 Along with the process priority number, the tag can also serve as a process identifier\u2014there is a one-to-one correspondence between the priority number and the process tag. Each type of identifier has advantages in terms of efficiency in specific situations, so both types are used extensively in the OS code. \u21a9 In other words, \"awakened\" in the system timer interrupt handler. \u21a9 That is, processes whose waiting state has not been interrupted by a timeout and/or forcibly using TBaseProcess::wake_up() and TBaseProcess::force_wake_up() . \u21a9 Therefore, a full description of them is not provided. \u21a9 Or an interrupt handler\u2014depending on the source of the events. For interrupt handlers, there is a special version of the function that signals the flag, but in the context of the current description, this nuance is omitted as non-essential. \u21a9 The rest of its representation is auxiliary in nature and serves to give completeness to the class and improve its user characteristics. \u21a9 I.e., yield control to the system kernel and remain in passive waiting. \u21a9 Including when such events do not occur within the specified time interval. \u21a9 So that various parts of the program have access to it. \u21a9 General rule: all processes working with a shared resource must behave this way, i.e., perform access through the semaphore. \u21a9 A function that uses objects with non-local storage class during its operation. Therefore, to prevent disruption of the program's integrity, such a function must not be called if an instance of the same function is already running. \u21a9 Sometimes translated as \"deadly embrace.\" \u21a9 Although nothing prevents placing a Mutex outside the process code's scope and using a pointer or reference, either directly or through wrapper classes that automate the resource unlocking process via the automatic call of the wrapper class's destructor. \u21a9 It is assumed that process execution priority is inversely related to priority numbers\u2014i.e., the process with priority 0 is the highest priority, and as priority numbers increase, process priority decreases. \u21a9 The same technique is used when building the process template: the pair class TBaseProcess \u2013 template process<> . \u21a9 Analogous to the OS::TEventFlag::signal() function. \u21a9 Analogous to the OS::TEventFlag::wait() function. \u21a9 In the latter case, extreme caution is required. \u21a9 Functionally, it's a FIFO, i.e., a queue object for data transmission following the First In, First Out scheme. \u21a9 Creation of a class instance. \u21a9 Refers to the channel's queue. Functionally, since a channel is a FIFO, the end of the queue corresponds to the FIFO input, and the beginning of the channel corresponds to the FIFO output. \u21a9 I.e., the call included a second argument\u2014an integer specifying the timeout value in system timer ticks. \u21a9","title":"Final Remarks"},{"location":"src/kernel/","text":"OS Kernel \ud83d\udd17 General Information \ud83d\udd17 The operating system kernel performs the following functions: Process organization and management. Scheduling at both the process and interrupt levels. Support for inter-process communication. System time support (system timer). Support for extensions. The core of the system is the TKernel class, which contains all the necessary set of functions and data. For obvious reasons, only a single instance of this class exists. Almost all of its internal representation is private. To allow access from certain parts of the OS that require its resources, the C++ \"friend\" mechanism is used \u2014 functions and classes granted such access are declared with the friend keyword. It is important to note that in this context, the term \"kernel\" refers not only to the TKernel object but also to the functional extension facility implemented as the TKernelAgent class. This class was specifically introduced into the operating system to provide a base for building extensions. Looking ahead, it can be noted that in scmRTOS , all inter-process communication facilities are implemented based on such an extension. The TKernelAgent class is declared as a friend of the TKernel class and contains a minimal necessary set of protected functions to provide its descendants with access to kernel resources. Extensions are built by inheriting from the TKernelAgent class. For more details, see TKernelAgent and Extensions . TKernel. Composition and Operation \ud83d\udd17 Composition \ud83d\udd17 The TKernel class contains the following data members 1 : CurProcPriority \u2013 A variable containing the priority number of the currently active process. Serves for quick access to the current process's resources and for manipulating the process's status (both in relation to the kernel and to IPC facilities) 2 . ReadyProcessMap \u2013 A map of processes ready for execution. Contains tags of processes ready to run: each bit of this variable corresponds to a specific process. A logical 1 indicates that the process is ready for execution 3 , a logical 0 indicates that it is not ready. ProcessTable \u2013 An array of pointers to processes registered in the system. ISR_NestCount \u2013 A counter for interrupt entries. It is incremented on each entry and decremented on each exit. SysTickCount \u2013 A counter for system timer ticks (overflows). Present only if this feature is enabled (via the corresponding macro in the configuration file). SchedProcPriority * \u2013 A variable for storing the priority value of the process scheduled to receive control. Process Setup \ud83d\udd17 The process setup essentially involves registering created processes. In the constructor of each process, the kernel function register_process(TBaseProcess *) is called. This function places the pointer to the process (passed as an argument) into the system's ProcessTable (see below). The position of this pointer in the table is determined according to the process's priority, which effectively serves as an index for accessing the table. See \"Listing 1. Process Registration Function\" for the code. 1 void OS :: TKernel :: register_process ( OS :: TBaseProcess * const p ) 2 { 3 ProcessTable [ p -> Priority ] = p ; 4 } Listing 1. Process Registration Function The next system function is the actual OS startup. See \"Listing 2. OS Startup Function\" for the code. 1 INLINE void OS :: run () 2 { 3 stack_item_t * sp = Kernel . ProcessTable [ pr0 ] -> StackPointer ; 4 os_start ( sp ); 5 } Listing 2. OS Startup Function The actions are quite simple: the stack pointer of the highest-priority process is retrieved from the process table (3), and the system is actually started (4) by calling the low-level function os_start() with the retrieved stack pointer as an argument. From this moment, the OS begins operating in its primary mode, i.e., transferring control from process to process according to their priorities, events, and the user program. Control Transfer \ud83d\udd17 Control can be transferred in two ways: A process voluntarily relinquishes control when it has nothing more to do (for the moment), or as a result of its operation, it needs to engage in inter-process communication (e.g., acquire a mutex semaphore ( OS::TMutex ) or signal an event flag ( OS::TEventFlag )). This informs the kernel, which must then perform process rescheduling if necessary. Control is taken from a process by the kernel as a result of an interrupt triggered by some event. If a higher-priority process was waiting for this event, control will be given to that process. The interrupted process will wait until the higher-priority one completes its task and relinquishes control 4 . In the first case, process rescheduling is performed synchronously relative to the program execution flow \u2014 within the scheduler code. In the second case, rescheduling occurs asynchronously upon the occurrence of an event. The actual control transfer can be organized in several ways. One method is direct control transfer by calling a low-level 6 context switch function from the scheduler 5 . Another method is control transfer by activating a special software interrupt , where the context switch takes place. scmRTOS supports both methods. Each approach has its own advantages and disadvantages, which will be discussed in detail later. The Scheduler \ud83d\udd17 The scheduler's source code is implemented in the sched() function \u2014 see \"Listing 3. The Scheduler\". Two variants are present here \u2014 one for the case of direct control transfer ( scmRTOS_CONTEXT_SWITCH_SCHEME == 0 ), and another for control transfer using a software interrupt. It should be noted that invoking the scheduler from the main program level is done via the scheduler() function. This function calls the actual scheduler ( sched() ) only if the call is not made from within an interrupt: INLINE void scheduler () { if ( ISR_NestCount ) return ; else sched (); } With proper use of the OS facilities, this situation should not occur, because invoking the scheduler from interrupt level should be done through specialized versions of the corresponding functions (their names have the _isr suffix), which are specifically designed for use within interrupts. For example, if it is necessary to signal an event flag from within an interrupt, the user must use the signal_isr() 7 function instead of signal() . However, if the latter is used by mistake, no fatal runtime error will occur; the scheduler simply will not be invoked. Consequently, despite an event possibly occurring within the interrupt, a control transfer will not happen, even if its turn has arrived. The control transfer will only occur during the next call to reschedule, which happens when the destructor of the TISRW / TISRW_SS object is executed. Thus, the check in the scheduler() function serves as protection against program crashes due to careless use of services, as well as when using services for which corresponding _isr functions are not provided \u2014 for example, channel::push() . 01 bool OS :: TKernel :: update_sched_prio () 02 { 03 uint_fast8_t NextPrty = highest_priority ( ReadyProcessMap ); 04 05 if ( NextPrty != CurProcPriority ) 06 { 07 SchedProcPriority = NextPrty ; 08 return true ; 09 } 10 11 return false ; 12 } 13 # if scmRTOS_CONTEXT_SWITCH_SCHEME == 0 14 void TKernel :: sched () 15 { 16 uint_fast8_t NextPrty = highest_priority ( ReadyProcessMap ); 17 if ( NextPrty != CurProcPriority ) 18 { 19 # if scmRTOS_CONTEXT_SWITCH_USER_HOOK_ENABLE == 1 20 context_switch_user_hook (); 21 # endif 22 23 stack_item_t * Next_SP = ProcessTable [ NextPrty ] -> StackPointer ; 24 stack_item_t ** Curr_SP_addr = & ( ProcessTable [ CurProcPriority ] -> StackPointer ); 25 CurProcPriority = NextPrty ; 26 os_context_switcher ( Curr_SP_addr , Next_SP ); 27 } 28 } 29 # else 30 void TKernel :: sched () 31 { 32 if ( update_sched_prio ()) 33 { 34 raise_context_switch (); 35 do 36 { 37 enable_context_switch (); 38 DUMMY_INSTR (); 39 disable_context_switch (); 40 } 41 while ( CurProcPriority != SchedProcPriority ); // until context switch done 42 } 43 } 44 # endif // scmRTOS_CONTEXT_SWITCH_SCHEME Listing 3. The Scheduler Scheduler with Direct Control Transfer \ud83d\udd17 All actions performed inside the scheduler must be non-interruptible; therefore, the code of this function executes within a critical section. However, since the scheduler is always called with interrupts disabled, using a critical section in its code is unnecessary. The first step is to calculate the priority of the highest-priority process ready for execution (by analyzing the ReadyProcessMap \u2013 the map of processes ready to run). Next, the found priority is compared with the current one. If they match, the current process is indeed the highest-priority one ready to run, and no control transfer to another process is required; the execution flow remains within the current process. If the found priority does not match the current one, it means a process with a higher priority than the current one has become ready to run, and control must be transferred to it. This is achieved by switching process contexts. The context of the current process is saved onto its stack, and the context of the next process is restored from its stack. These actions are platform-dependent and are performed in the low-level (assembly-implemented) function os_context_switcher() , which is called from the scheduler (26). This function receives two arguments: The address of the current process's stack pointer, where the pointer itself will be stored after saving the current process's context (24). The stack pointer of the next process (23). When implementing the low-level context switch function, attention must be paid to the calling conventions and parameter passing for the specific platform and compiler. Scheduler with Software Interrupt \ud83d\udd17 In this variant, the scheduler differs significantly from the one described above. The main difference is that the actual context switch does not occur via a direct call to the context switcher function but by activating a special interrupt, within which the context switch takes place. This method harbors several nuances and requires special measures to prevent disruption of the system's integrity. The primary difficulty in implementing this control transfer method is that the scheduler code itself and the software interrupt handler code are not strictly continuous or \"atomic\"; an interrupt can occur between them, which could also initiate rescheduling. This would cause a kind of \"overlap\" of the current rescheduling results and disrupt the integrity of the control transfer process. To avoid this conflict, the \"rescheduling-control transfer\" process is split into two \"atomic\" operations that can be safely separated from each other. The first operation is, as before, calculating the priority of the highest-priority ready process \u2014 calling the update_sched_prio() function (01) \u2014 and checking the need for rescheduling (32). If such a need exists, the priority value of the next process is recorded in the SchedProcPriority variable (07), and the context switch software interrupt is activated (34). The program then enters a loop waiting for the context switch (35). A rather subtle point is hidden here. One might ask, why not simply implement the enabled-interrupts zone as a pair of dummy instructions (to give the processor hardware time to actually trigger the interrupt)? Such an implementation contains a subtle error, which consists of the following. If, at the moment when context switching is enabled (which in this OS version is implemented by globally enabling interrupts (37)), one or several other interrupts besides the software interrupt were pending, and the priority of some of them is higher than that of the software interrupt, then control will naturally be transferred to the handler of that higher-priority interrupt. Upon its completion, a return will be made to the interrupted program. Now, in the main program (i.e., inside the scheduler function), the processor may execute one or several instructions 8 before the next interrupt can be activated. In this case, the program might reach the code that disables context switching, which would lead to interrupts being globally disabled, and the software interrupt, where the context switch is performed, would not be executed. This means the execution flow would remain in the current process, while it should have been transferred to the system (and other processes) until an event that the current process is waiting for occurs. This is nothing other than a breach of system integrity and can lead to a wide variety of difficult-to-predict negative consequences. Obviously, such a situation must not arise. Therefore, instead of a few dummy instructions in the enabled-interrupts zone, a loop waiting for the context switch is used. That is, no matter how many interrupts are queued, until an actual context switch occurs, the program's execution flow will not proceed beyond this loop. For the described mechanism to work, a criterion is needed to determine that rescheduling has indeed occurred. Such a criterion can be the equality of the kernel variables CurProcPriority and SchedProcPriority . These variables become equal to each other (i.e., the value of the current priority becomes equal to the scheduled value) only after the context switch has been performed. As can be seen, there are no updates here to variables containing stack pointers or the current priority value. All these actions are performed later during the actual context switch by calling a special kernel function os_context_switch_hook() . One might wonder: why such complexity? To answer this question, consider a scenario: suppose, in the case of context switching via a software interrupt, the scheduler implementation remained the same as in the case of a direct call to the context switcher. But the call: os_context_switcher ( Curr_SP_addr , Next_SP ); is replaced by 9 : raise_context_switch (); < wait_for_context_switch_done > ; Now, consider a situation where, at the moment interrupts are enabled, one or several other interrupts are pending, and at least one of them has a higher priority than the software interrupt for context switching. Furthermore, in the handler of this higher-priority pending interrupt, a service function (an inter-process communication facility) is called. What would happen in this case? In this case, the scheduler would be called again, and another process rescheduling would occur. However, since the previous rescheduling was not completed\u2014i.e., the processes did not actually switch, and contexts were not physically saved and restored\u2014the new rescheduling would simply overwrite the variables containing the pointers to the current and next processes. Moreover, when determining the need for rescheduling, the value of CurProcPriority would be used, which is actually incorrect because this value represents the priority of the next process scheduled during the previous scheduler call. In short, a \"overlap\" of scheduling operations would occur, disrupting the integrity of the system's operation. Therefore, it is crucial that the actual update of the CurProcPriority value and the switching of process contexts are \"atomic\"\u2014indivisible and not interrupted by any other code related to process scheduling. In the variant with direct context switcher call, this rule is inherently satisfied\u2014the entire scheduler's work happens within a critical section, and the context switcher is called directly from there. In the software interrupt variant, scheduling and context switching can be \"separated\" in time. Therefore, the actual context switch and the change of the current priority occur directly during the execution of the software interrupt handler 10 . Immediately after saving the context of the current process, the os_context_switch_hook() function is called (where the CurProcPriority value is directly updated). Also, the stack pointer of the current process is passed to os_context_switch_hook() , where it is saved in the current process object, and the stack pointer of the next process, required for restoring its context and subsequently transferring control to it, is retrieved and returned from the function. To avoid degrading performance in interrupt handlers, there is a special lightweight, inline version of the scheduler used by some member functions of service objects optimized for use in ISRs. See \"Listing 4. Scheduler Variant Optimized for Use in ISR\" for the code of this scheduler version. 01 void OS :: TKernel :: sched_isr () 02 { 03 if ( update_sched_prio ()) 04 { 05 raise_context_switch (); 06 } 07 } Listing 4. Scheduler Variant Optimized for Use in ISR When selecting the context switch interrupt handler, preference should be given to the one with the lowest priority (in the case of a priority interrupt controller). This helps avoid unnecessary rescheduling and context switches when several interrupts occur in succession. Pros and Cons of Control Transfer Methods \ud83d\udd17 Both methods have their advantages and disadvantages. The advantages of one control transfer method are the disadvantages of the other, and vice versa. Direct Control Transfer \ud83d\udd17 The main advantage of direct control transfer is that implementing this variant does not require a dedicated software interrupt in the target MCU\u2014not all MCUs have such hardware capability. A second minor advantage is slightly higher performance compared to the software interrupt variant, as the latter incurs additional overhead for activating the context switch interrupt handler, the loop waiting for context switch, and the call to os_context_switch_hook() . The direct control transfer variant has a serious drawback\u2014when the scheduler is called from an interrupt handler, the compiler is forced to save the \"local context\" (the processor's scratch registers) due to the call to a non-inline context switch function. This overhead can be quite significant compared to the rest of the ISR code. The negative aspect here is that saving these registers may be completely unnecessary\u2014since the function 11 that necessitates their saving does not use these registers. Therefore, if there are no more calls to non-inline functions, the code for saving and restoring this register group becomes redundant. Software Interrupt-Based Control Transfer \ud83d\udd17 This variant is free from the drawback described above. Because the ISR itself executes in the usual manner and no rescheduling is performed from within it, the saving of the \"local context\" is also not performed. This significantly reduces overhead and improves system performance. To avoid spoiling this advantage by calling a non-inline member function of an inter-process communication service object, it is recommended to use special, lightweight, inline versions of such functions\u2014see the Inter-Process Communication Facilities section for more details. The main disadvantage of control transfer using a software interrupt is that not all hardware platforms support a software interrupt. In such cases, one of the unused hardware interrupts can be used as this software interrupt. Unfortunately, this introduces a lack of universality\u2014it is not known in advance whether a particular hardware interrupt will be required in a given project. Therefore, if the processor does not specifically provide a suitable interrupt, the choice of the context switch interrupt is delegated (from the port level) to the project level, and the user must write the corresponding code themselves 12 . When using control transfer via a software interrupt, the expression \"The kernel takes control away from the processes\" fully reflects the situation. Conclusions \ud83d\udd17 Considering the above analysis of the advantages and disadvantages of both control transfer methods, the general recommendation is as follows: if the target platform provides a suitable interrupt for implementing context switching, it makes sense to use this variant, especially if the size of the \"local context\" is substantial. Using direct control transfer is justified when using a software interrupt is practically impossible\u2014for example, when the target platform does not support such an interrupt, or using a hardware interrupt as a software one is not feasible for various reasons. It may also be chosen if performance characteristics with this transfer method are better due to lower overhead for organizing context switches, and the saving/restoring of the \"local context\" does not incur significant overhead because of its small size 13 . Support for Inter-Process Communication \ud83d\udd17 Support for inter-process communication (IPC) boils down to providing a set of functions for monitoring process states and granting IPC facilities access to the rescheduling mechanisms of the OS. For more details, see the Inter-Process Communication Facilities section. Interrupts \ud83d\udd17 Usage Peculiarities with an RTOS and Implementation \ud83d\udd17 An occurred interrupt can be the source of an event that needs to be handled by a specific process. Therefore, to minimize (and make deterministic) the response time to an event, process rescheduling and control transfer to the highest-priority ready process are used when necessary. The code of any interrupt handler that uses IPC services must call the isr_enter() function upon entry, which increments the ISR_NestCount variable, and call the isr_exit() function upon exit. The latter decrements ISR_NestCount and uses its value to determine the interrupt nesting level (in case of nested interrupts). When ISR_NestCount becomes 0, it indicates a return from the interrupt handler to the main program. At this point, isr_exit() performs process rescheduling (if needed) by calling the interrupt-level scheduler. To simplify usage and ensure portability, the code executed upon entry and exit of interrupt handlers is placed in the constructor and destructor, respectively, of a special wrapper class\u2014 TISRW . An object of this type must be used within the interrupt handler 14 . It is sufficient to create an object of this type in the interrupt handler code; the compiler will handle the rest. It is important that the declaration of this object comes before the first use of any service functions. It should be noted that if a non-inline function is called from within an interrupt handler, the compiler will save the \"local context\"\u2014the scratch 15 registers 16 . Therefore, it is desirable to avoid calls to non-inline functions from interrupt handlers, as even partial context saving degrades both speed and code size 17 . In light of this, the current version of scmRTOS includes special additional lightweight functions for some IPC objects intended for use within interrupt handlers. These functions are inline and use a lightweight version of the scheduler, which is also inline. For more details, see the Inter-Process Communication Facilities section. Separate Interrupt Stack and Nested Interrupts \ud83d\udd17 Another aspect of using a preemptive RTOS is related to interrupts. As known, when an interrupt occurs and control is transferred to its handler, the program uses the stack of the interrupted process for its execution. This stack must have a size sufficient to meet the needs of both the process itself and any interrupt handler. Moreover, it must account for the combined worst-case scenario\u2014for instance, when process execution occupies the peak stack space, and an interrupt occurs whose handler also consumes part of the stack. The stack size must be such that overflow does not occur even in this case. Obviously, the above circumstances concern all processes in the system. If interrupt handlers consume a significant amount of stack space, the stack sizes of all processes must be increased by a certain amount. This leads to increased memory overhead. In the case of nested interrupts, the situation worsens dramatically. To counter this effect, switching the processor's stack pointer to a dedicated interrupt stack upon the occurrence of an interrupt is employed. This way, process stacks and the interrupt stack become \"decoupled\" from each other, eliminating the need to reserve additional memory in each process's stack for interrupt handler execution. The implementation of a separate interrupt stack is done at the port level. Some processors have hardware support for switching the stack pointer to an interrupt stack, making the use of this capability efficient and safe 18 . Nested interrupts\u2014i.e., those whose handlers can interrupt not only the main program but also other interrupt handlers\u2014also have specific usage characteristics. Understanding these is important for the effective and safe use of this mechanism. In the case of a processor with an interrupt controller supporting multi-level prioritized interrupts, the situation with nested interrupts is relatively straightforward\u2014potential hazardous situations when enabling nested interrupts are generally accounted for by the processor designers, and the interrupt controller prevents mishaps, such as those described below. In the case of a processor with a single-level interrupt system, its implementation typically involves automatically disabling interrupts globally upon the occurrence of any interrupt. This is done for simplicity and safety. That is, nested interrupts are not supported in such a system. To enable nested interrupts, it is sufficient to perform a global enable interrupts operation, which on processors with a single-level interrupt system is typically disabled by hardware when control is transferred to an interrupt handler. In this scenario, a situation is possible where an already executing interrupt handler is called again\u2014if a request for handling the same interrupt is still pending 19 . Typically, this is an erroneous situation that must be avoided. To prevent finding oneself in such a position, one must clearly understand both the processor's operational specifics and its \"context\" 20 , and write code very carefully: before globally enabling interrupts, disable the activation of the interrupt whose handler is already executing to avoid re-entry into the same handler. Upon completion of its work, do not forget to restore the processor's control resources to their original state, as it was before manipulating nested interrupt enabling. Based on the above, the following recommendation can be given. WARNING Despite the apparent advantage of the separate interrupt stack scheme, using this variant on processors that lack hardware support for switching the stack pointer to an interrupt stack is not recommended . This is due to the additional overhead of stack switching, poor portability\u2014any non-standard extensions are a source of problems\u2014and the fact that directly interfering with stack pointer management can, in one way or another, cause conflicts with local object addressing. For example, the compiler, seeing the body of an interrupt handler, allocates 21 memory for local objects on the stack. Moreover, it does this before the call 22 to the wrapper's constructor. Thus, after switching the stack pointer to the interrupt stack, the memory allocated earlier will physically be in a different location. The program will then operate incorrectly, and the compiler will be unable to detect this situation. Similarly, using nested interrupts on processors that do not support this capability in hardware is not recommended . Such interrupts require careful handling and typically need additional management\u2014for instance, locking the interrupt source to prevent another call to the same handler when interrupts are enabled. Brief conclusion. The motivation for using stack pointer switching to an interrupt stack correlates with the use of nested interrupts\u2014after all, in the case of nested interrupts, stack consumption (within interrupts) increases significantly. This imposes\u2014in the absence of switching to a separate interrupt stack\u2014additional requirements on the stack sizes of all processes 23 . TIP When using a preemptive RTOS, it is possible to structure the program so that interrupt handlers serve only as event sources , and all event processing is moved to the process level. This allows interrupt handlers to be small and fast, which, in turn, eliminates the need for both switching to an interrupt stack and enabling nested interrupts. In this case, the body of the interrupt handler can be comparable in size to the overhead of switching the stack pointer to an interrupt stack and enabling nested interrupts. This is precisely the recommended approach when the processor lacks hardware support for switching the stack pointer to an interrupt stack and does not have an interrupt controller with hardware support for nested interrupts. It should be noted that a priority-based preemptive RTOS is, in a way, an analogue of a multi-level priority interrupt controller. That is, it provides the ability to distribute code execution according to importance/urgency. In this regard, in most cases, there is no need to place event handling code at the interrupt level, even if such a hardware controller exists. Instead, interrupts should be used only as event sources 24 , with their handling placed at the process level. This is the recommended program design style. System Timer \ud83d\udd17 The system timer is used to generate specific time intervals required for process operation. This includes timeout support. Typically, one of the processor's hardware timers is used as the system timer 25 . The functionality of the system timer is implemented in the kernel function system_timer() . See \"Listing 5. System Timer\" for the code of this function. 01 void OS :: TKernel :: system_timer () 02 { 03 SYS_TIMER_CRIT_SECT (); 04 # if scmRTOS_SYSTEM_TICKS_ENABLE == 1 05 SysTickCount ++ ; 06 # endif 07 08 # if scmRTOS_PRIORITY_ORDER == 0 09 const uint_fast8_t BaseIndex = 0 ; 10 # else 11 const uint_fast8_t BaseIndex = 1 ; 12 # endif 13 14 for ( uint_fast8_t i = BaseIndex ; i < ( PROCESS_COUNT -1 + BaseIndex ); i ++ ) 15 { 16 TBaseProcess * p = ProcessTable [ i ]; 17 18 if ( p -> Timeout > 0 ) 19 { 20 if ( -- p -> Timeout == 0 ) 21 { 22 set_process_ready ( p -> Priority ); 23 } 24 } 25 } 26 } Listing 5. System Timer As can be seen from the source code, the actions are very simple: If the tick counter is enabled, the counter variable is incremented (5). Then, in a loop, the timeout values of all registered processes are checked. If the value of the variable being checked is not equal to 0 26 , it is decremented and checked for 0. If it equals 0 (after decrementing)\u2014i.e., the timeout for this process has expired\u2014the process is moved to the ready state. Since this function is called inside the timer interrupt handler, upon returning to the main program (as described above), control will be transferred to the highest-priority process ready for execution. That is, if the timeout of some process (with higher priority than the interrupted one) expires, it will gain control upon exiting the interrupt. This is implemented using the scheduler (see above) 27 . NOTE Some operating systems provide recommendations for setting the system tick duration. Most often, a range of 10 28 to 100 ms is mentioned. Perhaps for those operating systems, this is correct. The balance here is determined by the desire to achieve the lowest overhead from system timer interrupts and the desire to obtain finer time resolution. Given scmRTOS 's orientation towards small MCUs operating in real-time, and taking into account the fact that the (execution time) overhead 29 is small, the recommended system tick value is 1 to 10 ms . An analogy can be drawn with other domains where smaller objects are usually higher-frequency: for example, a mouse's heartbeat is much faster than a human's, and a human's is faster than an elephant's. At the same time, \"agility\" is inversely related. A similar trend exists in technology; therefore, it is reasonable to expect that for small processors, the system tick period is smaller than for large ones\u2014in larger systems, overhead is generally greater due to the typically higher load on more powerful processors and, consequently, their lower \"agility\". TKernelAgent and Extensions \ud83d\udd17 Kernel Agent \ud83d\udd17 The TKernelAgent class is a special facility designed to provide access to kernel resources when building extensions to enhance the operating system's functionality. The general idea is as follows. Creating various functional extensions for the OS requires access to certain kernel resources\u2014in particular, to the kernel variable containing the priority of the active process or to the system's process map. Providing direct access to this part of the internal representation would not be very wise\u2014it would violate the security model of the object-oriented approach 30 . This leads to negative consequences, such as program inoperability in the absence of proper coding discipline and/or loss of compatibility in case of changes to the kernel's internal representation. Therefore, to solve the problem of accessing kernel resources, an approach based on a specially created class\u2014the kernel agent\u2014has been proposed. This class restricts access through its documented interface. All this allows for the creation of extensions in a formalized way, making the process simpler and safer. The code for the kernel agent class can be found in \"Listing 6. TKernelAgent\". 01 class TKernelAgent 02 { 03 INLINE static TBaseProcess * cur_proc () { return Kernel . ProcessTable [ cur_proc_priority ()]; } 04 05 protected : 06 TKernelAgent () { } 07 INLINE static uint_fast8_t const & cur_proc_priority () { return Kernel . CurProcPriority ; } 08 INLINE static volatile TProcessMap & ready_process_map () { return Kernel . ReadyProcessMap ; } 09 INLINE static volatile timeout_t & cur_proc_timeout () { return cur_proc () -> Timeout ; } 10 INLINE static void reschedule () { Kernel . scheduler (); } 11 12 INLINE static void set_process_ready ( const uint_fast8_t pr ) { Kernel . set_process_ready ( pr ); } 13 INLINE static void set_process_unready ( const uint_fast8_t pr ) { Kernel . set_process_unready ( pr ); } 14 15 # if scmRTOS_DEBUG_ENABLE == 1 16 INLINE static TService * volatile & cur_proc_waiting_for () { return cur_proc () -> WaitingFor ; } 17 # endif 18 19 # if scmRTOS_PROCESS_RESTART_ENABLE == 1 20 INLINE static volatile 21 TProcessMap * & cur_proc_waiting_map () { return cur_proc () -> WaitingProcessMap ; } 22 # endif 23 }; Listing 6. TKernelAgent As can be seen from the code, the class is defined in such a way that it is impossible to create objects of this class. This is done deliberately because, by design, TKernelAgent serves as a base for creating extensions: its main function is to provide a documented interface to kernel resources. Therefore, all use of this code becomes possible only in descendants of this class, which are the actual extensions. An example of using TKernelAgent will be examined in more detail later when describing the base class for creating interprocess communication services, TService . The entire class interface consists of inline functions, which in most cases allows implementing the necessary extensions without loss of efficiency compared to the scenario where access to kernel resources is performed directly. Extensions \ud83d\udd17 The aforementioned kernel agent class enables the creation of additional facilities that extend the functional capabilities of the OS. The methodology for creating such facilities is simple\u2014just declare a class that inherits from TKernelAgent and define its contents. Such classes are called operating system extensions. The placement of the OS kernel code is such that the definitions of classes and a number of member function definitions are separated in the header file os_kernel.h . This makes it possible to write a user class that has access to all definitions of OS kernel types, while at the same time, the definitions of this user class become available in the member functions of the kernel classes\u2014for example, in the scheduler and in the system timer function 31 . Extensions are connected using the configuration file scmRTOS_extensions.h , which is included in os_kernel.h between the definitions of kernel types and their member functions. This allows the definition of an extension class to be physically placed in a separate user header file and included in the project by including this file in scmRTOS_extensions.h . After this, the extension is ready for use according to its intended purpose. Objects marked with \u2018*\u2019 are present only in the variant using software interrupt-based control transfer. \u21a9 Perhaps, from an ideological standpoint, using a pointer to the process for these purposes would be more correct. However, analysis showed no performance gain, and the size of a pointer is typically larger than that of an integer variable for storing a priority. \u21a9 At the same time, the process can be active (i.e., executing) or inactive (i.e., waiting to gain control). The latter situation occurs when there is another ready-to-run process in the system with a higher priority. \u21a9 This higher-priority process can, in turn, be interrupted by an even higher-priority process, and so on, up to the highest-priority process. The highest-priority process can only be (temporarily) interrupted by a hardware interrupt, and upon return from that interrupt, control will always go back to this same highest-priority process. Thus, the highest-priority process cannot be preempted by any other process. Upon exiting an interrupt handler, control is always transferred to the highest-priority process ready for execution. \u21a9 Or upon exiting an interrupt handler \u2014 depending on whether the control transfer is synchronous or asynchronous. \u21a9 Usually implemented in assembly language. \u21a9 All interrupt handlers in a program that use inter-process communication facilities must contain a declaration of a TISRW object placed before any call to a service function (i.e., where the scheduler might be invoked). This object must be declared before the first use of any OS services. \u21a9 This is a common property of many processors \u2014 after returning from an interrupt, a jump to the handler of the next interrupt is not possible immediately in the same machine cycle, but only after one or more cycles. \u21a9 <wait_for_context_switch_done> implies all the code that ensures context switching from starting of interrupts enabling. \u21a9 This software interrupt handler is always implemented in assembly and is also platform-dependent, so its code is not provided here. \u21a9 os_context_switcher ( stack_item_t ** Curr_SP , stack_item_t * Next_SP ) \u21a9 The scmRTOS distribution is offered with several working usage examples where all this code for organizing and configuring the software interrupt is present. Therefore, the user can simply modify this code for their project's needs or use it as-is if it suits them. \u21a9 For example, on MSP430 /IAR, the \"local context\" consists of only 4 registers. \u21a9 The aforementioned functions isr_enter() and isr_exit() are member functions of this wrapper class. \u21a9 Typically, the compiler divides processor registers into two groups: scratch and preserved. Scratch registers are those that any function can use without prior saving. Preserved registers are those whose values must be saved if needed. In some contexts, preserved registers are called local; in the context discussed here, these terms are synonymous. \u21a9 On different platforms, the proportion (of the total number) of these registers varies. For example, when using EWAVR, they occupy about half of the total, while with EW430, it's less than half. In the case of VisualDSP++/ Blackfin , the proportion of these registers is large, but on this platform, stack sizes are typically sufficiently large not to worry about it. \u21a9 Unfortunately, when using the direct control transfer scheme, a call to the non-inline context switch function occurs, making it impossible to avoid the overhead of saving scratch registers in this case. \u21a9 In this case, this mechanism is the only one implemented in the port, and there is no need for a separate implementation of the TISRW_SS wrapper class. \u21a9 This could be related, for example, to events triggering the interrupt too frequently or an uncleared interrupt flag that initiates the interrupt request. \u21a9 Here, \"context\" implies the logical and semantic environment in which this part of the program is executing. \u21a9 More precisely \u2014 reserves it. This is usually done by modifying the stack pointer. \u21a9 It has every right to do so. \u21a9 Furthermore, each process must have a stack size large enough to cover both the process's own needs and the stack consumption of interrupt handlers, including the entire nesting hierarchy. \u21a9 By making interrupt handlers as simple, short, and fast as possible. \u21a9 The simplest timer (without \"bells and whistles\") is suitable for this. The only fundamental requirement is that it must be capable of generating periodic interrupts at equal intervals\u2014for example, an overflow interrupt. It is also desirable to have the ability to control the overflow period to select a suitable system tick frequency. \u21a9 This means the process is waiting with a timeout. \u21a9 Given the ability to set the priority of the system timer interrupt. \u21a9 How, for example, can dynamic indication be organized with such a digit switching period when it is known that for comfortable operation, the switching period (for four digits) should be no more than 5 ms? \u21a9 Due to the small number of processes and the simple, fast scheduler. \u21a9 The principles of encapsulation and abstraction. \u21a9 In user hooks. \u21a9","title":"Kernel"},{"location":"src/kernel/#os-kernel","text":"","title":"OS Kernel"},{"location":"src/kernel/#general-information","text":"The operating system kernel performs the following functions: Process organization and management. Scheduling at both the process and interrupt levels. Support for inter-process communication. System time support (system timer). Support for extensions. The core of the system is the TKernel class, which contains all the necessary set of functions and data. For obvious reasons, only a single instance of this class exists. Almost all of its internal representation is private. To allow access from certain parts of the OS that require its resources, the C++ \"friend\" mechanism is used \u2014 functions and classes granted such access are declared with the friend keyword. It is important to note that in this context, the term \"kernel\" refers not only to the TKernel object but also to the functional extension facility implemented as the TKernelAgent class. This class was specifically introduced into the operating system to provide a base for building extensions. Looking ahead, it can be noted that in scmRTOS , all inter-process communication facilities are implemented based on such an extension. The TKernelAgent class is declared as a friend of the TKernel class and contains a minimal necessary set of protected functions to provide its descendants with access to kernel resources. Extensions are built by inheriting from the TKernelAgent class. For more details, see TKernelAgent and Extensions .","title":"General Information"},{"location":"src/kernel/#tkernel-composition-and-operation","text":"","title":"TKernel. Composition and Operation"},{"location":"src/kernel/#composition","text":"The TKernel class contains the following data members 1 : CurProcPriority \u2013 A variable containing the priority number of the currently active process. Serves for quick access to the current process's resources and for manipulating the process's status (both in relation to the kernel and to IPC facilities) 2 . ReadyProcessMap \u2013 A map of processes ready for execution. Contains tags of processes ready to run: each bit of this variable corresponds to a specific process. A logical 1 indicates that the process is ready for execution 3 , a logical 0 indicates that it is not ready. ProcessTable \u2013 An array of pointers to processes registered in the system. ISR_NestCount \u2013 A counter for interrupt entries. It is incremented on each entry and decremented on each exit. SysTickCount \u2013 A counter for system timer ticks (overflows). Present only if this feature is enabled (via the corresponding macro in the configuration file). SchedProcPriority * \u2013 A variable for storing the priority value of the process scheduled to receive control.","title":"Composition"},{"location":"src/kernel/#process-setup","text":"The process setup essentially involves registering created processes. In the constructor of each process, the kernel function register_process(TBaseProcess *) is called. This function places the pointer to the process (passed as an argument) into the system's ProcessTable (see below). The position of this pointer in the table is determined according to the process's priority, which effectively serves as an index for accessing the table. See \"Listing 1. Process Registration Function\" for the code. 1 void OS :: TKernel :: register_process ( OS :: TBaseProcess * const p ) 2 { 3 ProcessTable [ p -> Priority ] = p ; 4 } Listing 1. Process Registration Function The next system function is the actual OS startup. See \"Listing 2. OS Startup Function\" for the code. 1 INLINE void OS :: run () 2 { 3 stack_item_t * sp = Kernel . ProcessTable [ pr0 ] -> StackPointer ; 4 os_start ( sp ); 5 } Listing 2. OS Startup Function The actions are quite simple: the stack pointer of the highest-priority process is retrieved from the process table (3), and the system is actually started (4) by calling the low-level function os_start() with the retrieved stack pointer as an argument. From this moment, the OS begins operating in its primary mode, i.e., transferring control from process to process according to their priorities, events, and the user program.","title":"Process Setup"},{"location":"src/kernel/#control-transfer","text":"Control can be transferred in two ways: A process voluntarily relinquishes control when it has nothing more to do (for the moment), or as a result of its operation, it needs to engage in inter-process communication (e.g., acquire a mutex semaphore ( OS::TMutex ) or signal an event flag ( OS::TEventFlag )). This informs the kernel, which must then perform process rescheduling if necessary. Control is taken from a process by the kernel as a result of an interrupt triggered by some event. If a higher-priority process was waiting for this event, control will be given to that process. The interrupted process will wait until the higher-priority one completes its task and relinquishes control 4 . In the first case, process rescheduling is performed synchronously relative to the program execution flow \u2014 within the scheduler code. In the second case, rescheduling occurs asynchronously upon the occurrence of an event. The actual control transfer can be organized in several ways. One method is direct control transfer by calling a low-level 6 context switch function from the scheduler 5 . Another method is control transfer by activating a special software interrupt , where the context switch takes place. scmRTOS supports both methods. Each approach has its own advantages and disadvantages, which will be discussed in detail later.","title":"Control Transfer"},{"location":"src/kernel/#the-scheduler","text":"The scheduler's source code is implemented in the sched() function \u2014 see \"Listing 3. The Scheduler\". Two variants are present here \u2014 one for the case of direct control transfer ( scmRTOS_CONTEXT_SWITCH_SCHEME == 0 ), and another for control transfer using a software interrupt. It should be noted that invoking the scheduler from the main program level is done via the scheduler() function. This function calls the actual scheduler ( sched() ) only if the call is not made from within an interrupt: INLINE void scheduler () { if ( ISR_NestCount ) return ; else sched (); } With proper use of the OS facilities, this situation should not occur, because invoking the scheduler from interrupt level should be done through specialized versions of the corresponding functions (their names have the _isr suffix), which are specifically designed for use within interrupts. For example, if it is necessary to signal an event flag from within an interrupt, the user must use the signal_isr() 7 function instead of signal() . However, if the latter is used by mistake, no fatal runtime error will occur; the scheduler simply will not be invoked. Consequently, despite an event possibly occurring within the interrupt, a control transfer will not happen, even if its turn has arrived. The control transfer will only occur during the next call to reschedule, which happens when the destructor of the TISRW / TISRW_SS object is executed. Thus, the check in the scheduler() function serves as protection against program crashes due to careless use of services, as well as when using services for which corresponding _isr functions are not provided \u2014 for example, channel::push() . 01 bool OS :: TKernel :: update_sched_prio () 02 { 03 uint_fast8_t NextPrty = highest_priority ( ReadyProcessMap ); 04 05 if ( NextPrty != CurProcPriority ) 06 { 07 SchedProcPriority = NextPrty ; 08 return true ; 09 } 10 11 return false ; 12 } 13 # if scmRTOS_CONTEXT_SWITCH_SCHEME == 0 14 void TKernel :: sched () 15 { 16 uint_fast8_t NextPrty = highest_priority ( ReadyProcessMap ); 17 if ( NextPrty != CurProcPriority ) 18 { 19 # if scmRTOS_CONTEXT_SWITCH_USER_HOOK_ENABLE == 1 20 context_switch_user_hook (); 21 # endif 22 23 stack_item_t * Next_SP = ProcessTable [ NextPrty ] -> StackPointer ; 24 stack_item_t ** Curr_SP_addr = & ( ProcessTable [ CurProcPriority ] -> StackPointer ); 25 CurProcPriority = NextPrty ; 26 os_context_switcher ( Curr_SP_addr , Next_SP ); 27 } 28 } 29 # else 30 void TKernel :: sched () 31 { 32 if ( update_sched_prio ()) 33 { 34 raise_context_switch (); 35 do 36 { 37 enable_context_switch (); 38 DUMMY_INSTR (); 39 disable_context_switch (); 40 } 41 while ( CurProcPriority != SchedProcPriority ); // until context switch done 42 } 43 } 44 # endif // scmRTOS_CONTEXT_SWITCH_SCHEME Listing 3. The Scheduler","title":"The Scheduler"},{"location":"src/kernel/#scheduler-with-direct-control-transfer","text":"All actions performed inside the scheduler must be non-interruptible; therefore, the code of this function executes within a critical section. However, since the scheduler is always called with interrupts disabled, using a critical section in its code is unnecessary. The first step is to calculate the priority of the highest-priority process ready for execution (by analyzing the ReadyProcessMap \u2013 the map of processes ready to run). Next, the found priority is compared with the current one. If they match, the current process is indeed the highest-priority one ready to run, and no control transfer to another process is required; the execution flow remains within the current process. If the found priority does not match the current one, it means a process with a higher priority than the current one has become ready to run, and control must be transferred to it. This is achieved by switching process contexts. The context of the current process is saved onto its stack, and the context of the next process is restored from its stack. These actions are platform-dependent and are performed in the low-level (assembly-implemented) function os_context_switcher() , which is called from the scheduler (26). This function receives two arguments: The address of the current process's stack pointer, where the pointer itself will be stored after saving the current process's context (24). The stack pointer of the next process (23). When implementing the low-level context switch function, attention must be paid to the calling conventions and parameter passing for the specific platform and compiler.","title":"Scheduler with Direct Control Transfer"},{"location":"src/kernel/#scheduler-with-software-interrupt","text":"In this variant, the scheduler differs significantly from the one described above. The main difference is that the actual context switch does not occur via a direct call to the context switcher function but by activating a special interrupt, within which the context switch takes place. This method harbors several nuances and requires special measures to prevent disruption of the system's integrity. The primary difficulty in implementing this control transfer method is that the scheduler code itself and the software interrupt handler code are not strictly continuous or \"atomic\"; an interrupt can occur between them, which could also initiate rescheduling. This would cause a kind of \"overlap\" of the current rescheduling results and disrupt the integrity of the control transfer process. To avoid this conflict, the \"rescheduling-control transfer\" process is split into two \"atomic\" operations that can be safely separated from each other. The first operation is, as before, calculating the priority of the highest-priority ready process \u2014 calling the update_sched_prio() function (01) \u2014 and checking the need for rescheduling (32). If such a need exists, the priority value of the next process is recorded in the SchedProcPriority variable (07), and the context switch software interrupt is activated (34). The program then enters a loop waiting for the context switch (35). A rather subtle point is hidden here. One might ask, why not simply implement the enabled-interrupts zone as a pair of dummy instructions (to give the processor hardware time to actually trigger the interrupt)? Such an implementation contains a subtle error, which consists of the following. If, at the moment when context switching is enabled (which in this OS version is implemented by globally enabling interrupts (37)), one or several other interrupts besides the software interrupt were pending, and the priority of some of them is higher than that of the software interrupt, then control will naturally be transferred to the handler of that higher-priority interrupt. Upon its completion, a return will be made to the interrupted program. Now, in the main program (i.e., inside the scheduler function), the processor may execute one or several instructions 8 before the next interrupt can be activated. In this case, the program might reach the code that disables context switching, which would lead to interrupts being globally disabled, and the software interrupt, where the context switch is performed, would not be executed. This means the execution flow would remain in the current process, while it should have been transferred to the system (and other processes) until an event that the current process is waiting for occurs. This is nothing other than a breach of system integrity and can lead to a wide variety of difficult-to-predict negative consequences. Obviously, such a situation must not arise. Therefore, instead of a few dummy instructions in the enabled-interrupts zone, a loop waiting for the context switch is used. That is, no matter how many interrupts are queued, until an actual context switch occurs, the program's execution flow will not proceed beyond this loop. For the described mechanism to work, a criterion is needed to determine that rescheduling has indeed occurred. Such a criterion can be the equality of the kernel variables CurProcPriority and SchedProcPriority . These variables become equal to each other (i.e., the value of the current priority becomes equal to the scheduled value) only after the context switch has been performed. As can be seen, there are no updates here to variables containing stack pointers or the current priority value. All these actions are performed later during the actual context switch by calling a special kernel function os_context_switch_hook() . One might wonder: why such complexity? To answer this question, consider a scenario: suppose, in the case of context switching via a software interrupt, the scheduler implementation remained the same as in the case of a direct call to the context switcher. But the call: os_context_switcher ( Curr_SP_addr , Next_SP ); is replaced by 9 : raise_context_switch (); < wait_for_context_switch_done > ; Now, consider a situation where, at the moment interrupts are enabled, one or several other interrupts are pending, and at least one of them has a higher priority than the software interrupt for context switching. Furthermore, in the handler of this higher-priority pending interrupt, a service function (an inter-process communication facility) is called. What would happen in this case? In this case, the scheduler would be called again, and another process rescheduling would occur. However, since the previous rescheduling was not completed\u2014i.e., the processes did not actually switch, and contexts were not physically saved and restored\u2014the new rescheduling would simply overwrite the variables containing the pointers to the current and next processes. Moreover, when determining the need for rescheduling, the value of CurProcPriority would be used, which is actually incorrect because this value represents the priority of the next process scheduled during the previous scheduler call. In short, a \"overlap\" of scheduling operations would occur, disrupting the integrity of the system's operation. Therefore, it is crucial that the actual update of the CurProcPriority value and the switching of process contexts are \"atomic\"\u2014indivisible and not interrupted by any other code related to process scheduling. In the variant with direct context switcher call, this rule is inherently satisfied\u2014the entire scheduler's work happens within a critical section, and the context switcher is called directly from there. In the software interrupt variant, scheduling and context switching can be \"separated\" in time. Therefore, the actual context switch and the change of the current priority occur directly during the execution of the software interrupt handler 10 . Immediately after saving the context of the current process, the os_context_switch_hook() function is called (where the CurProcPriority value is directly updated). Also, the stack pointer of the current process is passed to os_context_switch_hook() , where it is saved in the current process object, and the stack pointer of the next process, required for restoring its context and subsequently transferring control to it, is retrieved and returned from the function. To avoid degrading performance in interrupt handlers, there is a special lightweight, inline version of the scheduler used by some member functions of service objects optimized for use in ISRs. See \"Listing 4. Scheduler Variant Optimized for Use in ISR\" for the code of this scheduler version. 01 void OS :: TKernel :: sched_isr () 02 { 03 if ( update_sched_prio ()) 04 { 05 raise_context_switch (); 06 } 07 } Listing 4. Scheduler Variant Optimized for Use in ISR When selecting the context switch interrupt handler, preference should be given to the one with the lowest priority (in the case of a priority interrupt controller). This helps avoid unnecessary rescheduling and context switches when several interrupts occur in succession.","title":"Scheduler with Software Interrupt"},{"location":"src/kernel/#pros-and-cons-of-control-transfer-methods","text":"Both methods have their advantages and disadvantages. The advantages of one control transfer method are the disadvantages of the other, and vice versa.","title":"Pros and Cons of Control Transfer Methods"},{"location":"src/kernel/#direct-control-transfer","text":"The main advantage of direct control transfer is that implementing this variant does not require a dedicated software interrupt in the target MCU\u2014not all MCUs have such hardware capability. A second minor advantage is slightly higher performance compared to the software interrupt variant, as the latter incurs additional overhead for activating the context switch interrupt handler, the loop waiting for context switch, and the call to os_context_switch_hook() . The direct control transfer variant has a serious drawback\u2014when the scheduler is called from an interrupt handler, the compiler is forced to save the \"local context\" (the processor's scratch registers) due to the call to a non-inline context switch function. This overhead can be quite significant compared to the rest of the ISR code. The negative aspect here is that saving these registers may be completely unnecessary\u2014since the function 11 that necessitates their saving does not use these registers. Therefore, if there are no more calls to non-inline functions, the code for saving and restoring this register group becomes redundant.","title":"Direct Control Transfer"},{"location":"src/kernel/#software-interrupt-based-control-transfer","text":"This variant is free from the drawback described above. Because the ISR itself executes in the usual manner and no rescheduling is performed from within it, the saving of the \"local context\" is also not performed. This significantly reduces overhead and improves system performance. To avoid spoiling this advantage by calling a non-inline member function of an inter-process communication service object, it is recommended to use special, lightweight, inline versions of such functions\u2014see the Inter-Process Communication Facilities section for more details. The main disadvantage of control transfer using a software interrupt is that not all hardware platforms support a software interrupt. In such cases, one of the unused hardware interrupts can be used as this software interrupt. Unfortunately, this introduces a lack of universality\u2014it is not known in advance whether a particular hardware interrupt will be required in a given project. Therefore, if the processor does not specifically provide a suitable interrupt, the choice of the context switch interrupt is delegated (from the port level) to the project level, and the user must write the corresponding code themselves 12 . When using control transfer via a software interrupt, the expression \"The kernel takes control away from the processes\" fully reflects the situation.","title":"Software Interrupt-Based Control Transfer"},{"location":"src/kernel/#conclusions","text":"Considering the above analysis of the advantages and disadvantages of both control transfer methods, the general recommendation is as follows: if the target platform provides a suitable interrupt for implementing context switching, it makes sense to use this variant, especially if the size of the \"local context\" is substantial. Using direct control transfer is justified when using a software interrupt is practically impossible\u2014for example, when the target platform does not support such an interrupt, or using a hardware interrupt as a software one is not feasible for various reasons. It may also be chosen if performance characteristics with this transfer method are better due to lower overhead for organizing context switches, and the saving/restoring of the \"local context\" does not incur significant overhead because of its small size 13 .","title":"Conclusions"},{"location":"src/kernel/#support-for-inter-process-communication","text":"Support for inter-process communication (IPC) boils down to providing a set of functions for monitoring process states and granting IPC facilities access to the rescheduling mechanisms of the OS. For more details, see the Inter-Process Communication Facilities section.","title":"Support for Inter-Process Communication"},{"location":"src/kernel/#interrupts","text":"","title":"Interrupts"},{"location":"src/kernel/#usage-peculiarities-with-an-rtos-and-implementation","text":"An occurred interrupt can be the source of an event that needs to be handled by a specific process. Therefore, to minimize (and make deterministic) the response time to an event, process rescheduling and control transfer to the highest-priority ready process are used when necessary. The code of any interrupt handler that uses IPC services must call the isr_enter() function upon entry, which increments the ISR_NestCount variable, and call the isr_exit() function upon exit. The latter decrements ISR_NestCount and uses its value to determine the interrupt nesting level (in case of nested interrupts). When ISR_NestCount becomes 0, it indicates a return from the interrupt handler to the main program. At this point, isr_exit() performs process rescheduling (if needed) by calling the interrupt-level scheduler. To simplify usage and ensure portability, the code executed upon entry and exit of interrupt handlers is placed in the constructor and destructor, respectively, of a special wrapper class\u2014 TISRW . An object of this type must be used within the interrupt handler 14 . It is sufficient to create an object of this type in the interrupt handler code; the compiler will handle the rest. It is important that the declaration of this object comes before the first use of any service functions. It should be noted that if a non-inline function is called from within an interrupt handler, the compiler will save the \"local context\"\u2014the scratch 15 registers 16 . Therefore, it is desirable to avoid calls to non-inline functions from interrupt handlers, as even partial context saving degrades both speed and code size 17 . In light of this, the current version of scmRTOS includes special additional lightweight functions for some IPC objects intended for use within interrupt handlers. These functions are inline and use a lightweight version of the scheduler, which is also inline. For more details, see the Inter-Process Communication Facilities section.","title":"Usage Peculiarities with an RTOS and Implementation"},{"location":"src/kernel/#separate-interrupt-stack-and-nested-interrupts","text":"Another aspect of using a preemptive RTOS is related to interrupts. As known, when an interrupt occurs and control is transferred to its handler, the program uses the stack of the interrupted process for its execution. This stack must have a size sufficient to meet the needs of both the process itself and any interrupt handler. Moreover, it must account for the combined worst-case scenario\u2014for instance, when process execution occupies the peak stack space, and an interrupt occurs whose handler also consumes part of the stack. The stack size must be such that overflow does not occur even in this case. Obviously, the above circumstances concern all processes in the system. If interrupt handlers consume a significant amount of stack space, the stack sizes of all processes must be increased by a certain amount. This leads to increased memory overhead. In the case of nested interrupts, the situation worsens dramatically. To counter this effect, switching the processor's stack pointer to a dedicated interrupt stack upon the occurrence of an interrupt is employed. This way, process stacks and the interrupt stack become \"decoupled\" from each other, eliminating the need to reserve additional memory in each process's stack for interrupt handler execution. The implementation of a separate interrupt stack is done at the port level. Some processors have hardware support for switching the stack pointer to an interrupt stack, making the use of this capability efficient and safe 18 . Nested interrupts\u2014i.e., those whose handlers can interrupt not only the main program but also other interrupt handlers\u2014also have specific usage characteristics. Understanding these is important for the effective and safe use of this mechanism. In the case of a processor with an interrupt controller supporting multi-level prioritized interrupts, the situation with nested interrupts is relatively straightforward\u2014potential hazardous situations when enabling nested interrupts are generally accounted for by the processor designers, and the interrupt controller prevents mishaps, such as those described below. In the case of a processor with a single-level interrupt system, its implementation typically involves automatically disabling interrupts globally upon the occurrence of any interrupt. This is done for simplicity and safety. That is, nested interrupts are not supported in such a system. To enable nested interrupts, it is sufficient to perform a global enable interrupts operation, which on processors with a single-level interrupt system is typically disabled by hardware when control is transferred to an interrupt handler. In this scenario, a situation is possible where an already executing interrupt handler is called again\u2014if a request for handling the same interrupt is still pending 19 . Typically, this is an erroneous situation that must be avoided. To prevent finding oneself in such a position, one must clearly understand both the processor's operational specifics and its \"context\" 20 , and write code very carefully: before globally enabling interrupts, disable the activation of the interrupt whose handler is already executing to avoid re-entry into the same handler. Upon completion of its work, do not forget to restore the processor's control resources to their original state, as it was before manipulating nested interrupt enabling. Based on the above, the following recommendation can be given. WARNING Despite the apparent advantage of the separate interrupt stack scheme, using this variant on processors that lack hardware support for switching the stack pointer to an interrupt stack is not recommended . This is due to the additional overhead of stack switching, poor portability\u2014any non-standard extensions are a source of problems\u2014and the fact that directly interfering with stack pointer management can, in one way or another, cause conflicts with local object addressing. For example, the compiler, seeing the body of an interrupt handler, allocates 21 memory for local objects on the stack. Moreover, it does this before the call 22 to the wrapper's constructor. Thus, after switching the stack pointer to the interrupt stack, the memory allocated earlier will physically be in a different location. The program will then operate incorrectly, and the compiler will be unable to detect this situation. Similarly, using nested interrupts on processors that do not support this capability in hardware is not recommended . Such interrupts require careful handling and typically need additional management\u2014for instance, locking the interrupt source to prevent another call to the same handler when interrupts are enabled. Brief conclusion. The motivation for using stack pointer switching to an interrupt stack correlates with the use of nested interrupts\u2014after all, in the case of nested interrupts, stack consumption (within interrupts) increases significantly. This imposes\u2014in the absence of switching to a separate interrupt stack\u2014additional requirements on the stack sizes of all processes 23 . TIP When using a preemptive RTOS, it is possible to structure the program so that interrupt handlers serve only as event sources , and all event processing is moved to the process level. This allows interrupt handlers to be small and fast, which, in turn, eliminates the need for both switching to an interrupt stack and enabling nested interrupts. In this case, the body of the interrupt handler can be comparable in size to the overhead of switching the stack pointer to an interrupt stack and enabling nested interrupts. This is precisely the recommended approach when the processor lacks hardware support for switching the stack pointer to an interrupt stack and does not have an interrupt controller with hardware support for nested interrupts. It should be noted that a priority-based preemptive RTOS is, in a way, an analogue of a multi-level priority interrupt controller. That is, it provides the ability to distribute code execution according to importance/urgency. In this regard, in most cases, there is no need to place event handling code at the interrupt level, even if such a hardware controller exists. Instead, interrupts should be used only as event sources 24 , with their handling placed at the process level. This is the recommended program design style.","title":"Separate Interrupt Stack and Nested Interrupts"},{"location":"src/kernel/#system-timer","text":"The system timer is used to generate specific time intervals required for process operation. This includes timeout support. Typically, one of the processor's hardware timers is used as the system timer 25 . The functionality of the system timer is implemented in the kernel function system_timer() . See \"Listing 5. System Timer\" for the code of this function. 01 void OS :: TKernel :: system_timer () 02 { 03 SYS_TIMER_CRIT_SECT (); 04 # if scmRTOS_SYSTEM_TICKS_ENABLE == 1 05 SysTickCount ++ ; 06 # endif 07 08 # if scmRTOS_PRIORITY_ORDER == 0 09 const uint_fast8_t BaseIndex = 0 ; 10 # else 11 const uint_fast8_t BaseIndex = 1 ; 12 # endif 13 14 for ( uint_fast8_t i = BaseIndex ; i < ( PROCESS_COUNT -1 + BaseIndex ); i ++ ) 15 { 16 TBaseProcess * p = ProcessTable [ i ]; 17 18 if ( p -> Timeout > 0 ) 19 { 20 if ( -- p -> Timeout == 0 ) 21 { 22 set_process_ready ( p -> Priority ); 23 } 24 } 25 } 26 } Listing 5. System Timer As can be seen from the source code, the actions are very simple: If the tick counter is enabled, the counter variable is incremented (5). Then, in a loop, the timeout values of all registered processes are checked. If the value of the variable being checked is not equal to 0 26 , it is decremented and checked for 0. If it equals 0 (after decrementing)\u2014i.e., the timeout for this process has expired\u2014the process is moved to the ready state. Since this function is called inside the timer interrupt handler, upon returning to the main program (as described above), control will be transferred to the highest-priority process ready for execution. That is, if the timeout of some process (with higher priority than the interrupted one) expires, it will gain control upon exiting the interrupt. This is implemented using the scheduler (see above) 27 . NOTE Some operating systems provide recommendations for setting the system tick duration. Most often, a range of 10 28 to 100 ms is mentioned. Perhaps for those operating systems, this is correct. The balance here is determined by the desire to achieve the lowest overhead from system timer interrupts and the desire to obtain finer time resolution. Given scmRTOS 's orientation towards small MCUs operating in real-time, and taking into account the fact that the (execution time) overhead 29 is small, the recommended system tick value is 1 to 10 ms . An analogy can be drawn with other domains where smaller objects are usually higher-frequency: for example, a mouse's heartbeat is much faster than a human's, and a human's is faster than an elephant's. At the same time, \"agility\" is inversely related. A similar trend exists in technology; therefore, it is reasonable to expect that for small processors, the system tick period is smaller than for large ones\u2014in larger systems, overhead is generally greater due to the typically higher load on more powerful processors and, consequently, their lower \"agility\".","title":"System Timer"},{"location":"src/kernel/#tkernelagent-and-extensions","text":"","title":"TKernelAgent and Extensions"},{"location":"src/kernel/#kernel-agent","text":"The TKernelAgent class is a special facility designed to provide access to kernel resources when building extensions to enhance the operating system's functionality. The general idea is as follows. Creating various functional extensions for the OS requires access to certain kernel resources\u2014in particular, to the kernel variable containing the priority of the active process or to the system's process map. Providing direct access to this part of the internal representation would not be very wise\u2014it would violate the security model of the object-oriented approach 30 . This leads to negative consequences, such as program inoperability in the absence of proper coding discipline and/or loss of compatibility in case of changes to the kernel's internal representation. Therefore, to solve the problem of accessing kernel resources, an approach based on a specially created class\u2014the kernel agent\u2014has been proposed. This class restricts access through its documented interface. All this allows for the creation of extensions in a formalized way, making the process simpler and safer. The code for the kernel agent class can be found in \"Listing 6. TKernelAgent\". 01 class TKernelAgent 02 { 03 INLINE static TBaseProcess * cur_proc () { return Kernel . ProcessTable [ cur_proc_priority ()]; } 04 05 protected : 06 TKernelAgent () { } 07 INLINE static uint_fast8_t const & cur_proc_priority () { return Kernel . CurProcPriority ; } 08 INLINE static volatile TProcessMap & ready_process_map () { return Kernel . ReadyProcessMap ; } 09 INLINE static volatile timeout_t & cur_proc_timeout () { return cur_proc () -> Timeout ; } 10 INLINE static void reschedule () { Kernel . scheduler (); } 11 12 INLINE static void set_process_ready ( const uint_fast8_t pr ) { Kernel . set_process_ready ( pr ); } 13 INLINE static void set_process_unready ( const uint_fast8_t pr ) { Kernel . set_process_unready ( pr ); } 14 15 # if scmRTOS_DEBUG_ENABLE == 1 16 INLINE static TService * volatile & cur_proc_waiting_for () { return cur_proc () -> WaitingFor ; } 17 # endif 18 19 # if scmRTOS_PROCESS_RESTART_ENABLE == 1 20 INLINE static volatile 21 TProcessMap * & cur_proc_waiting_map () { return cur_proc () -> WaitingProcessMap ; } 22 # endif 23 }; Listing 6. TKernelAgent As can be seen from the code, the class is defined in such a way that it is impossible to create objects of this class. This is done deliberately because, by design, TKernelAgent serves as a base for creating extensions: its main function is to provide a documented interface to kernel resources. Therefore, all use of this code becomes possible only in descendants of this class, which are the actual extensions. An example of using TKernelAgent will be examined in more detail later when describing the base class for creating interprocess communication services, TService . The entire class interface consists of inline functions, which in most cases allows implementing the necessary extensions without loss of efficiency compared to the scenario where access to kernel resources is performed directly.","title":"Kernel Agent"},{"location":"src/kernel/#extensions","text":"The aforementioned kernel agent class enables the creation of additional facilities that extend the functional capabilities of the OS. The methodology for creating such facilities is simple\u2014just declare a class that inherits from TKernelAgent and define its contents. Such classes are called operating system extensions. The placement of the OS kernel code is such that the definitions of classes and a number of member function definitions are separated in the header file os_kernel.h . This makes it possible to write a user class that has access to all definitions of OS kernel types, while at the same time, the definitions of this user class become available in the member functions of the kernel classes\u2014for example, in the scheduler and in the system timer function 31 . Extensions are connected using the configuration file scmRTOS_extensions.h , which is included in os_kernel.h between the definitions of kernel types and their member functions. This allows the definition of an extension class to be physically placed in a separate user header file and included in the project by including this file in scmRTOS_extensions.h . After this, the extension is ready for use according to its intended purpose. Objects marked with \u2018*\u2019 are present only in the variant using software interrupt-based control transfer. \u21a9 Perhaps, from an ideological standpoint, using a pointer to the process for these purposes would be more correct. However, analysis showed no performance gain, and the size of a pointer is typically larger than that of an integer variable for storing a priority. \u21a9 At the same time, the process can be active (i.e., executing) or inactive (i.e., waiting to gain control). The latter situation occurs when there is another ready-to-run process in the system with a higher priority. \u21a9 This higher-priority process can, in turn, be interrupted by an even higher-priority process, and so on, up to the highest-priority process. The highest-priority process can only be (temporarily) interrupted by a hardware interrupt, and upon return from that interrupt, control will always go back to this same highest-priority process. Thus, the highest-priority process cannot be preempted by any other process. Upon exiting an interrupt handler, control is always transferred to the highest-priority process ready for execution. \u21a9 Or upon exiting an interrupt handler \u2014 depending on whether the control transfer is synchronous or asynchronous. \u21a9 Usually implemented in assembly language. \u21a9 All interrupt handlers in a program that use inter-process communication facilities must contain a declaration of a TISRW object placed before any call to a service function (i.e., where the scheduler might be invoked). This object must be declared before the first use of any OS services. \u21a9 This is a common property of many processors \u2014 after returning from an interrupt, a jump to the handler of the next interrupt is not possible immediately in the same machine cycle, but only after one or more cycles. \u21a9 <wait_for_context_switch_done> implies all the code that ensures context switching from starting of interrupts enabling. \u21a9 This software interrupt handler is always implemented in assembly and is also platform-dependent, so its code is not provided here. \u21a9 os_context_switcher ( stack_item_t ** Curr_SP , stack_item_t * Next_SP ) \u21a9 The scmRTOS distribution is offered with several working usage examples where all this code for organizing and configuring the software interrupt is present. Therefore, the user can simply modify this code for their project's needs or use it as-is if it suits them. \u21a9 For example, on MSP430 /IAR, the \"local context\" consists of only 4 registers. \u21a9 The aforementioned functions isr_enter() and isr_exit() are member functions of this wrapper class. \u21a9 Typically, the compiler divides processor registers into two groups: scratch and preserved. Scratch registers are those that any function can use without prior saving. Preserved registers are those whose values must be saved if needed. In some contexts, preserved registers are called local; in the context discussed here, these terms are synonymous. \u21a9 On different platforms, the proportion (of the total number) of these registers varies. For example, when using EWAVR, they occupy about half of the total, while with EW430, it's less than half. In the case of VisualDSP++/ Blackfin , the proportion of these registers is large, but on this platform, stack sizes are typically sufficiently large not to worry about it. \u21a9 Unfortunately, when using the direct control transfer scheme, a call to the non-inline context switch function occurs, making it impossible to avoid the overhead of saving scratch registers in this case. \u21a9 In this case, this mechanism is the only one implemented in the port, and there is no need for a separate implementation of the TISRW_SS wrapper class. \u21a9 This could be related, for example, to events triggering the interrupt too frequently or an uncleared interrupt flag that initiates the interrupt request. \u21a9 Here, \"context\" implies the logical and semantic environment in which this part of the program is executing. \u21a9 More precisely \u2014 reserves it. This is usually done by modifying the stack pointer. \u21a9 It has every right to do so. \u21a9 Furthermore, each process must have a stack size large enough to cover both the process's own needs and the stack consumption of interrupt handlers, including the entire nesting hierarchy. \u21a9 By making interrupt handlers as simple, short, and fast as possible. \u21a9 The simplest timer (without \"bells and whistles\") is suitable for this. The only fundamental requirement is that it must be capable of generating periodic interrupts at equal intervals\u2014for example, an overflow interrupt. It is also desirable to have the ability to control the overflow period to select a suitable system tick frequency. \u21a9 This means the process is waiting with a timeout. \u21a9 Given the ability to set the priority of the system timer interrupt. \u21a9 How, for example, can dynamic indication be organized with such a digit switching period when it is known that for comfortable operation, the switching period (for four digits) should be no more than 5 ms? \u21a9 Due to the small number of processes and the simple, fast scheduler. \u21a9 The principles of encapsulation and abstraction. \u21a9 In user hooks. \u21a9","title":"Extensions"},{"location":"src/overview/","text":"Operating System Overview \ud83d\udd17 General Information \ud83d\udd17 scmRTOS is a real-time operating system with priority-based preemptive multitasking. The OS supports up to 32 processes (including the system IdleProc process, meaning up to 31 user processes), each with a unique priority. All processes are static, i.e., their number is determined at the project build stage and they cannot be added or removed during runtime. The decision to forgo dynamic process creation is driven by the need to conserve resources, which are very limited in single-chip MCUs. Dynamic process deletion is also not implemented because it offers little benefit\u2014the program memory used by a process is not freed, and RAM intended for future use would require the ability to be allocated and deallocated using a memory manager. Such a manager is a complex component in itself, requires significant resources, and is typically not used in single-chip MCU projects 1 . In the current version, process priorities are also static. Each process receives its priority at the project build stage, and this priority cannot be changed during program execution. This approach is similarly motivated by the goal of making the system as lightweight as possible in terms of resource requirements and runtime overhead. Changing priorities during system operation is a highly non-trivial mechanism. For it to work correctly, it requires analyzing the state of the entire system (kernel, services) followed by modifying kernel components and other OS parts (semaphores, event flags, etc.). This inevitably leads to prolonged periods of operation with interrupts disabled and, consequently, significantly degrades the system's real-time performance. OS Structure \ud83d\udd17 The system consists of three main components: the Kernel, processes, and inter-process communication (IPC) facilities. Kernel \ud83d\udd17 The kernel performs the following functions: Process organization and management. Scheduling at both the process and interrupt levels. Support for inter-process communication. System time support (system timer). Support for extensions. For more details on the kernel's structure, composition, functions, and mechanisms, see the OS Kernel section. Processes \ud83d\udd17 Processes provide the ability to create a separate (asynchronous relative to others) program execution flow. For this purpose, each process implements a function that must contain an infinite loop, which serves as the process's main loop \u2013 see \"Listing 1. Process Execution Function\" for an example. 1 template <> void slon_proc :: exec () 2 { 3 ... // Declarations 4 ... // Init process\u2019s data 5 for (;;) 6 { 7 ... // process\u2019s main loop 8 } 9 } Listing 1. Process Execution Function Upon system startup, control is transferred to the process function. At its beginning, you can place declarations for the data it uses (3) and initialization code (4), followed by the process's main loop (5)-(8). The user code must be written to prevent exiting the process function. For example, once it enters the main loop, it should not leave it (the primary approach). Alternatively, if it does exit the main loop, it must enter another loop (even an empty one) or go into an infinite \"sleep\" by calling the sleep() 2 function without parameters (or with parameter \"0\"). For more details, see the sleep() Function . The process code must also not contain return statements to exit the function. Inter-Process Communication \ud83d\udd17 Since processes in the system execute in parallel and asynchronously relative to each other, simply using global data for communication between them is incorrect and unsafe. While one process is accessing an object (which could be a variable of a built-in type, an array, a structure, a class object, etc.), its execution can be interrupted by another (higher-priority) process that also accesses the same object. Due to the non-atomic nature of access operations (read/write), the second process can either disrupt the correctness of the first process's actions or simply read incorrect data. To prevent such situations, special measures must be taken: access must be performed within so-called Critical Sections (where control transfer between processes is prohibited), or specialized inter-process communication (IPC) facilities must be used. The following IPC facilities are available in scmRTOS : Event Flags ( OS::TEventFlag ); Mutual Exclusion Semaphores ( OS::TMutex ); Data Channels in the form of a queue for bytes or objects of arbitrary type ( OS::channel ); Messages ( OS::message ). The developer must decide which facility (or combination thereof) to use in each specific case, based on task requirements, available resources, and personal preference. Starting with scmRTOS v4 , inter-process communication facilities (services) are built upon a common specialized base class, TService . This class provides all the necessary foundational tools for implementing service classes/templates. Its interface is documented and intended for users to extend the set of services themselves. If needed, a user can design and implement their own IPC facility that best meets the requirements of a specific target project. Software Model \ud83d\udd17 Composition and Organization \ud83d\udd17 The scmRTOS source code in any project consists of three parts: the common (core), platform-dependent (target), and project-dependent (project) parts. The common part contains declarations and definitions for kernel functions, processes, system services, as well as a small support library containing some useful code, parts of which are used directly by the OS. The platform-dependent part includes declarations and definitions responsible for implementing functions inherent to the specific target platform, language extensions for the compiler used, etc. This part encompasses the assembly code for context switching and system startup, the function for setting up the stack frame structure, the definition of a critical section wrapper class, the interrupt handler for the hardware timer used as the system timer on that platform, and other platform-dependent behaviors. The project-dependent part consists of three header files containing configuration macro definitions, includes for extensions, and code necessary for fine-tuning the operating system for a specific target project. This includes, in particular, type alias definitions for setting the bit width of timeout variables, selecting the source for the context switch interrupt, and other tools required for optimal system operation. The recommended placement of system source files is as follows: * Common part \u2013 in a separate core directory. * Platform-dependent part \u2013 in its own <target> directory, where target is the name of the system's target port. * Project-dependent part \u2013 directly within the project's source files. This structure is suggested for ease of project storage, transfer, and maintenance, as well as for a simpler and safer system update process when migrating to new versions. The source code of the common part is contained in eight files: scmRTOS.h \u2013 The main header file; it includes the entire hierarchy of system header files. os_kernel.h \u2013 Core declarations and type definitions for the OS kernel. os_kernel.cpp \u2013 Object declarations and function definitions for the kernel. scmRTOS_defs.h \u2013 Auxiliary declarations and macros. os_services.h \u2013 Type and service template definitions. os_services.cpp \u2013 Service function definitions. usrlib.h \u2013 Type and template definitions for the support library. usrlib.cpp \u2013 Support library function definitions. As evident from the list above, scmRTOS also includes a small support library containing code used by the OS facilities 3 . Since this library is not essentially part of the OS itself, its examination will not be covered in detail in this document. The source code of the platform-dependent part is located in three files: os_target.h \u2013 Platform-dependent declarations and macros. os_target_asm.ext 4 \u2013 Low-level code, context switching functions, OS startup. os_target.cpp \u2013 Definitions for the process stack frame initialization function, the interrupt handler function for the timer used as the system timer, and the root function of the background (idle) process. The project-dependent part consists of three header files: scmRTOS_config.h \u2013 Configuration macros and aliases for some types, particularly the type defining the bit width of timeout objects. scmRTOS_target_cfg.h \u2013 Code for tuning OS mechanisms to the needs of a specific project. This can include, for example, assigning the interrupt vector for the hardware timer interrupt handler chosen as the system timer, macros for controlling the system timer, defining the function for activating the context switch interrupt, etc. scmRTOS_extensions.h \u2013 Manages the inclusion of extensions. For more details, see TKernelAgent and Extensions . \u041f\u043e\u043d\u044f\u043b, \u0438\u0441\u043f\u0440\u0430\u0432\u043b\u044f\u044e. \u0423\u0431\u0435\u0440\u0443 \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0436\u0438\u0440\u043d\u044b\u043c \u0434\u043b\u044f \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0439 \u0432 `` \u0438 \u0431\u0443\u0434\u0443 \u0441\u0442\u0440\u043e\u0436\u0435 \u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u044c \u043e\u0440\u0438\u0433\u0438\u043d\u0430\u043b\u044c\u043d\u043e\u043c\u0443 \u0444\u043e\u0440\u043c\u0430\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044e. Internal Structure \ud83d\udd17 Everything related to scmRTOS , except for a few functions implemented in assembly and having the extern \"C\" linkage specification, is placed inside the OS namespace \u2014 this method implements a separate namespace for the operating system's components. The following classes are declared within this namespace 5 : TKernel . Since the kernel in the system can be represented by only one instance, only one object of this class exists. The user must not create objects of this class; TBaseProcess . Implements the object type that serves as the basis for constructing the process template, upon which any (user or system) OS process is implemented; process . A template upon which the type of any OS process is created. TISRW . This is a wrapper class to simplify and automate the procedure for creating interrupt handler code. Its constructor performs actions upon entering an interrupt handler, and its destructor performs the corresponding actions upon exit. TKernelAgent . A special service class intended to provide access to the necessary kernel resources for extending OS capabilities. The TService class, which serves as the base for all inter-process communication facilities, as well as the profiler class, are built upon this class. The list of service classes includes: TService . A base class for building all types and templates of inter-process communication facilities. Contains common functionality and defines the Application Programming Interface (API) for all descendant types. Serves as the basis for extending the set of IPC facilities. TEventFlag . Designed for inter-program interactions via a binary semaphore (event flag); TMutex . A binary semaphore designed for organizing mutual exclusion of access to shared resources; message . A template for creating message objects. A message is \"similar\" to an event flag but can additionally contain an object of an arbitrary type (usually a structure) representing the message body; channel . A template for creating a data channel for an arbitrary type. Serves as the basis for building message queues. As can be seen from the list above, counting semaphores are absent. The reason for this is that, despite all desire, no acute necessity for them could be identified. Resources that need to be controlled using counting semaphores are in acute shortage in single-chip MCUs, primarily RAM. Situations where it is still necessary to control the available quantity are handled using objects created based on the OS::channel template, which internally already implements the corresponding mechanism in one form or another. If such a service is needed, the user can independently add it to the base set by creating their own implementation as an extension; see TKernelAgent and Extensions . scmRTOS provides the user with several control functions: run() . Designed for starting the OS. When this function is called, the actual operation of the operating system begins \u2014 control is transferred to the processes, whose work and mutual interaction are determined by the user program. After transferring control to the OS kernel code, the function does not regain it (control) and, consequently, a return from the function is not provided; lock_system_timer() . Blocks interrupts from the system timer. Since the selection and servicing of the system timer hardware fall under the project's competence, the user must define the content of this function. The same applies to the paired function unlock_system_timer() ; unlock_system_timer() . Unblocks interrupts from the system timer; get_tick_count() . Returns the number of system timer ticks. The system timer tick counter must be enabled when configuring the system; get_proc() . Returns a pointer to a constant process object based on the index passed to the function as an argument. The index is essentially the value of the process's priority. Critical Sections \ud83d\udd17 Due to the preemptive nature of process execution, any process can be interrupted at an arbitrary point in time. On the other hand, there are a number of cases 6 where it is necessary to eliminate the possibility of interrupting a process during the execution of a specific code fragment. This is achieved by disabling task switching 7 for the duration of that fragment's execution. In other words, this fragment becomes a non-interruptible section. In OS terminology, such a section is called a critical section . To simplify the creation of a critical section, a special wrapper class, TCritSect , is provided. The constructor of this class saves the state of the processor resource that controls the global enabling/disabling of interrupts and then disables interrupts. The destructor restores this processor resource to the state it was in before the interrupts were disabled. Thus, if interrupts were already disabled, they will remain disabled. If they were enabled, they will be re-enabled. The implementation of this class is platform-dependent, so its definition is located in the corresponding os_target.h file. Using TCritSect is straightforward: at the point that marks the beginning of the critical section, simply declare an object of this type. From the point of declaration until the end of the block, interrupts will be disabled 8 . Built-in Type Aliases \ud83d\udd17 To simplify working with the source code and to enhance portability, the following type aliases are defined: TProcessMap \u2013 A type for defining a variable that functions as a process map . Its size depends on the number of processes in the system. Each process corresponds to a unique tag\u2014a mask containing only one non-zero bit, positioned according to the priority of that process. The process with the highest priority corresponds to the least significant bit (position 0) 9 . With fewer than 8 user processes, the process map size is 8 bits. For 8 to 15 user processes, the size is 16 bits. For 16 or more user processes, the size is 32 bits. stack_item_t \u2013 The type of a stack element . This depends on the target architecture. For example, on the 8-bit AVR , this type is defined as uint8_t ; on the 16-bit MSP430 , as uint16_t ; and on 32-bit platforms, typically as uint32_t . Using the OS \ud83d\udd17 As mentioned earlier, static mechanisms were used wherever possible to achieve maximum efficiency. This means that all functionality is determined at the compilation stage. This applies primarily to processes. Before using each process, its type must be defined 10 . This definition specifies the process type's name, its priority, and the amount of RAM allocated for its stack . For example: OS :: process < OS :: pr2 , 200 > MainProc ; Here, a process with priority pr2 and a stack size of 200 bytes is defined. This declaration might seem somewhat inconvenient due to its verbosity, because whenever you need to refer to the process type, you must write the full declaration\u2014for example, when defining the process's execution function 11 : template <> void OS :: process < OS :: pr2 , 200 >:: exec () { ... } This is because the exact type is the expression OS :: process < OS :: pr2 , 200 > A similar situation will arise in other cases where you need to refer to the process type. To eliminate this inconvenience, you can use type aliases introduced via typedef . This is the recommended coding style: first define type aliases for the processes (preferably in a single place, such as a header file, to have an immediate overview of how many processes are in the project and what they are), and then declare the actual process objects in the appropriate source files. With this approach, the example above looks like this 12 : // In a header file typedef OS :: process < OS :: pr2 , 200 > TMainProc ; ... template <> void TMainProc :: exec (); // In a source file TMainProc MainProc ; ... template <> void TMainProc :: exec () { ... } ... There is nothing special about this sequence of actions\u2014it is the standard way of describing a type alias and creating an object of that type, common in the C and C++ programming languages. IMPORTANT NOTE The number of processes must be specified when configuring the system. This number must exactly match the number of processes described in the project; otherwise, the system will not work. Please note that a special enumerated type, TPriority , is introduced for specifying priorities. It describes the allowable priority values 13 . Furthermore, the priorities of all processes must be consecutive, without gaps. For example, if there are 4 processes in the system, their priorities must be pr0 , pr1 , pr2 , pr3 . Duplicate priority values are also not allowed, meaning each process must have a unique priority value. For instance, if there are 4 user processes in the system (i.e., 5 processes in total, including the IdleProc system process), the priority values must be pr0 , pr1 , pr2 , pr3 ( prIDLE for IdleProc ), where pr0 is the highest priority process and pr3 is the lowest priority among the user processes. The absolute lowest priority process is IdleProc . This process always exists in the system and does not need to be described. It is this process that gains control when all user processes are in an inactive state. The compiler does not monitor gaps in process priority numbering or the uniqueness of process priority values. Adhering to the principle of separate compilation, there is no efficient way to automate configuration integrity checks using language features alone. Currently, there is a special tool that performs all the work of checking configuration integrity. The utility is called scmIC (IC \u2013 Integrity Checker) and can detect the vast majority of typical OS configuration errors. As mentioned, it is convenient to place the definitions of process types in a header file to make any process easily visible in another compilation unit. An example of typical process usage can be found in \"Listing 2. Defining Process Types in a Header File\" and \"Listing 3. Declaring Processes in a Source File and Starting the OS\". 1 //------------------------------------ 2 // 3 // Process types definition 4 // 5 // 6 typedef OS :: process < OS :: pr0 , 200 > TUARTDrv ; 7 typedef OS :: process < OS :: pr1 , 100 > TLCDProc ; 8 typedef OS :: process < OS :: pr2 , 200 > TMainProc ; 9 typedef OS :: process < OS :: pr3 , 200 > TFPGA_Proc ; 10 //------------------------------------- Listing 2. Defining Process Types in a Header File 1 //------------------------------------- 2 // 3 // Processes declarations 4 // 5 // 6 TUartDrv UartDrv ; 7 TLCDProc LCDProc ; 8 TMainProc MainProc ; 9 TFPGAProc FPGAProc ; 10 //------------------------------------- 11 12 //------------------------------------- 13 void main () 14 { 15 ... // system timer and other stuff initialization 16 OS :: run (); 17 } 18 //------------------------------------- Listing 3. Declaring Processes in a Source File and Starting the OS As mentioned earlier, each process has an execution function. When using the scheme described above, the process execution function is named exec and looks as shown in \"Listing 1. Process Execution Function\". Configuration information is specified in a special header file, scmRTOS_config.h . The list and values 14 of the configuration macros are shown in \"Table 1. Configuration Macros\". Name Value Description scmRTOS_PROCESS_COUNT n Number of processes in the system scmRTOS_SYSTIMER_NEST_INTS_ENABLE 0/1 Enables nested interrupts within the system timer interrupt handler 15 scmRTOS_SYSTEM_TICKS_ENABLE 0/1 Enables the use of the system timer tick counter scmRTOS_SYSTIMER_HOOK_ENABLE 0/1 Enables the call to the system_timer_user_hook() function within the system timer interrupt handler. In this case, the specified function must be defined in the user code scmRTOS_IDLE_HOOK_ENABLE 0/1 Enables the call to the idle_process_user_hook() function within the system IdleProc process. In this case, the specified function must be defined in the user code scmRTOS_ISRW_TYPE TISRW TISRW_SS Selects the type of wrapper class for the system timer interrupt handler \u2014 regular or with a switch to a separate interrupt stack. The suffix _SS stands for Separate Stack scmRTOS_CONTEXT_SWITCH_SCHEME 0/1 Defines the method for context switching (transfer of control) scmRTOS_PRIORITY_ORDER 0/1 Defines the priority order in the process map. A value of 0 corresponds to the case where the highest priority process maps to the least significant bit in the process map ( TProcessMap ). A value of 1 corresponds to the case where the highest priority process maps to the most significant (relevant) bit in the process map scmRTOS_IDLE_PROCESS_STACK_SIZE N Defines the stack size for the IdleProc background process scmRTOS_CONTEXT_SWITCH_USER_HOOK_ENABLE 0/1 Enables the call to the user hook context_switch_user_hook() during context switching. In this case, the function must be defined in the user code scmRTOS_DEBUG_ENABLE 0/1 Enables debugging facilities scmRTOS_PROCESS_RESTART_ENABLE 0/1 Allows interrupting the execution of any process at an arbitrary moment and restarting that process Table 1. Configuration Macros This refers to the standard memory manager provided with development tools. There are situations where a program needs to store data between function calls (i.e., using automatic storage duration\u2014on the stack or in CPU registers\u2014is not suitable), and the total amount of such data is unknown at compile time\u2014its appearance and lifetime are determined by events occurring during program execution. For storing such data, the heap is the most appropriate place. Managing this heap is typically the responsibility of a memory manager. Therefore, some applications cannot do without such a component. However, given the resource consumption of a standard memory manager, its use often becomes impractical. In these situations, a specialized memory manager, designed specifically to meet the application's requirements optimally, is frequently employed. Considering the above, it becomes clear that creating a universal memory manager equally well-suited to the diverse needs of various projects is hardly realistic. This is why scmRTOS does not include a built-in memory manager. \u21a9 In this case, no other process should \"wake up\" this sleeping process before it exits, otherwise undefined behavior will occur and the system will likely crash. The only safe action that can be applied to a process in this situation is to terminate it (with the possibility of restarting it from the beginning later). See Process Restart . \u21a9 Notably, the ring buffer class/template. \u21a9 The assembly file extension for the target processor. \u21a9 Almost all OS classes are declared as friends ( friend ) of each other. This is done to provide access for the OS components to the internal representations of other components without exposing the interface externally, thereby preventing user code from directly using internal OS variables and mechanisms, which enhances usage safety. \u21a9 For example, accessing OS kernel variables or the internal state of inter-process communication facilities. \u21a9 In the current implementation of scmRTOS , this is achieved by disabling interrupts globally. \u21a9 Upon exiting the block, the destructor is automatically called, which restores the state that existed before entering the critical section. This method eliminates the possibility of \"forgetting\" to re-enable interrupts when exiting the critical section. \u21a9 This order is the default. If scmRTOS_PRIORITY_ORDER is defined as 1, the order of bits in the process map is reversed\u2014i.e., the most significant bit corresponds to the highest priority process, and the least significant bit corresponds to the lowest priority process. The reversed priority order can be useful for processors with hardware support for finding the first non-zero bit in a binary word\u2014for example, for processors of the Blackfin family. \u21a9 Each process is an object of a distinct type (class), derived from the common base class TBaseProcess . \u21a9 The execution function of a specific process is technically a full specialization of the member function template OS::process::exec() . Therefore, its definition uses the syntax for defining a specialization: template<> . \u21a9 It is recommended to declare the prototype for the specialization of the process's execution function before the first use of the template instance\u2014this allows the compiler to see that a full specialization of the function exists for this instance, so there is no need to attempt generating the general implementation of that template function. In some cases, this helps avoid compilation errors. \u21a9 This is done to enhance safety\u2014you cannot simply specify any integer value; only the values described in TPriority are valid. The values described in TPriority are linked to the number of processes specified by the configuration macro scmRTOS_PROCESS_COUNT . Thus, you can only choose from a limited set. Process priority values look like: pr0 , pr1 , etc., where the number denotes the priority level. The system process IdleProc has a separate priority designation, prIDLE . \u21a9 The table provides example values. In each project, values are set individually based on the project's requirements. \u21a9 If the port supports only one variant, the corresponding macro value is defined within the port itself. The same applies to all other macros. \u21a9","title":"Overview"},{"location":"src/overview/#operating-system-overview","text":"","title":"Operating System Overview"},{"location":"src/overview/#general-information","text":"scmRTOS is a real-time operating system with priority-based preemptive multitasking. The OS supports up to 32 processes (including the system IdleProc process, meaning up to 31 user processes), each with a unique priority. All processes are static, i.e., their number is determined at the project build stage and they cannot be added or removed during runtime. The decision to forgo dynamic process creation is driven by the need to conserve resources, which are very limited in single-chip MCUs. Dynamic process deletion is also not implemented because it offers little benefit\u2014the program memory used by a process is not freed, and RAM intended for future use would require the ability to be allocated and deallocated using a memory manager. Such a manager is a complex component in itself, requires significant resources, and is typically not used in single-chip MCU projects 1 . In the current version, process priorities are also static. Each process receives its priority at the project build stage, and this priority cannot be changed during program execution. This approach is similarly motivated by the goal of making the system as lightweight as possible in terms of resource requirements and runtime overhead. Changing priorities during system operation is a highly non-trivial mechanism. For it to work correctly, it requires analyzing the state of the entire system (kernel, services) followed by modifying kernel components and other OS parts (semaphores, event flags, etc.). This inevitably leads to prolonged periods of operation with interrupts disabled and, consequently, significantly degrades the system's real-time performance.","title":"General Information"},{"location":"src/overview/#os-structure","text":"The system consists of three main components: the Kernel, processes, and inter-process communication (IPC) facilities.","title":"OS Structure"},{"location":"src/overview/#kernel","text":"The kernel performs the following functions: Process organization and management. Scheduling at both the process and interrupt levels. Support for inter-process communication. System time support (system timer). Support for extensions. For more details on the kernel's structure, composition, functions, and mechanisms, see the OS Kernel section.","title":"Kernel"},{"location":"src/overview/#processes","text":"Processes provide the ability to create a separate (asynchronous relative to others) program execution flow. For this purpose, each process implements a function that must contain an infinite loop, which serves as the process's main loop \u2013 see \"Listing 1. Process Execution Function\" for an example. 1 template <> void slon_proc :: exec () 2 { 3 ... // Declarations 4 ... // Init process\u2019s data 5 for (;;) 6 { 7 ... // process\u2019s main loop 8 } 9 } Listing 1. Process Execution Function Upon system startup, control is transferred to the process function. At its beginning, you can place declarations for the data it uses (3) and initialization code (4), followed by the process's main loop (5)-(8). The user code must be written to prevent exiting the process function. For example, once it enters the main loop, it should not leave it (the primary approach). Alternatively, if it does exit the main loop, it must enter another loop (even an empty one) or go into an infinite \"sleep\" by calling the sleep() 2 function without parameters (or with parameter \"0\"). For more details, see the sleep() Function . The process code must also not contain return statements to exit the function.","title":"Processes"},{"location":"src/overview/#inter-process-communication","text":"Since processes in the system execute in parallel and asynchronously relative to each other, simply using global data for communication between them is incorrect and unsafe. While one process is accessing an object (which could be a variable of a built-in type, an array, a structure, a class object, etc.), its execution can be interrupted by another (higher-priority) process that also accesses the same object. Due to the non-atomic nature of access operations (read/write), the second process can either disrupt the correctness of the first process's actions or simply read incorrect data. To prevent such situations, special measures must be taken: access must be performed within so-called Critical Sections (where control transfer between processes is prohibited), or specialized inter-process communication (IPC) facilities must be used. The following IPC facilities are available in scmRTOS : Event Flags ( OS::TEventFlag ); Mutual Exclusion Semaphores ( OS::TMutex ); Data Channels in the form of a queue for bytes or objects of arbitrary type ( OS::channel ); Messages ( OS::message ). The developer must decide which facility (or combination thereof) to use in each specific case, based on task requirements, available resources, and personal preference. Starting with scmRTOS v4 , inter-process communication facilities (services) are built upon a common specialized base class, TService . This class provides all the necessary foundational tools for implementing service classes/templates. Its interface is documented and intended for users to extend the set of services themselves. If needed, a user can design and implement their own IPC facility that best meets the requirements of a specific target project.","title":"Inter-Process Communication"},{"location":"src/overview/#software-model","text":"","title":"Software Model"},{"location":"src/overview/#composition-and-organization","text":"The scmRTOS source code in any project consists of three parts: the common (core), platform-dependent (target), and project-dependent (project) parts. The common part contains declarations and definitions for kernel functions, processes, system services, as well as a small support library containing some useful code, parts of which are used directly by the OS. The platform-dependent part includes declarations and definitions responsible for implementing functions inherent to the specific target platform, language extensions for the compiler used, etc. This part encompasses the assembly code for context switching and system startup, the function for setting up the stack frame structure, the definition of a critical section wrapper class, the interrupt handler for the hardware timer used as the system timer on that platform, and other platform-dependent behaviors. The project-dependent part consists of three header files containing configuration macro definitions, includes for extensions, and code necessary for fine-tuning the operating system for a specific target project. This includes, in particular, type alias definitions for setting the bit width of timeout variables, selecting the source for the context switch interrupt, and other tools required for optimal system operation. The recommended placement of system source files is as follows: * Common part \u2013 in a separate core directory. * Platform-dependent part \u2013 in its own <target> directory, where target is the name of the system's target port. * Project-dependent part \u2013 directly within the project's source files. This structure is suggested for ease of project storage, transfer, and maintenance, as well as for a simpler and safer system update process when migrating to new versions. The source code of the common part is contained in eight files: scmRTOS.h \u2013 The main header file; it includes the entire hierarchy of system header files. os_kernel.h \u2013 Core declarations and type definitions for the OS kernel. os_kernel.cpp \u2013 Object declarations and function definitions for the kernel. scmRTOS_defs.h \u2013 Auxiliary declarations and macros. os_services.h \u2013 Type and service template definitions. os_services.cpp \u2013 Service function definitions. usrlib.h \u2013 Type and template definitions for the support library. usrlib.cpp \u2013 Support library function definitions. As evident from the list above, scmRTOS also includes a small support library containing code used by the OS facilities 3 . Since this library is not essentially part of the OS itself, its examination will not be covered in detail in this document. The source code of the platform-dependent part is located in three files: os_target.h \u2013 Platform-dependent declarations and macros. os_target_asm.ext 4 \u2013 Low-level code, context switching functions, OS startup. os_target.cpp \u2013 Definitions for the process stack frame initialization function, the interrupt handler function for the timer used as the system timer, and the root function of the background (idle) process. The project-dependent part consists of three header files: scmRTOS_config.h \u2013 Configuration macros and aliases for some types, particularly the type defining the bit width of timeout objects. scmRTOS_target_cfg.h \u2013 Code for tuning OS mechanisms to the needs of a specific project. This can include, for example, assigning the interrupt vector for the hardware timer interrupt handler chosen as the system timer, macros for controlling the system timer, defining the function for activating the context switch interrupt, etc. scmRTOS_extensions.h \u2013 Manages the inclusion of extensions. For more details, see TKernelAgent and Extensions . \u041f\u043e\u043d\u044f\u043b, \u0438\u0441\u043f\u0440\u0430\u0432\u043b\u044f\u044e. \u0423\u0431\u0435\u0440\u0443 \u0432\u044b\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0436\u0438\u0440\u043d\u044b\u043c \u0434\u043b\u044f \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0439 \u0432 `` \u0438 \u0431\u0443\u0434\u0443 \u0441\u0442\u0440\u043e\u0436\u0435 \u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u044c \u043e\u0440\u0438\u0433\u0438\u043d\u0430\u043b\u044c\u043d\u043e\u043c\u0443 \u0444\u043e\u0440\u043c\u0430\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044e.","title":"Composition and Organization"},{"location":"src/overview/#internal-structure","text":"Everything related to scmRTOS , except for a few functions implemented in assembly and having the extern \"C\" linkage specification, is placed inside the OS namespace \u2014 this method implements a separate namespace for the operating system's components. The following classes are declared within this namespace 5 : TKernel . Since the kernel in the system can be represented by only one instance, only one object of this class exists. The user must not create objects of this class; TBaseProcess . Implements the object type that serves as the basis for constructing the process template, upon which any (user or system) OS process is implemented; process . A template upon which the type of any OS process is created. TISRW . This is a wrapper class to simplify and automate the procedure for creating interrupt handler code. Its constructor performs actions upon entering an interrupt handler, and its destructor performs the corresponding actions upon exit. TKernelAgent . A special service class intended to provide access to the necessary kernel resources for extending OS capabilities. The TService class, which serves as the base for all inter-process communication facilities, as well as the profiler class, are built upon this class. The list of service classes includes: TService . A base class for building all types and templates of inter-process communication facilities. Contains common functionality and defines the Application Programming Interface (API) for all descendant types. Serves as the basis for extending the set of IPC facilities. TEventFlag . Designed for inter-program interactions via a binary semaphore (event flag); TMutex . A binary semaphore designed for organizing mutual exclusion of access to shared resources; message . A template for creating message objects. A message is \"similar\" to an event flag but can additionally contain an object of an arbitrary type (usually a structure) representing the message body; channel . A template for creating a data channel for an arbitrary type. Serves as the basis for building message queues. As can be seen from the list above, counting semaphores are absent. The reason for this is that, despite all desire, no acute necessity for them could be identified. Resources that need to be controlled using counting semaphores are in acute shortage in single-chip MCUs, primarily RAM. Situations where it is still necessary to control the available quantity are handled using objects created based on the OS::channel template, which internally already implements the corresponding mechanism in one form or another. If such a service is needed, the user can independently add it to the base set by creating their own implementation as an extension; see TKernelAgent and Extensions . scmRTOS provides the user with several control functions: run() . Designed for starting the OS. When this function is called, the actual operation of the operating system begins \u2014 control is transferred to the processes, whose work and mutual interaction are determined by the user program. After transferring control to the OS kernel code, the function does not regain it (control) and, consequently, a return from the function is not provided; lock_system_timer() . Blocks interrupts from the system timer. Since the selection and servicing of the system timer hardware fall under the project's competence, the user must define the content of this function. The same applies to the paired function unlock_system_timer() ; unlock_system_timer() . Unblocks interrupts from the system timer; get_tick_count() . Returns the number of system timer ticks. The system timer tick counter must be enabled when configuring the system; get_proc() . Returns a pointer to a constant process object based on the index passed to the function as an argument. The index is essentially the value of the process's priority.","title":"Internal Structure"},{"location":"src/overview/#critical-sections","text":"Due to the preemptive nature of process execution, any process can be interrupted at an arbitrary point in time. On the other hand, there are a number of cases 6 where it is necessary to eliminate the possibility of interrupting a process during the execution of a specific code fragment. This is achieved by disabling task switching 7 for the duration of that fragment's execution. In other words, this fragment becomes a non-interruptible section. In OS terminology, such a section is called a critical section . To simplify the creation of a critical section, a special wrapper class, TCritSect , is provided. The constructor of this class saves the state of the processor resource that controls the global enabling/disabling of interrupts and then disables interrupts. The destructor restores this processor resource to the state it was in before the interrupts were disabled. Thus, if interrupts were already disabled, they will remain disabled. If they were enabled, they will be re-enabled. The implementation of this class is platform-dependent, so its definition is located in the corresponding os_target.h file. Using TCritSect is straightforward: at the point that marks the beginning of the critical section, simply declare an object of this type. From the point of declaration until the end of the block, interrupts will be disabled 8 .","title":"Critical Sections"},{"location":"src/overview/#built-in-type-aliases","text":"To simplify working with the source code and to enhance portability, the following type aliases are defined: TProcessMap \u2013 A type for defining a variable that functions as a process map . Its size depends on the number of processes in the system. Each process corresponds to a unique tag\u2014a mask containing only one non-zero bit, positioned according to the priority of that process. The process with the highest priority corresponds to the least significant bit (position 0) 9 . With fewer than 8 user processes, the process map size is 8 bits. For 8 to 15 user processes, the size is 16 bits. For 16 or more user processes, the size is 32 bits. stack_item_t \u2013 The type of a stack element . This depends on the target architecture. For example, on the 8-bit AVR , this type is defined as uint8_t ; on the 16-bit MSP430 , as uint16_t ; and on 32-bit platforms, typically as uint32_t .","title":"Built-in Type Aliases"},{"location":"src/overview/#using-the-os","text":"As mentioned earlier, static mechanisms were used wherever possible to achieve maximum efficiency. This means that all functionality is determined at the compilation stage. This applies primarily to processes. Before using each process, its type must be defined 10 . This definition specifies the process type's name, its priority, and the amount of RAM allocated for its stack . For example: OS :: process < OS :: pr2 , 200 > MainProc ; Here, a process with priority pr2 and a stack size of 200 bytes is defined. This declaration might seem somewhat inconvenient due to its verbosity, because whenever you need to refer to the process type, you must write the full declaration\u2014for example, when defining the process's execution function 11 : template <> void OS :: process < OS :: pr2 , 200 >:: exec () { ... } This is because the exact type is the expression OS :: process < OS :: pr2 , 200 > A similar situation will arise in other cases where you need to refer to the process type. To eliminate this inconvenience, you can use type aliases introduced via typedef . This is the recommended coding style: first define type aliases for the processes (preferably in a single place, such as a header file, to have an immediate overview of how many processes are in the project and what they are), and then declare the actual process objects in the appropriate source files. With this approach, the example above looks like this 12 : // In a header file typedef OS :: process < OS :: pr2 , 200 > TMainProc ; ... template <> void TMainProc :: exec (); // In a source file TMainProc MainProc ; ... template <> void TMainProc :: exec () { ... } ... There is nothing special about this sequence of actions\u2014it is the standard way of describing a type alias and creating an object of that type, common in the C and C++ programming languages. IMPORTANT NOTE The number of processes must be specified when configuring the system. This number must exactly match the number of processes described in the project; otherwise, the system will not work. Please note that a special enumerated type, TPriority , is introduced for specifying priorities. It describes the allowable priority values 13 . Furthermore, the priorities of all processes must be consecutive, without gaps. For example, if there are 4 processes in the system, their priorities must be pr0 , pr1 , pr2 , pr3 . Duplicate priority values are also not allowed, meaning each process must have a unique priority value. For instance, if there are 4 user processes in the system (i.e., 5 processes in total, including the IdleProc system process), the priority values must be pr0 , pr1 , pr2 , pr3 ( prIDLE for IdleProc ), where pr0 is the highest priority process and pr3 is the lowest priority among the user processes. The absolute lowest priority process is IdleProc . This process always exists in the system and does not need to be described. It is this process that gains control when all user processes are in an inactive state. The compiler does not monitor gaps in process priority numbering or the uniqueness of process priority values. Adhering to the principle of separate compilation, there is no efficient way to automate configuration integrity checks using language features alone. Currently, there is a special tool that performs all the work of checking configuration integrity. The utility is called scmIC (IC \u2013 Integrity Checker) and can detect the vast majority of typical OS configuration errors. As mentioned, it is convenient to place the definitions of process types in a header file to make any process easily visible in another compilation unit. An example of typical process usage can be found in \"Listing 2. Defining Process Types in a Header File\" and \"Listing 3. Declaring Processes in a Source File and Starting the OS\". 1 //------------------------------------ 2 // 3 // Process types definition 4 // 5 // 6 typedef OS :: process < OS :: pr0 , 200 > TUARTDrv ; 7 typedef OS :: process < OS :: pr1 , 100 > TLCDProc ; 8 typedef OS :: process < OS :: pr2 , 200 > TMainProc ; 9 typedef OS :: process < OS :: pr3 , 200 > TFPGA_Proc ; 10 //------------------------------------- Listing 2. Defining Process Types in a Header File 1 //------------------------------------- 2 // 3 // Processes declarations 4 // 5 // 6 TUartDrv UartDrv ; 7 TLCDProc LCDProc ; 8 TMainProc MainProc ; 9 TFPGAProc FPGAProc ; 10 //------------------------------------- 11 12 //------------------------------------- 13 void main () 14 { 15 ... // system timer and other stuff initialization 16 OS :: run (); 17 } 18 //------------------------------------- Listing 3. Declaring Processes in a Source File and Starting the OS As mentioned earlier, each process has an execution function. When using the scheme described above, the process execution function is named exec and looks as shown in \"Listing 1. Process Execution Function\". Configuration information is specified in a special header file, scmRTOS_config.h . The list and values 14 of the configuration macros are shown in \"Table 1. Configuration Macros\". Name Value Description scmRTOS_PROCESS_COUNT n Number of processes in the system scmRTOS_SYSTIMER_NEST_INTS_ENABLE 0/1 Enables nested interrupts within the system timer interrupt handler 15 scmRTOS_SYSTEM_TICKS_ENABLE 0/1 Enables the use of the system timer tick counter scmRTOS_SYSTIMER_HOOK_ENABLE 0/1 Enables the call to the system_timer_user_hook() function within the system timer interrupt handler. In this case, the specified function must be defined in the user code scmRTOS_IDLE_HOOK_ENABLE 0/1 Enables the call to the idle_process_user_hook() function within the system IdleProc process. In this case, the specified function must be defined in the user code scmRTOS_ISRW_TYPE TISRW TISRW_SS Selects the type of wrapper class for the system timer interrupt handler \u2014 regular or with a switch to a separate interrupt stack. The suffix _SS stands for Separate Stack scmRTOS_CONTEXT_SWITCH_SCHEME 0/1 Defines the method for context switching (transfer of control) scmRTOS_PRIORITY_ORDER 0/1 Defines the priority order in the process map. A value of 0 corresponds to the case where the highest priority process maps to the least significant bit in the process map ( TProcessMap ). A value of 1 corresponds to the case where the highest priority process maps to the most significant (relevant) bit in the process map scmRTOS_IDLE_PROCESS_STACK_SIZE N Defines the stack size for the IdleProc background process scmRTOS_CONTEXT_SWITCH_USER_HOOK_ENABLE 0/1 Enables the call to the user hook context_switch_user_hook() during context switching. In this case, the function must be defined in the user code scmRTOS_DEBUG_ENABLE 0/1 Enables debugging facilities scmRTOS_PROCESS_RESTART_ENABLE 0/1 Allows interrupting the execution of any process at an arbitrary moment and restarting that process Table 1. Configuration Macros This refers to the standard memory manager provided with development tools. There are situations where a program needs to store data between function calls (i.e., using automatic storage duration\u2014on the stack or in CPU registers\u2014is not suitable), and the total amount of such data is unknown at compile time\u2014its appearance and lifetime are determined by events occurring during program execution. For storing such data, the heap is the most appropriate place. Managing this heap is typically the responsibility of a memory manager. Therefore, some applications cannot do without such a component. However, given the resource consumption of a standard memory manager, its use often becomes impractical. In these situations, a specialized memory manager, designed specifically to meet the application's requirements optimally, is frequently employed. Considering the above, it becomes clear that creating a universal memory manager equally well-suited to the diverse needs of various projects is hardly realistic. This is why scmRTOS does not include a built-in memory manager. \u21a9 In this case, no other process should \"wake up\" this sleeping process before it exits, otherwise undefined behavior will occur and the system will likely crash. The only safe action that can be applied to a process in this situation is to terminate it (with the possibility of restarting it from the beginning later). See Process Restart . \u21a9 Notably, the ring buffer class/template. \u21a9 The assembly file extension for the target processor. \u21a9 Almost all OS classes are declared as friends ( friend ) of each other. This is done to provide access for the OS components to the internal representations of other components without exposing the interface externally, thereby preventing user code from directly using internal OS variables and mechanisms, which enhances usage safety. \u21a9 For example, accessing OS kernel variables or the internal state of inter-process communication facilities. \u21a9 In the current implementation of scmRTOS , this is achieved by disabling interrupts globally. \u21a9 Upon exiting the block, the destructor is automatically called, which restores the state that existed before entering the critical section. This method eliminates the possibility of \"forgetting\" to re-enable interrupts when exiting the critical section. \u21a9 This order is the default. If scmRTOS_PRIORITY_ORDER is defined as 1, the order of bits in the process map is reversed\u2014i.e., the most significant bit corresponds to the highest priority process, and the least significant bit corresponds to the lowest priority process. The reversed priority order can be useful for processors with hardware support for finding the first non-zero bit in a binary word\u2014for example, for processors of the Blackfin family. \u21a9 Each process is an object of a distinct type (class), derived from the common base class TBaseProcess . \u21a9 The execution function of a specific process is technically a full specialization of the member function template OS::process::exec() . Therefore, its definition uses the syntax for defining a specialization: template<> . \u21a9 It is recommended to declare the prototype for the specialization of the process's execution function before the first use of the template instance\u2014this allows the compiler to see that a full specialization of the function exists for this instance, so there is no need to attempt generating the general implementation of that template function. In some cases, this helps avoid compilation errors. \u21a9 This is done to enhance safety\u2014you cannot simply specify any integer value; only the values described in TPriority are valid. The values described in TPriority are linked to the number of processes specified by the configuration macro scmRTOS_PROCESS_COUNT . Thus, you can only choose from a limited set. Process priority values look like: pr0 , pr1 , etc., where the number denotes the priority level. The system process IdleProc has a separate priority designation, prIDLE . \u21a9 The table provides example values. In each project, values are set individually based on the project's requirements. \u21a9 If the port supports only one variant, the corresponding macro value is defined within the port itself. The same applies to all other macros. \u21a9","title":"Using the OS"},{"location":"src/ports/","text":"\u041f\u043e\u0440\u0442\u044b \ud83d\udd17 \u041e\u0431\u0449\u0438\u0435 \u0437\u0430\u043c\u0435\u0447\u0430\u043d\u0438\u044f \ud83d\udd17 \u0412\u0432\u0438\u0434\u0443 \u0431\u043e\u043b\u044c\u0448\u0438\u0445 \u043e\u0442\u043b\u0438\u0447\u0438\u0439 \u043a\u0430\u043a \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u044b\u0445 \u0430\u0440\u0445\u0438\u0442\u0435\u043a\u0442\u0443\u0440, \u0442\u0430\u043a \u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u043f\u043e\u0434 \u043d\u0438\u0445, \u0432\u043e\u0437\u043d\u0438\u043a\u0430\u0435\u0442 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u044c \u0432 \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0430\u0434\u0430\u043f\u0442\u0430\u0446\u0438\u0438 \u043a\u043e\u0434\u0430 \u041e\u0421 1 \u043f\u043e\u0434 \u043d\u0438\u0445. \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u043c \u044d\u0442\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u0430\u044f \u0447\u0430\u0441\u0442\u044c, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0432 \u0441\u043e\u0432\u043e\u043a\u0443\u043f\u043d\u043e\u0441\u0442\u0438 \u0441 \u043e\u0431\u0449\u0435\u0439 \u0447\u0430\u0441\u0442\u044c\u044e \u0438 \u0441\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u043f\u043e\u0440\u0442 \u043f\u043e\u0434 \u0442\u0443 \u0438\u043b\u0438 \u0438\u043d\u0443\u044e \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0443. \u041f\u0440\u043e\u0446\u0435\u0441\u0441 \u043f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0438 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0439 \u0447\u0430\u0441\u0442\u0438 \u043d\u0430\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435\u043c. \u0412 \u043d\u0430\u0441\u0442\u043e\u044f\u0449\u0435\u0439 \u0433\u043b\u0430\u0432\u0435 \u0431\u0443\u0434\u0443\u0442 \u0440\u0430\u0441\u0441\u043c\u043e\u0442\u0440\u0435\u043d\u044b, \u0433\u043b\u0430\u0432\u043d\u044b\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u044b\u0435 \u0447\u0430\u0441\u0442\u0438, \u0438\u0445 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u0438 \u043e\u0441\u043e\u0431\u0435\u043d\u043d\u043e\u0441\u0442\u0438, \u0442\u0430\u043a\u0436\u0435 \u0434\u0430\u043d\u0430 \u043a\u0440\u0430\u0442\u043a\u0430\u044f \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f \u043f\u043e \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044e \u041e\u0421, \u0442.\u0435. \u0447\u0442\u043e \u043d\u0443\u0436\u043d\u043e \u0441\u0434\u0435\u043b\u0430\u0442\u044c, \u0447\u0442\u043e\u0431\u044b \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u043f\u043e\u0440\u0442. \u041f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u0430\u044f \u0447\u0430\u0441\u0442\u044c \u043a\u0430\u0436\u0434\u043e\u0439 \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u044b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\u0439 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438 \u0438 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0442\u0440\u0438 \u0444\u0430\u0439\u043b\u0430: os_target.h \u2013 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u044b\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u0438 \u043c\u0430\u043a\u0440\u043e\u0441\u044b. os_target_asm.ext 2 \u2013 \u043d\u0438\u0437\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u043a\u043e\u0434, \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430, \u0441\u0442\u0430\u0440\u0442\u0430 \u041e\u0421. os_target.cpp \u2013 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0441\u0442\u0435\u043a\u043e\u0432\u043e\u0433\u043e \u043a\u0430\u0434\u0440\u0430 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430 \u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0430 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u044f \u043e\u0442 \u0442\u0430\u0439\u043c\u0435\u0440\u0430, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0433\u043e \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e. \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u043a\u043e\u0434\u0430 \u041e\u0421 \u043d\u0430 \u0446\u0435\u043b\u0435\u0432\u0443\u044e \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0443 \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u0443\u0442\u0451\u043c: \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u0445 \u043c\u0430\u043a\u0440\u043e\u0441\u043e\u0432 \u043f\u0440\u0435\u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430; \u0434\u0438\u0440\u0435\u043a\u0442\u0438\u0432\u0430\u043c\u0438 \u0443\u0441\u043b\u043e\u0432\u043d\u043e\u0439 \u0442\u0440\u0430\u043d\u0441\u043b\u044f\u0446\u0438\u0438; \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435\u043c \u0442\u0438\u043f\u043e\u0432, \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c\u044b\u0445 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u043c, \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0437\u0430\u0432\u0438\u0441\u0438\u0442 \u043e\u0442 \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u044b; \u0437\u0430\u0434\u0430\u043d\u0438\u0435\u043c \u043f\u0441\u0435\u0432\u0434\u043e\u043d\u0438\u043c\u043e\u0432 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0442\u0438\u043f\u043e\u0432; \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u0439, \u043a\u043e\u0434 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0432\u044b\u043d\u0435\u0441\u0435\u043d \u043d\u0430 \u0443\u0440\u043e\u0432\u0435\u043d\u044c \u043f\u043e\u0440\u0442\u0430. \u0412\u0430\u0436\u043d\u043e\u0439 \u0438 \"\u0442\u043e\u043d\u043a\u043e\u0439\" \u0447\u0430\u0441\u0442\u044c\u044e \u043a\u043e\u0434\u0430 \u043f\u043e\u0440\u0442\u0430 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u043d\u044b\u0445 \u043f\u043e\u0434\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c, \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u044e\u0449\u0438\u0445 \u0441\u0442\u0430\u0440\u0442 \u0441\u0438\u0441\u0442\u0435\u043c\u044b, \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u0435\u043c\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430, \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0435\u0439 \u0441\u0442\u0435\u043a\u0430 \u0438 \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430, \u043f\u043e\u043b\u0443\u0447\u0438\u0432\u0448\u0435\u0433\u043e \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435, \u0432 \u0442\u043e\u043c \u0447\u0438\u0441\u043b\u0435 \u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u043e\u0433\u043e \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u044f, \u0432 \u0442\u0435\u043b\u0435 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0441\u044f \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432. \u0427\u0442\u043e\u0431\u044b \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u044d\u0442\u043e\u0442 \u043a\u043e\u0434, \u043e\u0442 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0430 \u043f\u043e\u0440\u0442\u0430 \u0442\u0440\u0435\u0431\u0443\u044e\u0442\u0441\u044f \u0433\u043b\u0443\u0431\u043e\u043a\u0438\u0435 \u0437\u043d\u0430\u043d\u0438\u044f \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u043e\u0439 \u0430\u0440\u0445\u0438\u0442\u0435\u043a\u0442\u0443\u0440\u044b \u043d\u0430 \u043d\u0438\u0437\u043a\u043e\u043c \u0443\u0440\u043e\u0432\u043d\u0435, \u0430 \u0442\u0430\u043a\u0436\u0435 \u0443\u043c\u0435\u043d\u0438\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u044b\u0439 \u043f\u0430\u043a\u0435\u0442 (\u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440, \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440, \u043b\u0438\u043d\u043a\u0435\u0440) \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441\u043e \"\u0441\u043c\u0435\u0448\u0430\u043d\u043d\u044b\u043c\u0438\" 3 \u043f\u0440\u043e\u0435\u043a\u0442\u0430\u043c\u0438. \u041f\u0440\u043e\u0446\u0435\u0441\u0441 \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0441\u0432\u043e\u0434\u0438\u0442\u0441\u044f, \u0433\u043b\u0430\u0432\u043d\u044b\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u043a \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044e \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u044e \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0433\u043e \u043a\u043e\u0434\u0430. \u041e\u0431\u044a\u0435\u043a\u0442\u044b \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \ud83d\udd17 \u041c\u0430\u043a\u0440\u043e\u0441\u044b \ud83d\udd17 \u0421\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0440\u044f\u0434 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u044b\u0445 \u043c\u0430\u043a\u0440\u043e\u0441\u043e\u0432, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u044b. \u0415\u0441\u043b\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043c\u0430\u043a\u0440\u043e\u0441\u0430 \u0432 \u0442\u043e\u043c \u0438\u043b\u0438 \u0438\u043d\u043e\u043c \u043f\u043e\u0440\u0442\u0435 \u043d\u0435 \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f, \u0442\u043e \u043c\u0430\u043a\u0440\u043e\u0441 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0451\u043d \u043f\u0443\u0441\u0442\u044b\u043c. \u041f\u0435\u0440\u0435\u0447\u0435\u043d\u044c \u043c\u0430\u043a\u0440\u043e\u0441\u043e\u0432 \u0438 \u0438\u0445 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u044f \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u044b \u043d\u0438\u0436\u0435. INLINE \u0417\u0430\u0434\u0430\u0451\u0442 \u043f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u043f\u0440\u0438 \u0432\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u043d\u0438\u0438. \u041e\u0431\u044b\u0447\u043d\u043e \u0441\u043e\u0441\u0442\u043e\u0438\u0442 \u0438\u0437 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0439 \u0434\u0438\u0440\u0435\u043a\u0442\u0438\u0432\u044b \u0431\u0435\u0437\u0443\u0441\u043b\u043e\u0432\u043d\u043e\u0433\u043e \u0432\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u043d\u0438\u044f \u0438 \u043a\u043b\u044e\u0447\u0435\u0432\u043e\u0433\u043e \u0441\u043b\u043e\u0432\u0430 inline . OS_PROCESS \u041a\u0432\u0430\u043b\u0438\u0444\u0438\u0446\u0438\u0440\u0443\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u043d\u044f\u0435\u043c\u0443\u044e \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430. \u0421\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u044b\u0439 \u0430\u0442\u0440\u0438\u0431\u0443\u0442, \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0449\u0438\u0439 \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440\u0443, \u0447\u0442\u043e \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043d\u0435 \u0438\u043c\u0435\u0435\u0442 \u0432\u043e\u0437\u0432\u0440\u0430\u0442\u0430, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 preserved 4 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u044b \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430 \u043c\u043e\u0436\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0435\u0437 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f. \u042d\u0442\u043e \u044d\u043a\u043e\u043d\u043e\u043c\u0438\u0442 \u043a\u043e\u0434 \u0438 \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u043e \u0432 \u0441\u0442\u0435\u043a\u0435. OS_INTERRUPT \u0421\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0435 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u0435, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0435 \u0434\u043b\u044f \u043a\u0432\u0430\u043b\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u0432 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439 \u043d\u0430 \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435. DUMMY_INSTR () \u041c\u0430\u043a\u0440\u043e\u0441, \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u044e\u0449\u0438\u0439 \u043f\u0443\u0441\u0442\u0443\u044e \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044e \u0446\u0435\u043b\u0435\u0432\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430 (\u043a\u0430\u043a \u043f\u0440\u0430\u0432\u0438\u043b\u043e, \u044d\u0442\u043e \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f NOP ). \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0432 \u0446\u0438\u043a\u043b\u0435 \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u0432 \u043f\u043b\u0430\u043d\u0438\u0440\u043e\u0432\u0449\u0438\u043a\u0435 (\u0432 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u0435 \u0441 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u044b\u043c \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0435\u043c \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432). INLINE_PROCESS_CTOR \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442 \u043f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u0432\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u043d\u0438\u044f \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u043e\u0432 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432. \u0415\u0441\u043b\u0438 \u043d\u0443\u0436\u043d\u043e \u0432\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u043d\u0438\u0435, \u0442\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u044d\u0442\u043e\u0433\u043e \u043c\u0430\u043a\u0440\u043e\u0441\u0430 \u0434\u043e\u043b\u0436\u043d\u043e INLINE , \u0435\u0441\u043b\u0438 \u0432\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u043d\u0438\u0435 \u043d\u0435 \u043d\u0443\u0436\u043d\u043e, \u0442\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043c\u0430\u043a\u0440\u043e\u0441\u0430 \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c \u043e\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u043e \u043f\u0443\u0441\u0442\u044b\u043c. SYS_TIMER_CRIT_SECT () \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0432 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0435 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e \u0442\u0430\u0439\u043c\u0435\u0440\u0430 \u0438 \u0437\u0430\u0434\u0430\u0451\u0442, \u0431\u0443\u0434\u0435\u0442 \u043b\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u0432 \u043d\u0451\u043c \u043a\u0440\u0438\u0442\u0438\u0447\u0435\u0441\u043a\u0430\u044f \u0441\u0435\u043a\u0446\u0438\u044f, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0430\u043a\u0442\u0443\u0430\u043b\u044c\u043d\u0430 \u0432 \u0441\u043b\u0443\u0447\u0430\u0435, \u0435\u0441\u043b\u0438 \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440 \u0438\u043c\u0435\u0435\u0442 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u043d\u044b\u0439 \u043c\u043d\u043e\u0433\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u043b\u0435\u0440 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439, \u0447\u0442\u043e \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u0432\u0435\u0441\u0442\u0438 \u043a \u0442\u043e\u043c\u0443, \u0447\u0442\u043e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439 \u043e\u0442 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e \u0442\u0430\u0439\u043c\u0435\u0440\u0430 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u0440\u0435\u0440\u0432\u0430\u043d \u0432 \u043d\u0435\u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0443\u0435\u043c\u044b\u0439 \u043c\u043e\u043c\u0435\u043d\u0442 \u0434\u0440\u0443\u0433\u0438\u043c, \u0431\u043e\u043b\u0435\u0435 \u0432\u044b\u0441\u043e\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u043c, \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u043c \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u044c \u0434\u043e\u0441\u0442\u0443\u043f \u043a \u0442\u0435\u043c \u0436\u0435 \u0440\u0435\u0441\u0443\u0440\u0441\u0430\u043c \u041e\u0421, \u0447\u0442\u043e \u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439 \u043e\u0442 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e \u0442\u0430\u0439\u043c\u0435\u0440\u0430. CONTEXT_SWITCH_HOOK_CRIT_SECT \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442, \u0431\u0443\u0434\u0435\u0442 \u0445\u0443\u043a \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0430\u0442\u0435\u043b\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c\u0441\u044f \u0432 \u043a\u0440\u0438\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u0441\u0435\u043a\u0446\u0438\u0438 \u0438\u043b\u0438 \u043d\u0435\u0442. \u041e\u0447\u0435\u043d\u044c \u0432\u0430\u0436\u043d\u043e, \u0447\u0442\u043e\u0431\u044b \u0445\u0443\u043a \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0430\u0442\u0435\u043b\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u043b\u0441\u044f \u0446\u0435\u043b\u043e\u0441\u0442\u043d\u043e \u043f\u043e \u043e\u0442\u043d\u043e\u0448\u0435\u043d\u0438\u044e \u043a \u043c\u0430\u043d\u0438\u043f\u0443\u043b\u044f\u0446\u0438\u044f\u043c \u0441 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u043c\u0438 \u044f\u0434\u0440\u0430 ( SchedProcPriority , \u0432 \u0447\u0430\u0441\u0442\u043d\u043e\u0441\u0442\u0438), \u0430 \u044d\u0442\u043e \u043e\u0437\u043d\u0430\u0447\u0430\u0435\u0442, \u0447\u0442\u043e \u0432\u043e \u0432\u0440\u0435\u043c\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0445\u0443\u043a\u0430 \u043d\u0435 \u0434\u043e\u043b\u0436\u0435\u043d \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c\u0441\u044f \u043f\u043b\u0430\u043d\u0438\u0440\u043e\u0432\u0449\u0438\u043a. \u0412\u044b\u0437\u043e\u0432 \u043f\u043b\u0430\u043d\u0438\u0440\u043e\u0432\u0449\u0438\u043a\u0430 \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u043e\u0438\u0437\u043e\u0439\u0442\u0438 \u0438\u0437 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0430 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439 \u0432 \u0441\u043b\u0443\u0447\u0430\u0435, \u0435\u0441\u043b\u0438 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440 \u0438\u043c\u0435\u0435\u0442 \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u044b\u0439 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u043d\u044b\u0439 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u043b\u0435\u0440 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439 \u0438 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u043e\u0435 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u0438\u043c\u0435\u0435\u0442 \u0431\u043e\u043b\u0435\u0435 \u043d\u0438\u0437\u043a\u0438\u0439 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442 \u043f\u043e \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044e \u0441 \u0434\u0440\u0443\u0433\u0438\u043c\u0438 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u044f\u043c\u0438. \u0412 \u044d\u0442\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u043a\u043e\u0434 \u0445\u0443\u043a\u0430 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0430\u0442\u0435\u043b\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u0434\u043e\u043b\u0436\u0435\u043d \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c\u0441\u044f \u0432 \u043a\u0440\u0438\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u0441\u0435\u043a\u0446\u0438\u0438 \u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043c\u0430\u043a\u0440\u043e\u0441\u0430 \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c TCritSect cs . \u042d\u0442\u043e \u043e\u0447\u0435\u043d\u044c \u0432\u0430\u0436\u043d\u044b\u0439 \u043c\u043e\u043c\u0435\u043d\u0442, \u0435\u0441\u043b\u0438 \u0435\u0433\u043e \u043d\u0435 \u0441\u043e\u0431\u043b\u044e\u0441\u0442\u0438, \u0442\u043e \u0432 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0440\u0430\u0431\u043e\u0442\u044b \u0441\u0438\u0441\u0442\u0435\u043c\u044b \u0431\u0443\u0434\u0443\u0442 \u0432\u043e\u0437\u043d\u0438\u043a\u0430\u0442\u044c \u0442\u0440\u0443\u0434\u043d\u043e\u0443\u043b\u043e\u0432\u0438\u043c\u044b\u0435 \u043e\u0448\u0438\u0431\u043a\u0438, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u043f\u0440\u0438 \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0438 \u0442\u0443\u0442 \u043d\u0443\u0436\u043d\u043e \u043f\u0440\u043e\u044f\u0432\u0438\u0442\u044c \u0432\u043d\u0438\u043c\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0438 \u0430\u043a\u043a\u0443\u0440\u0430\u0442\u043d\u043e\u0441\u0442\u044c. SEPARATE_RETURN_STACK \u0414\u043b\u044f \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c, \u0438\u043c\u0435\u044e\u0449\u0438\u0445 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u0441\u0442\u0435\u043a \u0432\u043e\u0437\u0432\u0440\u0430\u0442\u043e\u0432, \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u044d\u0442\u043e\u0433\u043e \u043c\u0430\u043a\u0440\u043e\u0441\u0430 \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c \u0440\u0430\u0432\u043d\u043e 1. \u0414\u043b\u044f \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0445 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c \u2013 0. \u0422\u0438\u043f\u044b \ud83d\udd17 stack_item_t \u041f\u0441\u0435\u0432\u0434\u043e\u043d\u0438\u043c \u0432\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u043e\u0433\u043e \u0442\u0438\u043f\u0430, \u0437\u0430\u0434\u0430\u0451\u0442 \u0442\u0438\u043f \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u0441\u0442\u0435\u043a\u0430 \u0446\u0435\u043b\u0435\u0432\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430. status_reg_t \u041f\u0441\u0435\u0432\u0434\u043e\u043d\u0438\u043c \u0432\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u043e\u0433\u043e \u0442\u0438\u043f\u0430, \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0439 \u0440\u0430\u0437\u0440\u044f\u0434\u043d\u043e\u0441\u0442\u0438 \u0441\u0442\u0430\u0442\u0443\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430 \u0446\u0435\u043b\u0435\u0432\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430. TCritSect \u041a\u043b\u0430\u0441\u0441-\"\u043e\u0431\u0451\u0440\u0442\u043a\u0430\" \u0434\u043b\u044f \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u0438 \u043a\u0440\u0438\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u0441\u0435\u043a\u0446\u0438\u0438. TPrioMaskTable \u041a\u043b\u0430\u0441\u0441, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u0442\u0430\u0431\u043b\u0438\u0446\u0443 \u043c\u0430\u0441\u043e\u043a (\u0442\u0435\u0433\u043e\u0432) \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u043e\u0432. \u0421\u043b\u0443\u0436\u0438\u0442 \u0434\u043b\u044f \u043f\u043e\u0432\u044b\u0448\u0435\u043d\u0438\u044f \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0438 \u0440\u0430\u0431\u043e\u0442\u044b \u0441\u0438\u0441\u0442\u0435\u043c\u044b. \u041c\u043e\u0436\u0435\u0442 \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c \u043d\u0430 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0430\u0445, \u043d\u0430 \u0442\u0430\u043a\u0438\u0445, \u0433\u0434\u0435 \u0435\u0441\u0442\u044c \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u044b\u0435 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u0442\u0435\u0433\u043e\u0432 \u043f\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u0430, \u2013 \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u044b\u0439 shifter. TISRW \u041a\u043b\u0430\u0441\u0441-\"\u043e\u0431\u0451\u0440\u0442\u043a\u0430\" \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u0432 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439, \u0432 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0441\u0435\u0440\u0432\u0438\u0441\u044b \u041e\u0421. \u0424\u0443\u043d\u043a\u0446\u0438\u0438 \ud83d\udd17 get_prio_tag () \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u0442 \u043d\u043e\u043c\u0435\u0440 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u0430 \u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0439 \u0442\u0435\u0433. \u0424\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e \u044d\u0442\u043e \u0441\u0434\u0432\u0438\u0433 \u0435\u0434\u0438\u043d\u0438\u0446\u044b \u0432 \u0434\u0432\u043e\u0438\u0447\u043d\u043e\u043c \u0441\u043b\u043e\u0432\u0435 \u043d\u0430 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u0437\u0438\u0446\u0438\u0439, \u0440\u0430\u0432\u043d\u043e\u0435 \u043d\u043e\u043c\u0435\u0440\u0443 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u0430. highest_priority () \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043d\u043e\u043c\u0435\u0440 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u0430, \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0433\u043e \u0442\u0435\u0433\u0443 \u043d\u0430\u0438\u0431\u043e\u043b\u0435\u0435 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430 \u0432 \u043a\u0430\u0440\u0442\u0435 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432, \u043f\u0435\u0440\u0435\u0434\u0430\u043d\u043d\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430. disable_context_switch () \u0417\u0430\u043f\u0440\u0435\u0449\u0430\u0435\u0442 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432. \u0412 \u043d\u0430\u0441\u0442\u043e\u044f\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0435\u0442\u0441\u044f \u043f\u0443\u0442\u0451\u043c \u0437\u0430\u043f\u0440\u0435\u0449\u0435\u043d\u0438\u044f \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439. enable_context_switch () \u0420\u0430\u0437\u0440\u0435\u0448\u0430\u0435\u0442 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432. \u0412 \u043d\u0430\u0441\u0442\u043e\u044f\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0435\u0442\u0441\u044f \u0447\u0435\u0440\u0435\u0437 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u0438\u0435 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439. os_start () \u041f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442 \u0441\u0442\u0430\u0440\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b. \u0421\u0430\u043c\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u0430 \u043d\u0430 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u0435. \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u0441\u0442\u0435\u043a\u0430 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430 \u0438 \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u0435\u0442 \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0443 \u0435\u043c\u0443 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u0443\u0442\u0451\u043c \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430 \u0438\u0437 \u0435\u0433\u043e \u0441\u0442\u0435\u043a\u0430. os_context_switcher () \u0424\u0443\u043d\u043a\u0446\u0438\u044f, \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u0430\u044f \u043d\u0430 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u0435, \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432 \u0432 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u0435 \u0441 \u043f\u0440\u044f\u043c\u043e\u0439 \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0435\u0439 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f. context_switcher_isr () \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432. \u0420\u0435\u0430\u043b\u0438\u0437\u0443\u0435\u0442\u0441\u044f \u043d\u0430 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u0435. \u041f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u0435\u043c\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430, \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0435\u0439 \u0441\u0442\u0435\u043a\u043e\u0432 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432 \u043f\u0443\u0442\u0451\u043c \u0432\u044b\u0437\u043e\u0432\u0430 context_switch_hook() 5 \u0438 \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430 \u0430\u043a\u0442\u0438\u0432\u0438\u0440\u0443\u0435\u043c\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430. TBaseProcess :: init_stack_frame () \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0438 \u0441\u0442\u0435\u043a\u043e\u0432\u043e\u0433\u043e \u043a\u0430\u0434\u0440\u0430, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u044f\u0447\u0435\u0435\u043a \u043f\u0430\u043c\u044f\u0442\u0438 \u0432 \u0441\u0442\u0435\u043a\u0435 \u0442\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u0447\u0442\u043e\u0431\u044b \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0441\u0442\u0435\u043a\u0430 \u0431\u044b\u043b\u043e \u0442\u0430\u043a\u0438\u043c, \u043a\u0430\u043a \u0431\u0443\u0434\u0442\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441, \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u043f\u0440\u0438\u043d\u0430\u0434\u043b\u0435\u0436\u0438\u0442 \u0441\u0442\u0435\u043a, \u043f\u0440\u0435\u0440\u0432\u0430\u043d \u0438 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430 \u0441\u043e\u0445\u0440\u0430\u043d\u0451\u043d \u0432 \u0441\u0442\u0435\u043a\u0435. \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u043e\u043c \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430 \u0438 \u043f\u0440\u0438 \u0440\u0435\u0441\u0442\u0430\u0440\u0442\u0435 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430. system_timer_isr () \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e \u0442\u0430\u0439\u043c\u0435\u0440\u0430. \u0412\u044b\u0437\u044b\u0432\u0430\u0435\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e TKernel::system_timer() . \u041f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \ud83d\udd17 \u0414\u043b\u044f \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u043a\u0430\u043a \u043f\u0440\u0430\u0432\u0438\u043b\u043e, \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c \u0434\u043b\u044f \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u044b \u0432\u0441\u0435 \u0432\u044b\u0448\u0435\u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u0435 \u043c\u0430\u043a\u0440\u043e\u0441\u044b, \u0442\u0438\u043f\u044b \u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438. \u041d\u0430\u0438\u0431\u043e\u043b\u0435\u0435 \"\u0442\u043e\u043d\u043a\u0430\u044f\" \u0438 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u043f\u0440\u0438 \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0438 \u0432\u044b\u043f\u0430\u0434\u0430\u0435\u0442 \u043d\u0430 \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044e \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u043d\u043e\u0433\u043e \u043a\u043e\u0434\u0430 \u0438 \u043d\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u043f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0438 \u0441\u0442\u0435\u043a\u043e\u0432\u043e\u0433\u043e \u043a\u0430\u0434\u0440\u0430. \u0420\u044f\u0434 \u043c\u043e\u043c\u0435\u043d\u0442\u043e\u0432, \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0441\u043b\u0435\u0434\u0443\u0435\u0442 \u043e\u0431\u0440\u0430\u0442\u0438\u0442\u044c \u043e\u0441\u043e\u0431\u043e\u0435 \u0432\u043d\u0438\u043c\u0430\u043d\u0438\u0435: \u0432\u044b\u044f\u0441\u043d\u0438\u0442\u044c, \u043a\u0430\u043a\u0438\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0441\u043e\u0433\u043b\u0430\u0448\u0435\u043d\u0438\u044f \u043e \u0432\u044b\u0437\u043e\u0432\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u0443 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0433\u043e \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440\u0430, \u0447\u0442\u043e\u0431\u044b \u0437\u043d\u0430\u0442\u044c, \u043a\u0430\u043a\u0438\u0435 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u044b (\u0438\u043b\u0438 \u043e\u0431\u043b\u0430\u0441\u0442\u044c \u0441\u0442\u0435\u043a\u0430) \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0438 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u0442\u0435\u0445 \u0438\u043b\u0438 \u0438\u043d\u044b\u0445 \u0442\u0438\u043f\u043e\u0432; \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c \u043e\u0441\u043e\u0431\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0440\u0430\u0431\u043e\u0442\u044b \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430 \u0432 \u0447\u0430\u0441\u0442\u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0430\u0434\u0440\u0435\u0441\u043e\u0432 \u0432\u043e\u0437\u0432\u0440\u0430\u0442\u043e\u0432 \u0438 \u0441\u0442\u0430\u0442\u0443\u0441\u043d\u044b\u0445 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u043e\u0432 \u043f\u0440\u0438 \u0432\u043e\u0437\u043d\u0438\u043a\u043d\u043e\u0432\u0435\u043d\u0438\u0438 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u044f \u2013 \u044d\u0442\u043e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0434\u043b\u044f \u043f\u043e\u043d\u0438\u043c\u0430\u043d\u0438\u044f, \u043a\u0430\u043a \u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u0442\u0441\u044f \u0441\u0442\u0435\u043a\u043e\u0432\u044b\u0439 \u043a\u0430\u0434\u0440 \u043d\u0430 \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u043e\u0439 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435, \u0447\u0442\u043e, \u0432 \u0441\u0432\u043e\u044e \u043e\u0447\u0435\u0440\u0435\u0434\u044c, \u0432\u0430\u0436\u043d\u043e \u0434\u043b\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 (\u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0430 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439) \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432, \u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0441\u0442\u0435\u043a\u043e\u0432\u043e\u0433\u043e \u043a\u0430\u0434\u0440\u0430; \u043f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c \u0441\u0445\u0435\u043c\u0443 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u044d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c\u044b\u0445/\u0438\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c\u044b\u0445 \u0438\u043c\u0451\u043d \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u0430. \u0412 \u043f\u0440\u043e\u0441\u0442\u0435\u0439\u0448\u0435\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u0438\u043c\u0435\u043d\u0430 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u043d\u0430 \u0421 (\u0438 \"extern C\" 6 \u043d\u0430 \u0421++) \u043d\u0430 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u0435 \u0432\u0438\u0434\u043d\u044b \u0431\u0435\u0437 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0439, \u043d\u043e \u043d\u0430 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0430\u0445 7 \u043a \u0441\u0430\u043c\u043e\u043c\u0443 \u0438\u043c\u0435\u043d\u0438 \u043c\u043e\u0433\u0443\u0442 \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c\u0441\u044f \u043f\u0440\u0435\u0444\u0438\u043a\u0441\u044b \u0438/\u0438\u043b\u0438 \u0441\u0443\u0444\u0444\u0438\u043a\u0441\u044b, \u0447\u0442\u043e \u043f\u043e\u0442\u0440\u0435\u0431\u0443\u0435\u0442 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u043d\u044b\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0438\u043c\u0435\u043d\u043e\u0432\u0430\u0442\u044c \u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438 \u0441 \u044d\u0442\u043e\u0439 \u0441\u0445\u0435\u043c\u043e\u0439, \u0438\u043d\u0430\u0447\u0435 \u043b\u0438\u043d\u043a\u0435\u0440 \u043d\u0435 \u0441\u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0441\u0432\u044f\u0437\u0438. \u0412\u0435\u0441\u044c \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u043d\u044b\u0439 \u043a\u043e\u0434 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u043f\u043e\u043c\u0435\u0449\u0451\u043d \u0432 \u0444\u0430\u0439\u043b os_target_asm.ext, \u0443\u043f\u043e\u043c\u044f\u043d\u0443\u0442\u044b\u0439 \u0432\u044b\u0448\u0435. \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u043c\u0430\u043a\u0440\u043e\u0441\u043e\u0432 \u0438 \u0442\u0438\u043f\u043e\u0432, \u0430 \u0442\u0430\u043a\u0436\u0435 \u0432\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u043c\u044b\u0445 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u2013 \u0432 \u0444\u0430\u0439\u043b os_target.h. \u0412 \u0444\u0430\u0439\u043b\u0435 os_target.cpp \u043e\u0431\u044a\u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u044b \u0442\u0438\u043f\u043e\u0432, \u0435\u0441\u043b\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e, \u2013 \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, OS::TPrioMaskTable OS::PrioMaskTable , \u0430 \u0442\u0430\u043a\u0436\u0435 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u044e\u0442\u0441\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f TBaseProcess::init_stack_frame() \u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u044f \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e \u0442\u0430\u0439\u043c\u0435\u0440\u0430 system_timer_isr() . \u0412\u044b\u0448\u0435\u043e\u043f\u0438\u0441\u0430\u043d\u043d\u043e\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438\u0448\u044c \u043e\u0431\u0449\u0438\u043c\u0438 \u0441\u0432\u0435\u0434\u0435\u043d\u0438\u044f\u043c\u0438, \u043e\u0442\u043d\u043e\u0441\u044f\u0449\u0438\u043c\u0438\u0441\u044f \u043a \u043f\u043e\u0440\u0442\u0443 \u041e\u0421, \u043f\u0440\u0438 \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0438 \u0432\u043e\u0437\u043d\u0438\u043a\u0430\u0435\u0442 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u043c\u043d\u043e\u0433\u043e \u043d\u044e\u0430\u043d\u0441\u043e\u0432, \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0432\u0435\u0441\u044c\u043c\u0430 \u0447\u0430\u0441\u0442\u043d\u044b\u043c \u0438 \u0432\u044b\u0445\u043e\u0434\u0438\u0442 \u0437\u0430 \u0440\u0430\u043c\u043a\u0438 \u043d\u0430\u0441\u0442\u043e\u044f\u0449\u0435\u0433\u043e \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430. \u0421\u041e\u0412\u0415\u0422 \u041f\u0440\u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0438 \u043d\u043e\u0432\u043e\u0433\u043e \u043f\u043e\u0440\u0442\u0430 \u0438\u043c\u0435\u0435\u0442 \u0441\u043c\u044b\u0441\u043b \u0432\u0437\u044f\u0442\u044c \u0437\u0430 \u043e\u0441\u043d\u043e\u0432\u0443 \u0438\u043b\u0438 \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u043f\u0440\u0438\u043c\u0435\u0440\u0430 \u043e\u0434\u0438\u043d \u0438\u0437 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0445 \u2013 \u044d\u0442\u043e \u0437\u043d\u0430\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0431\u043b\u0435\u0433\u0447\u0430\u0435\u0442 \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f. \u041a\u0430\u043a\u043e\u0439 \u0438\u043c\u0435\u043d\u043d\u043e \u0432\u044b\u0431\u0440\u0430\u0442\u044c \u0438\u0437 \u0438\u043c\u0435\u044e\u0449\u0438\u0445\u0441\u044f \u043f\u043e\u0440\u0442\u043e\u0432, \u0437\u0430\u0432\u0438\u0441\u0438\u0442 \u043e\u0442 \u0431\u043b\u0438\u0437\u043e\u0441\u0442\u0438 \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u043e\u0439 \u0438 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u043e\u0439 \u0447\u0430\u0441\u0442\u0435\u0439 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u044b, \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435. \u0417\u0430\u043f\u0443\u0441\u043a \u0432 \u0441\u043e\u0441\u0442\u0430\u0432\u0435 \u0440\u0430\u0431\u043e\u0447\u0435\u0433\u043e \u043f\u0440\u043e\u0435\u043a\u0442\u0430 \ud83d\udd17 \u0414\u043b\u044f \u043f\u043e\u0432\u044b\u0448\u0435\u043d\u0438\u044f \u0433\u0438\u0431\u043a\u043e\u0441\u0442\u0438 \u0438 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0447\u0430\u0441\u0442\u044c \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0433\u043e \u043a\u043e\u0434\u0430, \u0437\u0430\u0432\u0438\u0441\u044f\u0449\u0430\u044f \u043e\u0442 \u0447\u0430\u0441\u0442\u043d\u044b\u0445 \u043e\u0441\u043e\u0431\u0435\u043d\u043d\u043e\u0441\u0442\u0435\u0439 \u0442\u043e\u0433\u043e \u0438\u043b\u0438 \u0438\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0435\u043a\u0442\u0430 \u0438 \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0433\u043e \u043c\u0438\u043a\u0440\u043e\u043a\u043e\u043d\u0442\u0440\u043e\u043b\u043b\u0435\u0440\u0430, \u0432\u044b\u043d\u0435\u0441\u0435\u043d\u0430 \u043d\u0430 \u0443\u0440\u043e\u0432\u0435\u043d\u044c \u043f\u0440\u043e\u0435\u043a\u0442\u0430. \u0421\u044e\u0434\u0430, \u043a\u0430\u043a \u043f\u0440\u0430\u0432\u0438\u043b\u043e, \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0441\u044f \u0432\u044b\u0431\u043e\u0440 \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u043e\u0433\u043e \u0442\u0430\u0439\u043c\u0435\u0440\u0430 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0433\u043e \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e, \u0430 \u0442\u0430\u043a\u0436\u0435 \u0432\u044b\u0431\u043e\u0440 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u044f \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432, \u0435\u0441\u043b\u0438 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440 \u043d\u0435 \u0438\u043c\u0435\u0435\u0442 \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u043e\u0433\u043e \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u044f. \u0414\u043b\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043f\u043e\u0440\u0442\u0430 \u043f\u0440\u043e\u0435\u043a\u0442 \u0434\u043e\u043b\u0436\u0435\u043d \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0444\u0430\u0439\u043b\u044b: scmRTOS_config.h; scmRTOS_target_cfg.h; scmRTOS_config.h \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0431\u043e\u043b\u044c\u0448\u0438\u043d\u0441\u0442\u0432\u043e \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0445 \u043c\u0430\u043a\u0440\u043e\u0441\u043e\u0432, \u0437\u0430\u0434\u0430\u044e\u0449\u0438\u0445 \u0442\u0430\u043a\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b, \u043a\u0430\u043a \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432 \u0432 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0435, \u0441\u043f\u043e\u0441\u043e\u0431 \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u0438\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0445 \u0445\u0443\u043a\u043e\u0432, \u043f\u043e\u0440\u044f\u0434\u043e\u043a \u043d\u0443\u043c\u0435\u0440\u0430\u0446\u0438\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u043e\u0432 \u0438 \u0442.\u0434. \u0412 scmRTOS_target_cfg.h \u0440\u0430\u0437\u043c\u0435\u0449\u0451\u043d \u043a\u043e\u0434 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0440\u0435\u0441\u0443\u0440\u0441\u0430\u043c\u0438 \u0446\u0435\u043b\u0435\u0432\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430, \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u043c\u0438 \u0434\u043b\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u044b\u0445 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u2013 \u0432\u0441\u0451 \u0442\u043e\u0442 \u0436\u0435 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u044b\u0439 \u0442\u0430\u0439\u043c\u0435\u0440, \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432. \u0421\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u043e\u0431\u043e\u0438\u0445 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0445 \u0444\u0430\u0439\u043b\u043e\u0432 \u043f\u043e\u0434\u0440\u043e\u0431\u043d\u043e \u043e\u043f\u0438\u0441\u0430\u043d\u043e \u0432 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0445, \u043f\u043e\u0441\u0432\u044f\u0449\u0451\u043d\u043d\u044b\u0445 \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u044b\u043c \u043f\u043e\u0440\u0442\u0430\u043c. \u042d\u0442\u043e \u043a\u0430\u0441\u0430\u0435\u0442\u0441\u044f \u043d\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u041e\u0421, \u043d\u043e \u0438 \u0434\u0440\u0443\u0433\u0438\u0445 \u043a\u0440\u043e\u0441\u0441\u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u044b\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c. \u21a9 \u0420\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u0435 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u043d\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430 \u0434\u043b\u044f \u0446\u0435\u043b\u0435\u0432\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430. \u21a9 \u0422.\u0435. \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u043c\u0438 \u0438\u0441\u0445\u043e\u0434\u043d\u044b\u0435 \u0444\u0430\u0439\u043b\u044b \u043d\u0430 \u0440\u0430\u0437\u043d\u044b\u0445 \u044f\u0437\u044b\u043a\u0430\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u2013 \u0432 \u043d\u0430\u0448\u0435\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u0421++ \u0438 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440 \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u043e\u0439 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u044b. \u21a9 \u0422\u0435, \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u043f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u043e, \u0430 \u043f\u043e\u0441\u043b\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043e, \u0447\u0442\u043e\u0431\u044b \u0432\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043d\u0435 \u043f\u043e\u043b\u0443\u0447\u0438\u043b\u0430 \u0438\u0441\u043a\u0430\u0436\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430 \u043f\u0440\u0438 \u0432\u044b\u0437\u043e\u0432\u0435 \u0434\u0440\u0443\u0433\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u0438. \u21a9 \u0427\u0435\u0440\u0435\u0437 \u0444\u0443\u043d\u043a\u0446\u0438\u044e-\"\u043e\u0431\u0451\u0440\u0442\u043a\u0443\"\" os_context_switch_hook() , \u0438\u043c\u0435\u044e\u0449\u0443\u044e \u0441\u043f\u0435\u0446\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044e \u0441\u0432\u044f\u0437\u044b\u0432\u0430\u043d\u0438\u044f \"extern C\" . \u21a9 \u0418\u043c\u0435\u043d\u0430 \u0432 \u0421++ \u043f\u043e\u0434\u0432\u0435\u0440\u0433\u0430\u044e\u0442\u0441\u044f \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u043c\u0443 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044e \u0432 \u0446\u0435\u043b\u044f\u0445 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0438 \u043f\u0435\u0440\u0435\u0433\u0440\u0443\u0437\u043a\u0438 \u0438\u043c\u0451\u043d \u0444\u0443\u043d\u043a\u0446\u0438\u0439, \u0430 \u0442\u0430\u043a\u0436\u0435 \u0434\u043b\u044f \u0442\u0438\u043f\u043e\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0433\u043e \u0441\u0432\u044f\u0437\u044b\u0432\u0430\u043d\u0438\u044f, \u043f\u043e \u043a\u0430\u043a\u043e\u0439 \u043f\u0440\u0438\u0447\u0438\u043d\u0435 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043a \u043d\u0438\u043c \u0434\u043e\u0441\u0442\u0443\u043f \u043d\u0430 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u0435 \u0437\u0430\u0434\u0430\u0447\u0430 \u0442\u0440\u0443\u0434\u043d\u043e\u0432\u044b\u043f\u043e\u043b\u043d\u0438\u043c\u0430\u044f. \u041f\u043e\u044d\u0442\u043e\u043c\u0443 \u0438\u043c\u0435\u043d\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0439, \u043e\u043f\u0438\u0441\u0430\u043d\u043d\u044b\u0445 \u0432 \u0444\u0430\u0439\u043b\u0430\u0445, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043a\u043e\u043c\u043f\u0438\u043b\u0438\u0440\u0443\u044e\u0442\u0441\u044f \u0421++ \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440\u043e\u043c \u0438 \u043a \u043a\u043e\u0442\u043e\u0440\u044b\u043c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c \u0434\u043e\u0441\u0442\u0443\u043f \u0438\u0437 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u043d\u043e\u0433\u043e \u043a\u043e\u0434\u0430, \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u044b \u0432 \u0438\u0441\u0445\u043e\u0434\u043d\u044b\u0445 \u0444\u0430\u0439\u043b\u0430\u0445 \u043a\u0430\u043a \"extern C\" . \u21a9 \u0412 \u0447\u0430\u0441\u0442\u043d\u043e\u0441\u0442\u0438, \u043d\u0430 Blackfin. \u21a9","title":"Ports"},{"location":"src/ports/#_1","text":"","title":"\u041f\u043e\u0440\u0442\u044b"},{"location":"src/ports/#_2","text":"\u0412\u0432\u0438\u0434\u0443 \u0431\u043e\u043b\u044c\u0448\u0438\u0445 \u043e\u0442\u043b\u0438\u0447\u0438\u0439 \u043a\u0430\u043a \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u044b\u0445 \u0430\u0440\u0445\u0438\u0442\u0435\u043a\u0442\u0443\u0440, \u0442\u0430\u043a \u0438 \u0441\u0440\u0435\u0434\u0441\u0442\u0432 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u043f\u043e\u0434 \u043d\u0438\u0445, \u0432\u043e\u0437\u043d\u0438\u043a\u0430\u0435\u0442 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u044c \u0432 \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u0439 \u0430\u0434\u0430\u043f\u0442\u0430\u0446\u0438\u0438 \u043a\u043e\u0434\u0430 \u041e\u0421 1 \u043f\u043e\u0434 \u043d\u0438\u0445. \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u043c \u044d\u0442\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u0430\u044f \u0447\u0430\u0441\u0442\u044c, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0432 \u0441\u043e\u0432\u043e\u043a\u0443\u043f\u043d\u043e\u0441\u0442\u0438 \u0441 \u043e\u0431\u0449\u0435\u0439 \u0447\u0430\u0441\u0442\u044c\u044e \u0438 \u0441\u043e\u0441\u0442\u0430\u0432\u043b\u044f\u0435\u0442 \u043f\u043e\u0440\u0442 \u043f\u043e\u0434 \u0442\u0443 \u0438\u043b\u0438 \u0438\u043d\u0443\u044e \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0443. \u041f\u0440\u043e\u0446\u0435\u0441\u0441 \u043f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0438 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0439 \u0447\u0430\u0441\u0442\u0438 \u043d\u0430\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435\u043c. \u0412 \u043d\u0430\u0441\u0442\u043e\u044f\u0449\u0435\u0439 \u0433\u043b\u0430\u0432\u0435 \u0431\u0443\u0434\u0443\u0442 \u0440\u0430\u0441\u0441\u043c\u043e\u0442\u0440\u0435\u043d\u044b, \u0433\u043b\u0430\u0432\u043d\u044b\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u044b\u0435 \u0447\u0430\u0441\u0442\u0438, \u0438\u0445 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u0438 \u043e\u0441\u043e\u0431\u0435\u043d\u043d\u043e\u0441\u0442\u0438, \u0442\u0430\u043a\u0436\u0435 \u0434\u0430\u043d\u0430 \u043a\u0440\u0430\u0442\u043a\u0430\u044f \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f \u043f\u043e \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044e \u041e\u0421, \u0442.\u0435. \u0447\u0442\u043e \u043d\u0443\u0436\u043d\u043e \u0441\u0434\u0435\u043b\u0430\u0442\u044c, \u0447\u0442\u043e\u0431\u044b \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u043f\u043e\u0440\u0442. \u041f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u0430\u044f \u0447\u0430\u0441\u0442\u044c \u043a\u0430\u0436\u0434\u043e\u0439 \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u044b \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442\u0441\u044f \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u043e\u0439 \u0434\u0438\u0440\u0435\u043a\u0442\u043e\u0440\u0438\u0438 \u0438 \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0442\u0440\u0438 \u0444\u0430\u0439\u043b\u0430: os_target.h \u2013 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u044b\u0435 \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u0438 \u043c\u0430\u043a\u0440\u043e\u0441\u044b. os_target_asm.ext 2 \u2013 \u043d\u0438\u0437\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u043a\u043e\u0434, \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430, \u0441\u0442\u0430\u0440\u0442\u0430 \u041e\u0421. os_target.cpp \u2013 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0441\u0442\u0435\u043a\u043e\u0432\u043e\u0433\u043e \u043a\u0430\u0434\u0440\u0430 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430 \u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0430 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u044f \u043e\u0442 \u0442\u0430\u0439\u043c\u0435\u0440\u0430, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0433\u043e \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e. \u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u043a\u043e\u0434\u0430 \u041e\u0421 \u043d\u0430 \u0446\u0435\u043b\u0435\u0432\u0443\u044e \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0443 \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u0443\u0442\u0451\u043c: \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u044b\u0445 \u043c\u0430\u043a\u0440\u043e\u0441\u043e\u0432 \u043f\u0440\u0435\u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430; \u0434\u0438\u0440\u0435\u043a\u0442\u0438\u0432\u0430\u043c\u0438 \u0443\u0441\u043b\u043e\u0432\u043d\u043e\u0439 \u0442\u0440\u0430\u043d\u0441\u043b\u044f\u0446\u0438\u0438; \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435\u043c \u0442\u0438\u043f\u043e\u0432, \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c\u044b\u0445 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u043c, \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0437\u0430\u0432\u0438\u0441\u0438\u0442 \u043e\u0442 \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u044b; \u0437\u0430\u0434\u0430\u043d\u0438\u0435\u043c \u043f\u0441\u0435\u0432\u0434\u043e\u043d\u0438\u043c\u043e\u0432 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0442\u0438\u043f\u043e\u0432; \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u0439, \u043a\u043e\u0434 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0432\u044b\u043d\u0435\u0441\u0435\u043d \u043d\u0430 \u0443\u0440\u043e\u0432\u0435\u043d\u044c \u043f\u043e\u0440\u0442\u0430. \u0412\u0430\u0436\u043d\u043e\u0439 \u0438 \"\u0442\u043e\u043d\u043a\u043e\u0439\" \u0447\u0430\u0441\u0442\u044c\u044e \u043a\u043e\u0434\u0430 \u043f\u043e\u0440\u0442\u0430 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u043d\u044b\u0445 \u043f\u043e\u0434\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c, \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u044e\u0449\u0438\u0445 \u0441\u0442\u0430\u0440\u0442 \u0441\u0438\u0441\u0442\u0435\u043c\u044b, \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u0435\u043c\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430, \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0435\u0439 \u0441\u0442\u0435\u043a\u0430 \u0438 \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430, \u043f\u043e\u043b\u0443\u0447\u0438\u0432\u0448\u0435\u0433\u043e \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435, \u0432 \u0442\u043e\u043c \u0447\u0438\u0441\u043b\u0435 \u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u043e\u0433\u043e \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u044f, \u0432 \u0442\u0435\u043b\u0435 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0441\u044f \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432. \u0427\u0442\u043e\u0431\u044b \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u0442\u044c \u044d\u0442\u043e\u0442 \u043a\u043e\u0434, \u043e\u0442 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0430 \u043f\u043e\u0440\u0442\u0430 \u0442\u0440\u0435\u0431\u0443\u044e\u0442\u0441\u044f \u0433\u043b\u0443\u0431\u043e\u043a\u0438\u0435 \u0437\u043d\u0430\u043d\u0438\u044f \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u043e\u0439 \u0430\u0440\u0445\u0438\u0442\u0435\u043a\u0442\u0443\u0440\u044b \u043d\u0430 \u043d\u0438\u0437\u043a\u043e\u043c \u0443\u0440\u043e\u0432\u043d\u0435, \u0430 \u0442\u0430\u043a\u0436\u0435 \u0443\u043c\u0435\u043d\u0438\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u044b\u0439 \u043f\u0430\u043a\u0435\u0442 (\u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440, \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440, \u043b\u0438\u043d\u043a\u0435\u0440) \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441\u043e \"\u0441\u043c\u0435\u0448\u0430\u043d\u043d\u044b\u043c\u0438\" 3 \u043f\u0440\u043e\u0435\u043a\u0442\u0430\u043c\u0438. \u041f\u0440\u043e\u0446\u0435\u0441\u0441 \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0441\u0432\u043e\u0434\u0438\u0442\u0441\u044f, \u0433\u043b\u0430\u0432\u043d\u044b\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u043a \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044e \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0438 \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0438\u044e \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0433\u043e \u043a\u043e\u0434\u0430.","title":"\u041e\u0431\u0449\u0438\u0435 \u0437\u0430\u043c\u0435\u0447\u0430\u043d\u0438\u044f"},{"location":"src/ports/#_3","text":"","title":"\u041e\u0431\u044a\u0435\u043a\u0442\u044b \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f"},{"location":"src/ports/#_4","text":"\u0421\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u0440\u044f\u0434 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u044b\u0445 \u043c\u0430\u043a\u0440\u043e\u0441\u043e\u0432, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u044b. \u0415\u0441\u043b\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043c\u0430\u043a\u0440\u043e\u0441\u0430 \u0432 \u0442\u043e\u043c \u0438\u043b\u0438 \u0438\u043d\u043e\u043c \u043f\u043e\u0440\u0442\u0435 \u043d\u0435 \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f, \u0442\u043e \u043c\u0430\u043a\u0440\u043e\u0441 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0451\u043d \u043f\u0443\u0441\u0442\u044b\u043c. \u041f\u0435\u0440\u0435\u0447\u0435\u043d\u044c \u043c\u0430\u043a\u0440\u043e\u0441\u043e\u0432 \u0438 \u0438\u0445 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u044f \u043f\u0440\u0438\u0432\u0435\u0434\u0435\u043d\u044b \u043d\u0438\u0436\u0435. INLINE \u0417\u0430\u0434\u0430\u0451\u0442 \u043f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u043f\u0440\u0438 \u0432\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u043d\u0438\u0438. \u041e\u0431\u044b\u0447\u043d\u043e \u0441\u043e\u0441\u0442\u043e\u0438\u0442 \u0438\u0437 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0439 \u0434\u0438\u0440\u0435\u043a\u0442\u0438\u0432\u044b \u0431\u0435\u0437\u0443\u0441\u043b\u043e\u0432\u043d\u043e\u0433\u043e \u0432\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u043d\u0438\u044f \u0438 \u043a\u043b\u044e\u0447\u0435\u0432\u043e\u0433\u043e \u0441\u043b\u043e\u0432\u0430 inline . OS_PROCESS \u041a\u0432\u0430\u043b\u0438\u0444\u0438\u0446\u0438\u0440\u0443\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u043d\u044f\u0435\u043c\u0443\u044e \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430. \u0421\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u044b\u0439 \u0430\u0442\u0440\u0438\u0431\u0443\u0442, \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0449\u0438\u0439 \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440\u0443, \u0447\u0442\u043e \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043d\u0435 \u0438\u043c\u0435\u0435\u0442 \u0432\u043e\u0437\u0432\u0440\u0430\u0442\u0430, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 preserved 4 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u044b \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430 \u043c\u043e\u0436\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0431\u0435\u0437 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f. \u042d\u0442\u043e \u044d\u043a\u043e\u043d\u043e\u043c\u0438\u0442 \u043a\u043e\u0434 \u0438 \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u043e \u0432 \u0441\u0442\u0435\u043a\u0435. OS_INTERRUPT \u0421\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0435 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u0435, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0435 \u0434\u043b\u044f \u043a\u0432\u0430\u043b\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u0432 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439 \u043d\u0430 \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435. DUMMY_INSTR () \u041c\u0430\u043a\u0440\u043e\u0441, \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u044e\u0449\u0438\u0439 \u043f\u0443\u0441\u0442\u0443\u044e \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044e \u0446\u0435\u043b\u0435\u0432\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430 (\u043a\u0430\u043a \u043f\u0440\u0430\u0432\u0438\u043b\u043e, \u044d\u0442\u043e \u0438\u043d\u0441\u0442\u0440\u0443\u043a\u0446\u0438\u044f NOP ). \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0432 \u0446\u0438\u043a\u043b\u0435 \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u0432 \u043f\u043b\u0430\u043d\u0438\u0440\u043e\u0432\u0449\u0438\u043a\u0435 (\u0432 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u0435 \u0441 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u044b\u043c \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0435\u043c \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432). INLINE_PROCESS_CTOR \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442 \u043f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u0432\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u043d\u0438\u044f \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u043e\u0432 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432. \u0415\u0441\u043b\u0438 \u043d\u0443\u0436\u043d\u043e \u0432\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u043d\u0438\u0435, \u0442\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u044d\u0442\u043e\u0433\u043e \u043c\u0430\u043a\u0440\u043e\u0441\u0430 \u0434\u043e\u043b\u0436\u043d\u043e INLINE , \u0435\u0441\u043b\u0438 \u0432\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u043d\u0438\u0435 \u043d\u0435 \u043d\u0443\u0436\u043d\u043e, \u0442\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043c\u0430\u043a\u0440\u043e\u0441\u0430 \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c \u043e\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u043e \u043f\u0443\u0441\u0442\u044b\u043c. SYS_TIMER_CRIT_SECT () \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0432 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0435 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e \u0442\u0430\u0439\u043c\u0435\u0440\u0430 \u0438 \u0437\u0430\u0434\u0430\u0451\u0442, \u0431\u0443\u0434\u0435\u0442 \u043b\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u0432 \u043d\u0451\u043c \u043a\u0440\u0438\u0442\u0438\u0447\u0435\u0441\u043a\u0430\u044f \u0441\u0435\u043a\u0446\u0438\u044f, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0430\u043a\u0442\u0443\u0430\u043b\u044c\u043d\u0430 \u0432 \u0441\u043b\u0443\u0447\u0430\u0435, \u0435\u0441\u043b\u0438 \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440 \u0438\u043c\u0435\u0435\u0442 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u043d\u044b\u0439 \u043c\u043d\u043e\u0433\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u0439 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u043b\u0435\u0440 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439, \u0447\u0442\u043e \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u0432\u0435\u0441\u0442\u0438 \u043a \u0442\u043e\u043c\u0443, \u0447\u0442\u043e \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439 \u043e\u0442 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e \u0442\u0430\u0439\u043c\u0435\u0440\u0430 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u0440\u0435\u0440\u0432\u0430\u043d \u0432 \u043d\u0435\u043f\u0440\u0435\u0434\u0441\u043a\u0430\u0437\u0443\u0435\u043c\u044b\u0439 \u043c\u043e\u043c\u0435\u043d\u0442 \u0434\u0440\u0443\u0433\u0438\u043c, \u0431\u043e\u043b\u0435\u0435 \u0432\u044b\u0441\u043e\u043a\u043e\u0443\u0440\u043e\u0432\u043d\u0435\u0432\u044b\u043c, \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u043c \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u044c \u0434\u043e\u0441\u0442\u0443\u043f \u043a \u0442\u0435\u043c \u0436\u0435 \u0440\u0435\u0441\u0443\u0440\u0441\u0430\u043c \u041e\u0421, \u0447\u0442\u043e \u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439 \u043e\u0442 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e \u0442\u0430\u0439\u043c\u0435\u0440\u0430. CONTEXT_SWITCH_HOOK_CRIT_SECT \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442, \u0431\u0443\u0434\u0435\u0442 \u0445\u0443\u043a \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0430\u0442\u0435\u043b\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c\u0441\u044f \u0432 \u043a\u0440\u0438\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u0441\u0435\u043a\u0446\u0438\u0438 \u0438\u043b\u0438 \u043d\u0435\u0442. \u041e\u0447\u0435\u043d\u044c \u0432\u0430\u0436\u043d\u043e, \u0447\u0442\u043e\u0431\u044b \u0445\u0443\u043a \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0430\u0442\u0435\u043b\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u043b\u0441\u044f \u0446\u0435\u043b\u043e\u0441\u0442\u043d\u043e \u043f\u043e \u043e\u0442\u043d\u043e\u0448\u0435\u043d\u0438\u044e \u043a \u043c\u0430\u043d\u0438\u043f\u0443\u043b\u044f\u0446\u0438\u044f\u043c \u0441 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u043c\u0438 \u044f\u0434\u0440\u0430 ( SchedProcPriority , \u0432 \u0447\u0430\u0441\u0442\u043d\u043e\u0441\u0442\u0438), \u0430 \u044d\u0442\u043e \u043e\u0437\u043d\u0430\u0447\u0430\u0435\u0442, \u0447\u0442\u043e \u0432\u043e \u0432\u0440\u0435\u043c\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0445\u0443\u043a\u0430 \u043d\u0435 \u0434\u043e\u043b\u0436\u0435\u043d \u0432\u044b\u0437\u044b\u0432\u0430\u0442\u044c\u0441\u044f \u043f\u043b\u0430\u043d\u0438\u0440\u043e\u0432\u0449\u0438\u043a. \u0412\u044b\u0437\u043e\u0432 \u043f\u043b\u0430\u043d\u0438\u0440\u043e\u0432\u0449\u0438\u043a\u0430 \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u043e\u0438\u0437\u043e\u0439\u0442\u0438 \u0438\u0437 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0430 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439 \u0432 \u0441\u043b\u0443\u0447\u0430\u0435, \u0435\u0441\u043b\u0438 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440 \u0438\u043c\u0435\u0435\u0442 \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u044b\u0439 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u043d\u044b\u0439 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u043b\u0435\u0440 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439 \u0438 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u043e\u0435 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u0438\u043c\u0435\u0435\u0442 \u0431\u043e\u043b\u0435\u0435 \u043d\u0438\u0437\u043a\u0438\u0439 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442 \u043f\u043e \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044e \u0441 \u0434\u0440\u0443\u0433\u0438\u043c\u0438 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u044f\u043c\u0438. \u0412 \u044d\u0442\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u043a\u043e\u0434 \u0445\u0443\u043a\u0430 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0430\u0442\u0435\u043b\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u0434\u043e\u043b\u0436\u0435\u043d \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0442\u044c\u0441\u044f \u0432 \u043a\u0440\u0438\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u0441\u0435\u043a\u0446\u0438\u0438 \u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043c\u0430\u043a\u0440\u043e\u0441\u0430 \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c TCritSect cs . \u042d\u0442\u043e \u043e\u0447\u0435\u043d\u044c \u0432\u0430\u0436\u043d\u044b\u0439 \u043c\u043e\u043c\u0435\u043d\u0442, \u0435\u0441\u043b\u0438 \u0435\u0433\u043e \u043d\u0435 \u0441\u043e\u0431\u043b\u044e\u0441\u0442\u0438, \u0442\u043e \u0432 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0440\u0430\u0431\u043e\u0442\u044b \u0441\u0438\u0441\u0442\u0435\u043c\u044b \u0431\u0443\u0434\u0443\u0442 \u0432\u043e\u0437\u043d\u0438\u043a\u0430\u0442\u044c \u0442\u0440\u0443\u0434\u043d\u043e\u0443\u043b\u043e\u0432\u0438\u043c\u044b\u0435 \u043e\u0448\u0438\u0431\u043a\u0438, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u043f\u0440\u0438 \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0438 \u0442\u0443\u0442 \u043d\u0443\u0436\u043d\u043e \u043f\u0440\u043e\u044f\u0432\u0438\u0442\u044c \u0432\u043d\u0438\u043c\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u0438 \u0430\u043a\u043a\u0443\u0440\u0430\u0442\u043d\u043e\u0441\u0442\u044c. SEPARATE_RETURN_STACK \u0414\u043b\u044f \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c, \u0438\u043c\u0435\u044e\u0449\u0438\u0445 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u0441\u0442\u0435\u043a \u0432\u043e\u0437\u0432\u0440\u0430\u0442\u043e\u0432, \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u044d\u0442\u043e\u0433\u043e \u043c\u0430\u043a\u0440\u043e\u0441\u0430 \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c \u0440\u0430\u0432\u043d\u043e 1. \u0414\u043b\u044f \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0445 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c \u2013 0.","title":"\u041c\u0430\u043a\u0440\u043e\u0441\u044b"},{"location":"src/ports/#_5","text":"stack_item_t \u041f\u0441\u0435\u0432\u0434\u043e\u043d\u0438\u043c \u0432\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u043e\u0433\u043e \u0442\u0438\u043f\u0430, \u0437\u0430\u0434\u0430\u0451\u0442 \u0442\u0438\u043f \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u0441\u0442\u0435\u043a\u0430 \u0446\u0435\u043b\u0435\u0432\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430. status_reg_t \u041f\u0441\u0435\u0432\u0434\u043e\u043d\u0438\u043c \u0432\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u043e\u0433\u043e \u0442\u0438\u043f\u0430, \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0439 \u0440\u0430\u0437\u0440\u044f\u0434\u043d\u043e\u0441\u0442\u0438 \u0441\u0442\u0430\u0442\u0443\u0441\u043d\u043e\u0433\u043e \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430 \u0446\u0435\u043b\u0435\u0432\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430. TCritSect \u041a\u043b\u0430\u0441\u0441-\"\u043e\u0431\u0451\u0440\u0442\u043a\u0430\" \u0434\u043b\u044f \u043e\u0440\u0433\u0430\u043d\u0438\u0437\u0430\u0446\u0438\u0438 \u043a\u0440\u0438\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u0441\u0435\u043a\u0446\u0438\u0438. TPrioMaskTable \u041a\u043b\u0430\u0441\u0441, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u0442\u0430\u0431\u043b\u0438\u0446\u0443 \u043c\u0430\u0441\u043e\u043a (\u0442\u0435\u0433\u043e\u0432) \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u043e\u0432. \u0421\u043b\u0443\u0436\u0438\u0442 \u0434\u043b\u044f \u043f\u043e\u0432\u044b\u0448\u0435\u043d\u0438\u044f \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0438 \u0440\u0430\u0431\u043e\u0442\u044b \u0441\u0438\u0441\u0442\u0435\u043c\u044b. \u041c\u043e\u0436\u0435\u0442 \u043e\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c \u043d\u0430 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0430\u0445, \u043d\u0430 \u0442\u0430\u043a\u0438\u0445, \u0433\u0434\u0435 \u0435\u0441\u0442\u044c \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u044b\u0435 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u0434\u043b\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f \u0442\u0435\u0433\u043e\u0432 \u043f\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u0430, \u2013 \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u044b\u0439 shifter. TISRW \u041a\u043b\u0430\u0441\u0441-\"\u043e\u0431\u0451\u0440\u0442\u043a\u0430\" \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u043e\u0432 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439, \u0432 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0441\u0435\u0440\u0432\u0438\u0441\u044b \u041e\u0421.","title":"\u0422\u0438\u043f\u044b"},{"location":"src/ports/#_6","text":"get_prio_tag () \u041f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u0443\u0435\u0442 \u043d\u043e\u043c\u0435\u0440 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u0430 \u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0439 \u0442\u0435\u0433. \u0424\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e \u044d\u0442\u043e \u0441\u0434\u0432\u0438\u0433 \u0435\u0434\u0438\u043d\u0438\u0446\u044b \u0432 \u0434\u0432\u043e\u0438\u0447\u043d\u043e\u043c \u0441\u043b\u043e\u0432\u0435 \u043d\u0430 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u0437\u0438\u0446\u0438\u0439, \u0440\u0430\u0432\u043d\u043e\u0435 \u043d\u043e\u043c\u0435\u0440\u0443 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u0430. highest_priority () \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043d\u043e\u043c\u0435\u0440 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u0430, \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0433\u043e \u0442\u0435\u0433\u0443 \u043d\u0430\u0438\u0431\u043e\u043b\u0435\u0435 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430 \u0432 \u043a\u0430\u0440\u0442\u0435 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432, \u043f\u0435\u0440\u0435\u0434\u0430\u043d\u043d\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430. disable_context_switch () \u0417\u0430\u043f\u0440\u0435\u0449\u0430\u0435\u0442 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432. \u0412 \u043d\u0430\u0441\u0442\u043e\u044f\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0435\u0442\u0441\u044f \u043f\u0443\u0442\u0451\u043c \u0437\u0430\u043f\u0440\u0435\u0449\u0435\u043d\u0438\u044f \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439. enable_context_switch () \u0420\u0430\u0437\u0440\u0435\u0448\u0430\u0435\u0442 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432. \u0412 \u043d\u0430\u0441\u0442\u043e\u044f\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0435\u0442\u0441\u044f \u0447\u0435\u0440\u0435\u0437 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u0438\u0435 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439. os_start () \u041f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442 \u0441\u0442\u0430\u0440\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u043e\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u044b. \u0421\u0430\u043c\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u0430 \u043d\u0430 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u0435. \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u0441\u0442\u0435\u043a\u0430 \u0441\u0430\u043c\u043e\u0433\u043e \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430 \u0438 \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u0435\u0442 \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0443 \u0435\u043c\u0443 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u0443\u0442\u0451\u043c \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430 \u0438\u0437 \u0435\u0433\u043e \u0441\u0442\u0435\u043a\u0430. os_context_switcher () \u0424\u0443\u043d\u043a\u0446\u0438\u044f, \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u0430\u044f \u043d\u0430 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u0435, \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432 \u0432 \u0432\u0430\u0440\u0438\u0430\u043d\u0442\u0435 \u0441 \u043f\u0440\u044f\u043c\u043e\u0439 \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0435\u0439 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f. context_switcher_isr () \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432. \u0420\u0435\u0430\u043b\u0438\u0437\u0443\u0435\u0442\u0441\u044f \u043d\u0430 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u0435. \u041f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u0435\u043c\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430, \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0435\u0439 \u0441\u0442\u0435\u043a\u043e\u0432 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432 \u043f\u0443\u0442\u0451\u043c \u0432\u044b\u0437\u043e\u0432\u0430 context_switch_hook() 5 \u0438 \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430 \u0430\u043a\u0442\u0438\u0432\u0438\u0440\u0443\u0435\u043c\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430. TBaseProcess :: init_stack_frame () \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0438 \u0441\u0442\u0435\u043a\u043e\u0432\u043e\u0433\u043e \u043a\u0430\u0434\u0440\u0430, \u043a\u043e\u0442\u043e\u0440\u0430\u044f \u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u044f\u0447\u0435\u0435\u043a \u043f\u0430\u043c\u044f\u0442\u0438 \u0432 \u0441\u0442\u0435\u043a\u0435 \u0442\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, \u0447\u0442\u043e\u0431\u044b \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0441\u0442\u0435\u043a\u0430 \u0431\u044b\u043b\u043e \u0442\u0430\u043a\u0438\u043c, \u043a\u0430\u043a \u0431\u0443\u0434\u0442\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441, \u043a\u043e\u0442\u043e\u0440\u043e\u043c\u0443 \u043f\u0440\u0438\u043d\u0430\u0434\u043b\u0435\u0436\u0438\u0442 \u0441\u0442\u0435\u043a, \u043f\u0440\u0435\u0440\u0432\u0430\u043d \u0438 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430 \u0441\u043e\u0445\u0440\u0430\u043d\u0451\u043d \u0432 \u0441\u0442\u0435\u043a\u0435. \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u043e\u043c \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430 \u0438 \u043f\u0440\u0438 \u0440\u0435\u0441\u0442\u0430\u0440\u0442\u0435 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430. system_timer_isr () \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e \u0442\u0430\u0439\u043c\u0435\u0440\u0430. \u0412\u044b\u0437\u044b\u0432\u0430\u0435\u0442 \u0444\u0443\u043d\u043a\u0446\u0438\u044e TKernel::system_timer() .","title":"\u0424\u0443\u043d\u043a\u0446\u0438\u0438"},{"location":"src/ports/#_7","text":"\u0414\u043b\u044f \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f, \u043a\u0430\u043a \u043f\u0440\u0430\u0432\u0438\u043b\u043e, \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c \u0434\u043b\u044f \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u044b \u0432\u0441\u0435 \u0432\u044b\u0448\u0435\u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u0435 \u043c\u0430\u043a\u0440\u043e\u0441\u044b, \u0442\u0438\u043f\u044b \u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438. \u041d\u0430\u0438\u0431\u043e\u043b\u0435\u0435 \"\u0442\u043e\u043d\u043a\u0430\u044f\" \u0438 \u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u043f\u0440\u0438 \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0438 \u0432\u044b\u043f\u0430\u0434\u0430\u0435\u0442 \u043d\u0430 \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044e \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u043d\u043e\u0433\u043e \u043a\u043e\u0434\u0430 \u0438 \u043d\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u043f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0438 \u0441\u0442\u0435\u043a\u043e\u0432\u043e\u0433\u043e \u043a\u0430\u0434\u0440\u0430. \u0420\u044f\u0434 \u043c\u043e\u043c\u0435\u043d\u0442\u043e\u0432, \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0441\u043b\u0435\u0434\u0443\u0435\u0442 \u043e\u0431\u0440\u0430\u0442\u0438\u0442\u044c \u043e\u0441\u043e\u0431\u043e\u0435 \u0432\u043d\u0438\u043c\u0430\u043d\u0438\u0435: \u0432\u044b\u044f\u0441\u043d\u0438\u0442\u044c, \u043a\u0430\u043a\u0438\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0441\u043e\u0433\u043b\u0430\u0448\u0435\u043d\u0438\u044f \u043e \u0432\u044b\u0437\u043e\u0432\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u0443 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0433\u043e \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440\u0430, \u0447\u0442\u043e\u0431\u044b \u0437\u043d\u0430\u0442\u044c, \u043a\u0430\u043a\u0438\u0435 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u044b (\u0438\u043b\u0438 \u043e\u0431\u043b\u0430\u0441\u0442\u044c \u0441\u0442\u0435\u043a\u0430) \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442\u0441\u044f \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0438 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432 \u0442\u0435\u0445 \u0438\u043b\u0438 \u0438\u043d\u044b\u0445 \u0442\u0438\u043f\u043e\u0432; \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c \u043e\u0441\u043e\u0431\u0435\u043d\u043d\u043e\u0441\u0442\u0438 \u0440\u0430\u0431\u043e\u0442\u044b \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430 \u0432 \u0447\u0430\u0441\u0442\u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0430\u0434\u0440\u0435\u0441\u043e\u0432 \u0432\u043e\u0437\u0432\u0440\u0430\u0442\u043e\u0432 \u0438 \u0441\u0442\u0430\u0442\u0443\u0441\u043d\u044b\u0445 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u043e\u0432 \u043f\u0440\u0438 \u0432\u043e\u0437\u043d\u0438\u043a\u043d\u043e\u0432\u0435\u043d\u0438\u0438 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u044f \u2013 \u044d\u0442\u043e \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0434\u043b\u044f \u043f\u043e\u043d\u0438\u043c\u0430\u043d\u0438\u044f, \u043a\u0430\u043a \u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u0442\u0441\u044f \u0441\u0442\u0435\u043a\u043e\u0432\u044b\u0439 \u043a\u0430\u0434\u0440 \u043d\u0430 \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u043e\u0439 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435, \u0447\u0442\u043e, \u0432 \u0441\u0432\u043e\u044e \u043e\u0447\u0435\u0440\u0435\u0434\u044c, \u0432\u0430\u0436\u043d\u043e \u0434\u043b\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 (\u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a\u0430 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0439) \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432, \u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0441\u0442\u0435\u043a\u043e\u0432\u043e\u0433\u043e \u043a\u0430\u0434\u0440\u0430; \u043f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c \u0441\u0445\u0435\u043c\u0443 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u044d\u043a\u0441\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c\u044b\u0445/\u0438\u043c\u043f\u043e\u0440\u0442\u0438\u0440\u0443\u0435\u043c\u044b\u0445 \u0438\u043c\u0451\u043d \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u0430. \u0412 \u043f\u0440\u043e\u0441\u0442\u0435\u0439\u0448\u0435\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u0438\u043c\u0435\u043d\u0430 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u043d\u0430 \u0421 (\u0438 \"extern C\" 6 \u043d\u0430 \u0421++) \u043d\u0430 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u0435 \u0432\u0438\u0434\u043d\u044b \u0431\u0435\u0437 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0439, \u043d\u043e \u043d\u0430 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0430\u0445 7 \u043a \u0441\u0430\u043c\u043e\u043c\u0443 \u0438\u043c\u0435\u043d\u0438 \u043c\u043e\u0433\u0443\u0442 \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c\u0441\u044f \u043f\u0440\u0435\u0444\u0438\u043a\u0441\u044b \u0438/\u0438\u043b\u0438 \u0441\u0443\u0444\u0444\u0438\u043a\u0441\u044b, \u0447\u0442\u043e \u043f\u043e\u0442\u0440\u0435\u0431\u0443\u0435\u0442 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u043d\u044b\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0438\u043c\u0435\u043d\u043e\u0432\u0430\u0442\u044c \u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438 \u0441 \u044d\u0442\u043e\u0439 \u0441\u0445\u0435\u043c\u043e\u0439, \u0438\u043d\u0430\u0447\u0435 \u043b\u0438\u043d\u043a\u0435\u0440 \u043d\u0435 \u0441\u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0441\u0432\u044f\u0437\u0438. \u0412\u0435\u0441\u044c \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u043d\u044b\u0439 \u043a\u043e\u0434 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u043f\u043e\u043c\u0435\u0449\u0451\u043d \u0432 \u0444\u0430\u0439\u043b os_target_asm.ext, \u0443\u043f\u043e\u043c\u044f\u043d\u0443\u0442\u044b\u0439 \u0432\u044b\u0448\u0435. \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u043c\u0430\u043a\u0440\u043e\u0441\u043e\u0432 \u0438 \u0442\u0438\u043f\u043e\u0432, \u0430 \u0442\u0430\u043a\u0436\u0435 \u0432\u0441\u0442\u0440\u0430\u0438\u0432\u0430\u0435\u043c\u044b\u0445 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u2013 \u0432 \u0444\u0430\u0439\u043b os_target.h. \u0412 \u0444\u0430\u0439\u043b\u0435 os_target.cpp \u043e\u0431\u044a\u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u044b \u0442\u0438\u043f\u043e\u0432, \u0435\u0441\u043b\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e, \u2013 \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, OS::TPrioMaskTable OS::PrioMaskTable , \u0430 \u0442\u0430\u043a\u0436\u0435 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u044e\u0442\u0441\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f TBaseProcess::init_stack_frame() \u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u044f \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e \u0442\u0430\u0439\u043c\u0435\u0440\u0430 system_timer_isr() . \u0412\u044b\u0448\u0435\u043e\u043f\u0438\u0441\u0430\u043d\u043d\u043e\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438\u0448\u044c \u043e\u0431\u0449\u0438\u043c\u0438 \u0441\u0432\u0435\u0434\u0435\u043d\u0438\u044f\u043c\u0438, \u043e\u0442\u043d\u043e\u0441\u044f\u0449\u0438\u043c\u0438\u0441\u044f \u043a \u043f\u043e\u0440\u0442\u0443 \u041e\u0421, \u043f\u0440\u0438 \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0438 \u0432\u043e\u0437\u043d\u0438\u043a\u0430\u0435\u0442 \u0434\u043e\u0441\u0442\u0430\u0442\u043e\u0447\u043d\u043e \u043c\u043d\u043e\u0433\u043e \u043d\u044e\u0430\u043d\u0441\u043e\u0432, \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0432\u0435\u0441\u044c\u043c\u0430 \u0447\u0430\u0441\u0442\u043d\u044b\u043c \u0438 \u0432\u044b\u0445\u043e\u0434\u0438\u0442 \u0437\u0430 \u0440\u0430\u043c\u043a\u0438 \u043d\u0430\u0441\u0442\u043e\u044f\u0449\u0435\u0433\u043e \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430. \u0421\u041e\u0412\u0415\u0422 \u041f\u0440\u0438 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0438 \u043d\u043e\u0432\u043e\u0433\u043e \u043f\u043e\u0440\u0442\u0430 \u0438\u043c\u0435\u0435\u0442 \u0441\u043c\u044b\u0441\u043b \u0432\u0437\u044f\u0442\u044c \u0437\u0430 \u043e\u0441\u043d\u043e\u0432\u0443 \u0438\u043b\u0438 \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u043f\u0440\u0438\u043c\u0435\u0440\u0430 \u043e\u0434\u0438\u043d \u0438\u0437 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0438\u0445 \u2013 \u044d\u0442\u043e \u0437\u043d\u0430\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u043e\u0431\u043b\u0435\u0433\u0447\u0430\u0435\u0442 \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f. \u041a\u0430\u043a\u043e\u0439 \u0438\u043c\u0435\u043d\u043d\u043e \u0432\u044b\u0431\u0440\u0430\u0442\u044c \u0438\u0437 \u0438\u043c\u0435\u044e\u0449\u0438\u0445\u0441\u044f \u043f\u043e\u0440\u0442\u043e\u0432, \u0437\u0430\u0432\u0438\u0441\u0438\u0442 \u043e\u0442 \u0431\u043b\u0438\u0437\u043e\u0441\u0442\u0438 \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u043e\u0439 \u0438 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u043e\u0439 \u0447\u0430\u0441\u0442\u0435\u0439 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u044b, \u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043e\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435.","title":"\u041f\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435"},{"location":"src/ports/#_8","text":"\u0414\u043b\u044f \u043f\u043e\u0432\u044b\u0448\u0435\u043d\u0438\u044f \u0433\u0438\u0431\u043a\u043e\u0441\u0442\u0438 \u0438 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0447\u0430\u0441\u0442\u044c \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u043e\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0433\u043e \u043a\u043e\u0434\u0430, \u0437\u0430\u0432\u0438\u0441\u044f\u0449\u0430\u044f \u043e\u0442 \u0447\u0430\u0441\u0442\u043d\u044b\u0445 \u043e\u0441\u043e\u0431\u0435\u043d\u043d\u043e\u0441\u0442\u0435\u0439 \u0442\u043e\u0433\u043e \u0438\u043b\u0438 \u0438\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0435\u043a\u0442\u0430 \u0438 \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u043e \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0433\u043e \u043c\u0438\u043a\u0440\u043e\u043a\u043e\u043d\u0442\u0440\u043e\u043b\u043b\u0435\u0440\u0430, \u0432\u044b\u043d\u0435\u0441\u0435\u043d\u0430 \u043d\u0430 \u0443\u0440\u043e\u0432\u0435\u043d\u044c \u043f\u0440\u043e\u0435\u043a\u0442\u0430. \u0421\u044e\u0434\u0430, \u043a\u0430\u043a \u043f\u0440\u0430\u0432\u0438\u043b\u043e, \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0441\u044f \u0432\u044b\u0431\u043e\u0440 \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u043e\u0433\u043e \u0442\u0430\u0439\u043c\u0435\u0440\u0430 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0433\u043e \u0432 \u043a\u0430\u0447\u0435\u0441\u0442\u0432\u0435 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e, \u0430 \u0442\u0430\u043a\u0436\u0435 \u0432\u044b\u0431\u043e\u0440 \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u044f \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432, \u0435\u0441\u043b\u0438 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440 \u043d\u0435 \u0438\u043c\u0435\u0435\u0442 \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u043d\u043e\u0433\u043e \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u044f. \u0414\u043b\u044f \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043f\u043e\u0440\u0442\u0430 \u043f\u0440\u043e\u0435\u043a\u0442 \u0434\u043e\u043b\u0436\u0435\u043d \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0442\u044c \u0444\u0430\u0439\u043b\u044b: scmRTOS_config.h; scmRTOS_target_cfg.h; scmRTOS_config.h \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u0431\u043e\u043b\u044c\u0448\u0438\u043d\u0441\u0442\u0432\u043e \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0445 \u043c\u0430\u043a\u0440\u043e\u0441\u043e\u0432, \u0437\u0430\u0434\u0430\u044e\u0449\u0438\u0445 \u0442\u0430\u043a\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b, \u043a\u0430\u043a \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432 \u0432 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0435, \u0441\u043f\u043e\u0441\u043e\u0431 \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0438 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f, \u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u043e\u0433\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u0438\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0445 \u0445\u0443\u043a\u043e\u0432, \u043f\u043e\u0440\u044f\u0434\u043e\u043a \u043d\u0443\u043c\u0435\u0440\u0430\u0446\u0438\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043f\u0440\u0438\u043e\u0440\u0438\u0442\u0435\u0442\u043e\u0432 \u0438 \u0442.\u0434. \u0412 scmRTOS_target_cfg.h \u0440\u0430\u0437\u043c\u0435\u0449\u0451\u043d \u043a\u043e\u0434 \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0440\u0435\u0441\u0443\u0440\u0441\u0430\u043c\u0438 \u0446\u0435\u043b\u0435\u0432\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430, \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u043c\u0438 \u0434\u043b\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u044b\u0445 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u2013 \u0432\u0441\u0451 \u0442\u043e\u0442 \u0436\u0435 \u0441\u0438\u0441\u0442\u0435\u043c\u043d\u044b\u0439 \u0442\u0430\u0439\u043c\u0435\u0440, \u043f\u0440\u0435\u0440\u044b\u0432\u0430\u043d\u0438\u0435 \u043f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043e\u0432. \u0421\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0435 \u043e\u0431\u043e\u0438\u0445 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0445 \u0444\u0430\u0439\u043b\u043e\u0432 \u043f\u043e\u0434\u0440\u043e\u0431\u043d\u043e \u043e\u043f\u0438\u0441\u0430\u043d\u043e \u0432 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0445, \u043f\u043e\u0441\u0432\u044f\u0449\u0451\u043d\u043d\u044b\u0445 \u043a\u043e\u043d\u043a\u0440\u0435\u0442\u043d\u044b\u043c \u043f\u043e\u0440\u0442\u0430\u043c. \u042d\u0442\u043e \u043a\u0430\u0441\u0430\u0435\u0442\u0441\u044f \u043d\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u041e\u0421, \u043d\u043e \u0438 \u0434\u0440\u0443\u0433\u0438\u0445 \u043a\u0440\u043e\u0441\u0441\u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435\u043d\u043d\u044b\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c. \u21a9 \u0420\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u0435 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u043d\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430 \u0434\u043b\u044f \u0446\u0435\u043b\u0435\u0432\u043e\u0433\u043e \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0440\u0430. \u21a9 \u0422.\u0435. \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u043c\u0438 \u0438\u0441\u0445\u043e\u0434\u043d\u044b\u0435 \u0444\u0430\u0439\u043b\u044b \u043d\u0430 \u0440\u0430\u0437\u043d\u044b\u0445 \u044f\u0437\u044b\u043a\u0430\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u2013 \u0432 \u043d\u0430\u0448\u0435\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u0421++ \u0438 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440 \u0446\u0435\u043b\u0435\u0432\u043e\u0439 \u0430\u043f\u043f\u0430\u0440\u0430\u0442\u043d\u043e\u0439 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u044b. \u21a9 \u0422\u0435, \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u043f\u0435\u0440\u0435\u0434 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435\u043c \u0434\u043e\u043b\u0436\u043d\u043e \u0431\u044b\u0442\u044c \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u043e, \u0430 \u043f\u043e\u0441\u043b\u0435 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432\u043e\u0441\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043e, \u0447\u0442\u043e\u0431\u044b \u0432\u044b\u0437\u044b\u0432\u0430\u044e\u0449\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043d\u0435 \u043f\u043e\u043b\u0443\u0447\u0438\u043b\u0430 \u0438\u0441\u043a\u0430\u0436\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430 \u043f\u0440\u0438 \u0432\u044b\u0437\u043e\u0432\u0435 \u0434\u0440\u0443\u0433\u043e\u0439 \u0444\u0443\u043d\u043a\u0446\u0438\u0438. \u21a9 \u0427\u0435\u0440\u0435\u0437 \u0444\u0443\u043d\u043a\u0446\u0438\u044e-\"\u043e\u0431\u0451\u0440\u0442\u043a\u0443\"\" os_context_switch_hook() , \u0438\u043c\u0435\u044e\u0449\u0443\u044e \u0441\u043f\u0435\u0446\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044e \u0441\u0432\u044f\u0437\u044b\u0432\u0430\u043d\u0438\u044f \"extern C\" . \u21a9 \u0418\u043c\u0435\u043d\u0430 \u0432 \u0421++ \u043f\u043e\u0434\u0432\u0435\u0440\u0433\u0430\u044e\u0442\u0441\u044f \u0441\u043f\u0435\u0446\u0438\u0430\u043b\u044c\u043d\u043e\u043c\u0443 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044e \u0432 \u0446\u0435\u043b\u044f\u0445 \u043f\u043e\u0434\u0434\u0435\u0440\u0436\u043a\u0438 \u043f\u0435\u0440\u0435\u0433\u0440\u0443\u0437\u043a\u0438 \u0438\u043c\u0451\u043d \u0444\u0443\u043d\u043a\u0446\u0438\u0439, \u0430 \u0442\u0430\u043a\u0436\u0435 \u0434\u043b\u044f \u0442\u0438\u043f\u043e\u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u043e\u0433\u043e \u0441\u0432\u044f\u0437\u044b\u0432\u0430\u043d\u0438\u044f, \u043f\u043e \u043a\u0430\u043a\u043e\u0439 \u043f\u0440\u0438\u0447\u0438\u043d\u0435 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u043a \u043d\u0438\u043c \u0434\u043e\u0441\u0442\u0443\u043f \u043d\u0430 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u0435 \u0437\u0430\u0434\u0430\u0447\u0430 \u0442\u0440\u0443\u0434\u043d\u043e\u0432\u044b\u043f\u043e\u043b\u043d\u0438\u043c\u0430\u044f. \u041f\u043e\u044d\u0442\u043e\u043c\u0443 \u0438\u043c\u0435\u043d\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0439, \u043e\u043f\u0438\u0441\u0430\u043d\u043d\u044b\u0445 \u0432 \u0444\u0430\u0439\u043b\u0430\u0445, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043a\u043e\u043c\u043f\u0438\u043b\u0438\u0440\u0443\u044e\u0442\u0441\u044f \u0421++ \u043a\u043e\u043c\u043f\u0438\u043b\u044f\u0442\u043e\u0440\u043e\u043c \u0438 \u043a \u043a\u043e\u0442\u043e\u0440\u044b\u043c \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c \u0434\u043e\u0441\u0442\u0443\u043f \u0438\u0437 \u0430\u0441\u0441\u0435\u043c\u0431\u043b\u0435\u0440\u043d\u043e\u0433\u043e \u043a\u043e\u0434\u0430, \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u043e\u0431\u044a\u044f\u0432\u043b\u0435\u043d\u044b \u0432 \u0438\u0441\u0445\u043e\u0434\u043d\u044b\u0445 \u0444\u0430\u0439\u043b\u0430\u0445 \u043a\u0430\u043a \"extern C\" . \u21a9 \u0412 \u0447\u0430\u0441\u0442\u043d\u043e\u0441\u0442\u0438, \u043d\u0430 Blackfin. \u21a9","title":"\u0417\u0430\u043f\u0443\u0441\u043a \u0432 \u0441\u043e\u0441\u0442\u0430\u0432\u0435 \u0440\u0430\u0431\u043e\u0447\u0435\u0433\u043e \u043f\u0440\u043e\u0435\u043a\u0442\u0430"},{"location":"src/processes/","text":"Processes \ud83d\udd17 General Information and Representation \ud83d\udd17 The Process Internals \ud83d\udd17 A process in scmRTOS is an object of a type derived from the OS::TBaseProcess class. The reason why each process requires a separate type (instead of simply making all processes objects of type OS::TBaseProcess ) is that processes, despite all similarities, still differ \u2013they have different stack sizes and different priority values (which, it should be remembered, are set statically). Standard C++ templates are used to define process types. This allows for the creation of \"compact\" process types containing all the necessary internals, including the process stack itself, whose size is different for each process and is specified individually. 01 class TBaseProcess 02 { 03 friend class TKernel ; 04 friend class TISRW ; 05 friend class TISRW_SS ; 06 friend class TKernelAgent ; 07 08 friend void run (); 09 10 public : 11 TBaseProcess ( stack_item_t * StackPoolEnd 12 , TPriority pr 13 , void ( * exec )() 14 # if scmRTOS_DEBUG_ENABLE == 1 15 , stack_item_t * StackPool 16 # endif 17 ); 18 protected : 19 INLINE void set_unready () { Kernel . set_process_unready ( this -> Priority ); } 20 void init_stack_frame ( stack_item_t * StackPoolEnd 21 , void ( * exec )() 22 # if scmRTOS_DEBUG_ENABLE == 1 23 , stack_item_t * StackPool 24 # endif 25 ); 26 public : 27 static void sleep ( timeout_t timeout = 0 ); 28 void wake_up (); 29 void force_wake_up (); 30 INLINE void start () { force_wake_up (); } 31 INLINE bool is_sleeping () const ; 32 INLINE bool is_suspended () const ; 33 34 # if scmRTOS_DEBUG_ENABLE == 1 35 INLINE TService * waiting_for () { return WaitingFor ; } 36 public : 37 size_t stack_slack () const ; 38 # endif // scmRTOS_DEBUG_ENABLE 39 40 # if scmRTOS_PROCESS_RESTART_ENABLE == 1 41 protected : 42 void reset_controls (); 43 # endif 44 //----------------------------------------------------- 45 // 46 // Data members 47 // 48 protected : 49 stack_item_t * StackPointer ; 50 volatile timeout_t Timeout ; 51 const TPriority Priority ; 52 # if scmRTOS_DEBUG_ENABLE == 1 53 TService * volatile WaitingFor ; 54 const stack_item_t * const StackPool ; 55 # endif // scmRTOS_DEBUG_ENABLE 56 57 # if scmRTOS_PROCESS_RESTART_ENABLE == 1 58 volatile TProcessMap * WaitingProcessMap ; 59 # endif 60 61 # if scmRTOS_SUSPENDED_PROCESS_ENABLE != 0 62 static TProcessMap SuspendedProcessMap ; 63 # endif 64 }; Listing 1. TBaseProcess TBaseProcess \ud83d\udd17 The core functionality of a process is defined in the base class OS::TBaseProcess . As mentioned above, the actual processes are derived from it using the OS::process<> template. This method is used to avoid duplicating identical code in template instances 1 during their implementation. Therefore, the template itself declares only what pertains to entities that differ between processes\u2014stacks and the process execution function ( exec() ). The source code of the OS::TBaseProcess class is presented 2 \u2014see \"Listing 1. TBaseProcess\". Despite the seemingly extensive definition of this class, it is actually very small and simple. Its representation contains only three data members\u2014the stack pointer (49), the timeout tick counter (50), and the priority value (51). The remaining data members are auxiliary and are present only when additional functionality is enabled\u2014the ability to interrupt a process at any moment with subsequent restart, as well as debugging facilities 3 . The class interface provides the following functions: sleep(timeout_t timeout = 0) . Transitions the process to a \"sleep\" state: the argument value is assigned to the internal timeout counter variable, the process is removed from the map of ready processes, and the scheduler is called, which will transfer control to the next ready process. wake_up() . Wakes the process from the \"sleep\" state. The process is transitioned to the ready state only if it was in a timeout-based waiting state for an event; if this process has a priority higher than the current one, it immediately gains control. force_wake_up() . Wakes the process from the \"sleep\" state. The process is always transitioned to the ready state. If this process has a priority higher than the current one, it immediately gains control. This function must be used with extreme caution, as incorrect use can lead to improper (unpredictable) program behavior. is_sleeping() . Checks if the process is in a \"sleep\" state, i.e., in a timeout-based waiting state for an event. is_suspended() . Checks if the process is in an inactive state. Stack \ud83d\udd17 A process stack is a contiguous area of RAM used for storing the process data, as well as for saving the process context and return addresses from functions and interrupts. Due to the specifics of some architectures, two separate stacks may be used \u2014 one for data, another for return addresses. scmRTOS supports this capability, allowing for the placement of two RAM areas \u2014 two stacks \u2014 within each process object. The size of each can be specified individually based on the requirements of the application. Support for two stacks is enabled using the SEPARATE_RETURN_STACK macro defined in the os_target.h file. Inside the protected section, the very important function init_stack_frame() is declared. It is responsible for forming the stack frame. The fact is that the startup of process executable functions does not occur in the same way as for regular functions \u2014 process executable functions are not called in the traditional manner. Control is transferred to them in the same way as during context switching between processes. Therefore, starting a process's executable function occurs by restoring that process's context from the stack, followed by a jump to the address stored in the stack at the location of the saved process interrupt return address. To make such a startup possible, the process stack must be prepared accordingly \u2014 by initializing memory cells in the stack at specific addresses with the necessary values. In other words, the process stack's contents must be as if the process had been preempted earlier (with its context, of course, saved). The specific actions for preparing the stack frame are individual for each platform, hence the implementation of the init_stack_frame() function is placed at the operating system porting level. Timeouts \ud83d\udd17 Each process has a special variable Timeout for controlling the process behavior during event waits with timeouts or during \"sleep\". Essentially, this variable is a counter for system timer ticks. If its value is not zero, it is decremented and compared to zero within the system timer interrupt handler. Upon reaching zero, the process owning this variable is transitioned to the ready state. Thus, if a process is in a \"sleep\" state with a timeout (i.e., placed into the not-ready state by calling the sleep(timeout) function with a non-zero argument), then after an interval equal to the specified number of system timer ticks 4 , the process will be \"awoken\" 5 within the system timer interrupt handler. A similar situation occurs when calling a service function that involves waiting for an event with a timeout. In this case, the process will be transitioned to the ready state either upon the occurrence of the event it is waiting for (which triggered the service function call) or upon timeout expiration. The value returned by the service function unambiguously indicates the source of the process's \"awakening\", allowing the user program to easily decide on further actions in the given situation. Priorities \ud83d\udd17 Each process also has a data field containing the process priority. This field serves as the process identifier for manipulations with processes and their representations. In particular, the process priority is the index into the table of pointers to processes located within the kernel, where the address of each process is written during registration. Priorities are unique \u2014 there cannot be two processes with the same priority. The internal representation of a priority is an integer-type variable. For safety when assigning priorities, a special enumerated type TPriority is used. The sleep() Function \ud83d\udd17 This function serves to transition the current process from the active state to the inactive state. If the function is called with an argument equal to 0 (or without specifying an argument \u2014 the function is declared with a default argument equal to 0), the process will go into \"sleep\" until it is awakened, for example, by another process using the TBaseProcess::force_wake_up() function. If the function is called with an argument, the process will \"sleep\" for the specified number of system timer ticks, after which it will be \"awoken\", i.e., placed into the ready state. In this case, the \"sleep\" can also be interrupted by another process or an interrupt handler using the TBaseProcess::wake_up() or TBaseProcess::force_wake_up() functions. Process Creation and Usage \ud83d\udd17 Defining a Process Type \ud83d\udd17 To create a process, you need to define its type and declare an object of that type. The type of a specific process is described using the OS::process template: see \"Listing 2. Process Template\". 01 template < TPriority pr , size_t stack_size > 02 class process : public TBaseProcess 03 { 04 public : 05 INLINE_PROCESS_CTOR process (); 06 07 OS_PROCESS static void exec (); 08 09 # if scmRTOS_PROCESS_RESTART_ENABLE == 1 10 INLINE void terminate (); 11 # endif 12 13 private : 14 stack_item_t Stack [ stack_size / sizeof ( stack_item_t )]; 15 }; Listing 2. Process Template As you can see, two entities are added to what the base class provides: the process stack Stack with size stack_size . The size is specified in bytes; the static function exec() , which is the actual function containing the user code of the process. Declaring a Process Object and Its Usage \ud83d\udd17 Now it's enough to declare an object of this type, which will be the process itself, and to define the process function exec() . typedef OS :: process < OS :: prn , 100 > Slon ; Slon slon ; where n is the priority number. \"Listing 1. Process Executable Function\" illustrates an example of a typical process function. Using a process mainly consists of writing user code inside the process function. In doing so, as already mentioned, a few simple rules should be followed: You must ensure that the program's control flow does not leave the process function. Otherwise, due to the fact that this function was not called in the usual way, exiting from it will cause the control flow to go, roughly speaking, to undefined addresses, leading to undefined program behavior (although in practice, the behavior is usually quite definite \u2013 the program does not work!); Use the TBaseProcess::wake_up() function with caution and attention, and TBaseProcess::force_wake_up() \u2013 with extra caution, as careless use can lead to untimely \"awakening\" of a sleeping (suspended) process, which may cause collisions in inter-process communication. Starting a Process in an Inactive State \ud83d\udd17 Sometimes there is a need for the process executable function to start not immediately after system startup, but upon a specific signal. For example, there are several processes that should start their work only after initializing/configuring some (possibly external to the MCU) equipment; otherwise, unpleasant consequences may arise due to incorrect actions towards that equipment. In this situation, some dispatching will be required \u2013 the processes must somehow organize their work so as not to disrupt the logic of interaction with this equipment \u2013 for example, all processes except one (the dispatcher) start by waiting for an event (work start), which will be signaled to them by the dispatcher process. The dispatcher process performs all necessary preparatory work and then announces the start of work to the waiting processes. The described approach would require adding corresponding code manually in each process waiting for the start, which clutters the code, adds work, and is error-prone. Furthermore, there may be other situations where it is required that a process does not start its work immediately. To provide the described functionality, a process has the ability to start in a so-called inactive state. Such a process is no different from any other except that its tag is absent in the map of processes ready for execution ( ReadyProcessMap ). The declaration of such a process looks like this 6 : typedef OS :: process < OS :: pr1 , 300 , OS :: pssSuspended > Proc2 ; ... Proc2 proc2 ; Later, to start the work of this process, the launching code must call the force_wake_up() function: Proc2 . force_wake_up (); Process Restart \ud83d\udd17 A situation may arise when it is necessary to interrupt a process from the outside and start its execution from the beginning. For example, a process performs lengthy calculations, and it turns out that the results of these calculations are no longer needed at some point, and a new calculation cycle with new data must be started. This can be done by terminating the process with the possibility of subsequently restarting it from the beginning. To implement the above, the OS provides the user with two functions: OS::process::terminate() ; OS::TBaseProcess::start() . The terminate() function is intended to be called from outside the process being stopped. Inside it, all resources associated with this process are reset to their initial state, and the process is transitioned to the not-ready state. If the process was waiting for a service, its tag is removed from that service's map of waiting processes. Process startup is performed separately \u2013 so that the user has the opportunity to do it at a moment they deem appropriate \u2013 and is carried out using the start() function, which simply transitions the process to the ready state. The process will start working according to the sequence determined by its priority and the OS load. For the process interruption and restart to work correctly, this functionality must be enabled during configuration \u2013 the value of the scmRTOS_PROCESS_RESTART_ENABLE macro must be set to 1. The term \"instance\" is often used in jargon. \u21a9 Actually, there are two variants of this class\u2014the standard one (shown here) and one with a separate stack for return addresses. The latter is not included here for brevity, as it contains no fundamental differences relevant for understanding or exposition. \u21a9 The same applies to the rest of the code\u2014much of the class definition is occupied by the description of these auxiliary capabilities. \u21a9 Strictly speaking, not exactly equal to the number of system timer ticks, but with an accuracy up to a fraction of this period, which depends on the moment the sleep function is called relative to the moment the system timer interrupt occurs. \u21a9 I.e., transitioned to the ready state. \u21a9 The ss prefix in this example stands for Start State \u21a9","title":"Processes"},{"location":"src/processes/#processes","text":"","title":"Processes"},{"location":"src/processes/#general-information-and-representation","text":"","title":"General Information and Representation"},{"location":"src/processes/#the-process-internals","text":"A process in scmRTOS is an object of a type derived from the OS::TBaseProcess class. The reason why each process requires a separate type (instead of simply making all processes objects of type OS::TBaseProcess ) is that processes, despite all similarities, still differ \u2013they have different stack sizes and different priority values (which, it should be remembered, are set statically). Standard C++ templates are used to define process types. This allows for the creation of \"compact\" process types containing all the necessary internals, including the process stack itself, whose size is different for each process and is specified individually. 01 class TBaseProcess 02 { 03 friend class TKernel ; 04 friend class TISRW ; 05 friend class TISRW_SS ; 06 friend class TKernelAgent ; 07 08 friend void run (); 09 10 public : 11 TBaseProcess ( stack_item_t * StackPoolEnd 12 , TPriority pr 13 , void ( * exec )() 14 # if scmRTOS_DEBUG_ENABLE == 1 15 , stack_item_t * StackPool 16 # endif 17 ); 18 protected : 19 INLINE void set_unready () { Kernel . set_process_unready ( this -> Priority ); } 20 void init_stack_frame ( stack_item_t * StackPoolEnd 21 , void ( * exec )() 22 # if scmRTOS_DEBUG_ENABLE == 1 23 , stack_item_t * StackPool 24 # endif 25 ); 26 public : 27 static void sleep ( timeout_t timeout = 0 ); 28 void wake_up (); 29 void force_wake_up (); 30 INLINE void start () { force_wake_up (); } 31 INLINE bool is_sleeping () const ; 32 INLINE bool is_suspended () const ; 33 34 # if scmRTOS_DEBUG_ENABLE == 1 35 INLINE TService * waiting_for () { return WaitingFor ; } 36 public : 37 size_t stack_slack () const ; 38 # endif // scmRTOS_DEBUG_ENABLE 39 40 # if scmRTOS_PROCESS_RESTART_ENABLE == 1 41 protected : 42 void reset_controls (); 43 # endif 44 //----------------------------------------------------- 45 // 46 // Data members 47 // 48 protected : 49 stack_item_t * StackPointer ; 50 volatile timeout_t Timeout ; 51 const TPriority Priority ; 52 # if scmRTOS_DEBUG_ENABLE == 1 53 TService * volatile WaitingFor ; 54 const stack_item_t * const StackPool ; 55 # endif // scmRTOS_DEBUG_ENABLE 56 57 # if scmRTOS_PROCESS_RESTART_ENABLE == 1 58 volatile TProcessMap * WaitingProcessMap ; 59 # endif 60 61 # if scmRTOS_SUSPENDED_PROCESS_ENABLE != 0 62 static TProcessMap SuspendedProcessMap ; 63 # endif 64 }; Listing 1. TBaseProcess","title":"The Process Internals"},{"location":"src/processes/#tbaseprocess","text":"The core functionality of a process is defined in the base class OS::TBaseProcess . As mentioned above, the actual processes are derived from it using the OS::process<> template. This method is used to avoid duplicating identical code in template instances 1 during their implementation. Therefore, the template itself declares only what pertains to entities that differ between processes\u2014stacks and the process execution function ( exec() ). The source code of the OS::TBaseProcess class is presented 2 \u2014see \"Listing 1. TBaseProcess\". Despite the seemingly extensive definition of this class, it is actually very small and simple. Its representation contains only three data members\u2014the stack pointer (49), the timeout tick counter (50), and the priority value (51). The remaining data members are auxiliary and are present only when additional functionality is enabled\u2014the ability to interrupt a process at any moment with subsequent restart, as well as debugging facilities 3 . The class interface provides the following functions: sleep(timeout_t timeout = 0) . Transitions the process to a \"sleep\" state: the argument value is assigned to the internal timeout counter variable, the process is removed from the map of ready processes, and the scheduler is called, which will transfer control to the next ready process. wake_up() . Wakes the process from the \"sleep\" state. The process is transitioned to the ready state only if it was in a timeout-based waiting state for an event; if this process has a priority higher than the current one, it immediately gains control. force_wake_up() . Wakes the process from the \"sleep\" state. The process is always transitioned to the ready state. If this process has a priority higher than the current one, it immediately gains control. This function must be used with extreme caution, as incorrect use can lead to improper (unpredictable) program behavior. is_sleeping() . Checks if the process is in a \"sleep\" state, i.e., in a timeout-based waiting state for an event. is_suspended() . Checks if the process is in an inactive state.","title":"TBaseProcess"},{"location":"src/processes/#stack","text":"A process stack is a contiguous area of RAM used for storing the process data, as well as for saving the process context and return addresses from functions and interrupts. Due to the specifics of some architectures, two separate stacks may be used \u2014 one for data, another for return addresses. scmRTOS supports this capability, allowing for the placement of two RAM areas \u2014 two stacks \u2014 within each process object. The size of each can be specified individually based on the requirements of the application. Support for two stacks is enabled using the SEPARATE_RETURN_STACK macro defined in the os_target.h file. Inside the protected section, the very important function init_stack_frame() is declared. It is responsible for forming the stack frame. The fact is that the startup of process executable functions does not occur in the same way as for regular functions \u2014 process executable functions are not called in the traditional manner. Control is transferred to them in the same way as during context switching between processes. Therefore, starting a process's executable function occurs by restoring that process's context from the stack, followed by a jump to the address stored in the stack at the location of the saved process interrupt return address. To make such a startup possible, the process stack must be prepared accordingly \u2014 by initializing memory cells in the stack at specific addresses with the necessary values. In other words, the process stack's contents must be as if the process had been preempted earlier (with its context, of course, saved). The specific actions for preparing the stack frame are individual for each platform, hence the implementation of the init_stack_frame() function is placed at the operating system porting level.","title":"Stack"},{"location":"src/processes/#timeouts","text":"Each process has a special variable Timeout for controlling the process behavior during event waits with timeouts or during \"sleep\". Essentially, this variable is a counter for system timer ticks. If its value is not zero, it is decremented and compared to zero within the system timer interrupt handler. Upon reaching zero, the process owning this variable is transitioned to the ready state. Thus, if a process is in a \"sleep\" state with a timeout (i.e., placed into the not-ready state by calling the sleep(timeout) function with a non-zero argument), then after an interval equal to the specified number of system timer ticks 4 , the process will be \"awoken\" 5 within the system timer interrupt handler. A similar situation occurs when calling a service function that involves waiting for an event with a timeout. In this case, the process will be transitioned to the ready state either upon the occurrence of the event it is waiting for (which triggered the service function call) or upon timeout expiration. The value returned by the service function unambiguously indicates the source of the process's \"awakening\", allowing the user program to easily decide on further actions in the given situation.","title":"Timeouts"},{"location":"src/processes/#priorities","text":"Each process also has a data field containing the process priority. This field serves as the process identifier for manipulations with processes and their representations. In particular, the process priority is the index into the table of pointers to processes located within the kernel, where the address of each process is written during registration. Priorities are unique \u2014 there cannot be two processes with the same priority. The internal representation of a priority is an integer-type variable. For safety when assigning priorities, a special enumerated type TPriority is used.","title":"Priorities"},{"location":"src/processes/#the-sleep-function","text":"This function serves to transition the current process from the active state to the inactive state. If the function is called with an argument equal to 0 (or without specifying an argument \u2014 the function is declared with a default argument equal to 0), the process will go into \"sleep\" until it is awakened, for example, by another process using the TBaseProcess::force_wake_up() function. If the function is called with an argument, the process will \"sleep\" for the specified number of system timer ticks, after which it will be \"awoken\", i.e., placed into the ready state. In this case, the \"sleep\" can also be interrupted by another process or an interrupt handler using the TBaseProcess::wake_up() or TBaseProcess::force_wake_up() functions.","title":"The sleep() Function"},{"location":"src/processes/#process-creation-and-usage","text":"","title":"Process Creation and Usage"},{"location":"src/processes/#defining-a-process-type","text":"To create a process, you need to define its type and declare an object of that type. The type of a specific process is described using the OS::process template: see \"Listing 2. Process Template\". 01 template < TPriority pr , size_t stack_size > 02 class process : public TBaseProcess 03 { 04 public : 05 INLINE_PROCESS_CTOR process (); 06 07 OS_PROCESS static void exec (); 08 09 # if scmRTOS_PROCESS_RESTART_ENABLE == 1 10 INLINE void terminate (); 11 # endif 12 13 private : 14 stack_item_t Stack [ stack_size / sizeof ( stack_item_t )]; 15 }; Listing 2. Process Template As you can see, two entities are added to what the base class provides: the process stack Stack with size stack_size . The size is specified in bytes; the static function exec() , which is the actual function containing the user code of the process.","title":"Defining a Process Type"},{"location":"src/processes/#declaring-a-process-object-and-its-usage","text":"Now it's enough to declare an object of this type, which will be the process itself, and to define the process function exec() . typedef OS :: process < OS :: prn , 100 > Slon ; Slon slon ; where n is the priority number. \"Listing 1. Process Executable Function\" illustrates an example of a typical process function. Using a process mainly consists of writing user code inside the process function. In doing so, as already mentioned, a few simple rules should be followed: You must ensure that the program's control flow does not leave the process function. Otherwise, due to the fact that this function was not called in the usual way, exiting from it will cause the control flow to go, roughly speaking, to undefined addresses, leading to undefined program behavior (although in practice, the behavior is usually quite definite \u2013 the program does not work!); Use the TBaseProcess::wake_up() function with caution and attention, and TBaseProcess::force_wake_up() \u2013 with extra caution, as careless use can lead to untimely \"awakening\" of a sleeping (suspended) process, which may cause collisions in inter-process communication.","title":"Declaring a Process Object and Its Usage"},{"location":"src/processes/#starting-a-process-in-an-inactive-state","text":"Sometimes there is a need for the process executable function to start not immediately after system startup, but upon a specific signal. For example, there are several processes that should start their work only after initializing/configuring some (possibly external to the MCU) equipment; otherwise, unpleasant consequences may arise due to incorrect actions towards that equipment. In this situation, some dispatching will be required \u2013 the processes must somehow organize their work so as not to disrupt the logic of interaction with this equipment \u2013 for example, all processes except one (the dispatcher) start by waiting for an event (work start), which will be signaled to them by the dispatcher process. The dispatcher process performs all necessary preparatory work and then announces the start of work to the waiting processes. The described approach would require adding corresponding code manually in each process waiting for the start, which clutters the code, adds work, and is error-prone. Furthermore, there may be other situations where it is required that a process does not start its work immediately. To provide the described functionality, a process has the ability to start in a so-called inactive state. Such a process is no different from any other except that its tag is absent in the map of processes ready for execution ( ReadyProcessMap ). The declaration of such a process looks like this 6 : typedef OS :: process < OS :: pr1 , 300 , OS :: pssSuspended > Proc2 ; ... Proc2 proc2 ; Later, to start the work of this process, the launching code must call the force_wake_up() function: Proc2 . force_wake_up ();","title":"Starting a Process in an Inactive State"},{"location":"src/processes/#process-restart","text":"A situation may arise when it is necessary to interrupt a process from the outside and start its execution from the beginning. For example, a process performs lengthy calculations, and it turns out that the results of these calculations are no longer needed at some point, and a new calculation cycle with new data must be started. This can be done by terminating the process with the possibility of subsequently restarting it from the beginning. To implement the above, the OS provides the user with two functions: OS::process::terminate() ; OS::TBaseProcess::start() . The terminate() function is intended to be called from outside the process being stopped. Inside it, all resources associated with this process are reset to their initial state, and the process is transitioned to the not-ready state. If the process was waiting for a service, its tag is removed from that service's map of waiting processes. Process startup is performed separately \u2013 so that the user has the opportunity to do it at a moment they deem appropriate \u2013 and is carried out using the start() function, which simply transitions the process to the ready state. The process will start working according to the sequence determined by its priority and the OS load. For the process interruption and restart to work correctly, this functionality must be enabled during configuration \u2013 the value of the scmRTOS_PROCESS_RESTART_ENABLE macro must be set to 1. The term \"instance\" is often used in jargon. \u21a9 Actually, there are two variants of this class\u2014the standard one (shown here) and one with a separate stack for return addresses. The latter is not included here for brevity, as it contains no fundamental differences relevant for understanding or exposition. \u21a9 The same applies to the rest of the code\u2014much of the class definition is occupied by the description of these auxiliary capabilities. \u21a9 Strictly speaking, not exactly equal to the number of system timer ticks, but with an accuracy up to a fraction of this period, which depends on the moment the sleep function is called relative to the moment the system timer interrupt occurs. \u21a9 I.e., transitioned to the ready state. \u21a9 The ss prefix in this example stands for Start State \u21a9","title":"Process Restart"},{"location":"src/profiler/","text":"Extension Development: Process Profiler \ud83d\udd17 Purpose \ud83d\udd17 The process profiler is an object that performs the collection of information about the relative active time of system processes, processes this information, and has an interface through which a user program can access the profiling results. Information about the relative process execution time can be collected in different ways \u2013 in particular, by sampling the current active process and by measuring process execution time. Essentially, the profiler class itself can be the same, with the choice of implementation for both methods made by organizing how the profiler interacts with OS objects and uses the processor's hardware resources. The implementation of the profiler class itself requires access to the internals of the OS, but all these needs can be satisfied by the operating system's standard facilities, which are provided to the user for such purposes. Thus, the active process time profiler can be implemented as an OS extension. The goal of this example is to show how to create a useful tool that extends the functional capabilities of the operating system without modifying the OS source code. Additional requirements: The developed class must not impose restrictions on how the profiler is used \u2013 i.e., the information collection period and the place of use must be entirely determined by the user; The implementation must be as resource-efficient as possible, both in terms of executable code size and performance, i.e., the use of floating-point calculations, in particular, must be excluded. Implementation \ud83d\udd17 The profiler itself performs two main functions \u2013 collecting information about the relative active time of processes and processing this information to obtain results. Estimating the process execution time can be implemented based on a counter that accumulates this information. Accordingly, for all system processes, an array of such counters is required. An array of variables storing the profiling results is also required. Thus, the profiler must contain two arrays of variables: a function for updating the counters according to process activity, a function for processing the counter values and saving the results, and a function for accessing the profiling results. To increase flexibility of use, the base of the profiler is implemented as a template \u2013 see \"Listing 1. Profiler\". 01 template < typename T > 02 class process_profiler : public OS :: TKernelAgent 03 { 04 uint32_t time_interval (); 05 public : 06 INLINE process_profiler (); 07 08 INLINE void advance_counters () 09 { 10 uint32_t elapsed = time_interval (); 11 counters [ cur_proc_priority () ] += elapsed ; 12 } 13 14 INLINE T get_result ( uint_fast8_t index ) { return result [ index ]; } 15 INLINE void process_data (); 16 17 protected : 18 volatile uint32_t counters [ OS :: PROCESS_COUNT ]; 19 T result [ OS :: PROCESS_COUNT ]; 20 }; Listing 1. Profiler The profiler is implemented as a template, whose parameter specifies the type of variables containing the counter and result values. This allows for selecting the most suitable option for a specific application. It is assumed that the template parameter will be a numeric type \u2014 for example, uint32_t or float . If the target platform has hardware floating-point support, choosing float will be preferable \u2014 such an implementation will likely be both faster and more compact. In the absence of such support, using integer types would be advisable. In addition to the above, there is a very important function time_interval() (4). The time_interval() function is defined by the user based on the available resources and the chosen method for collecting process execution time information. The call to the advance_counters() function must be organized by the user, and the call site is determined by the chosen profiling method \u2014 statistical or measurement-based. The algorithm for processing the collected information results in normalizing the counter values accumulated over the measurement period \u2014 see \"Listing 2. Processing Profiling Results\". 01 template < typename T > 02 void process_profiler < T >:: process_data () 03 { 04 // Use cache to make critical section fast as possible 05 uint32_t counters_cache [ OS :: PROCESS_COUNT ]; 06 07 { 08 CritSect cs ; 09 for ( uint_fast8_t i = 0 ; i < OS :: PROCESS_COUNT ; ++ i ) 10 { 11 counters_cache [ i ] = counters [ i ]; 12 counters [ i ] = 0 ; 13 } 14 } 15 16 uint32_t sum = 0 ; 17 for ( uint_fast8_t i = 0 ; i < OS :: PROCESS_COUNT ; ++ i ) 18 { 19 sum += counters_cache [ i ]; 20 } 21 22 for ( uint_fast8_t i = 0 ; i < OS :: PROCESS_COUNT ; ++ i ) 23 { 24 if constexpr ( std :: is_integral_v < T > ) 25 { 26 result [ i ] = static_cast < uint64_t > ( counters_cache [ i ]) * 10000 / sum ; 27 } 28 else 29 { 30 result [ i ] = static_cast < T > ( counters_cache [ i ]) / sum * 100 ; 31 } 32 } 33 } Listing 2. Processing Profiling Results The provided code, in particular, shows how the result processing is selected depending on the template parameter type (24). To avoid blocking interrupts for a significant amount of time while accessing the counters array 1 , this array is copied into a temporary array, which is then used for further data processing. When an integer type is chosen as the template parameter, the resulting profiling resolution is one hundredth of a percent, and the final results are stored in hundredths of a percent. This is implemented by normalizing the value of each counter, previously multiplied by a coefficient defining the result resolution 2 , relative to the sum of the values of all counters. From these circumstances follows a natural limitation on the maximum value of the counter used in the calculations. For example, if the type of variables serving as the profiler's counters is a 32-bit unsigned integer, which can represent numbers in the range \\(0..2^{32}-1 = 0..4294967295\\) , and the calculations involve multiplication by a coefficient of 10000, then to prevent overflow during calculations, the counter value must not exceed: \\[ N_{max} = \\frac{2^{32} - 1}{10000} = \\frac{4294967295}{10000} = 429496 \\tag{1} \\] The resulting value is relatively small, so to extend this limitation, the calculations are performed with 64-bit precision \u2014 the counter value is cast to a 64-bit unsigned integer (26). The user must also ensure that no counter overflow occurs during the profiling period, i.e., the accumulated value in any counter does not exceed \\(2^{32}-1\\) . This requirement is met by coordinating the profiling period and the resolution of the value returned by the time_interval() function. The profiler is integrated into the project by including the header file profiler.h in the project's configuration file scmRTOS_extensions.h . Usage \ud83d\udd17 Statistical Method \ud83d\udd17 In the case of the statistical method, the call to the advance_counters() function should be placed in code that gains control periodically at equal time intervals \u2014 for example, in an interrupt handler of a timer; in scmRTOS , the system timer interrupt handler is well-suited for this purpose. In this case, the call to advance_counters() is placed in the user-defined system timer hook, whose invocation must be enabled during configuration. The time_interval() function in this case must always return 1. Measurement Method \ud83d\udd17 When choosing the measurement-based profiling method, the call to the advance_counters() function must occur during context switches. This can be achieved by placing its call in the user-defined context switch interrupt hook. The implementation of the time_interval() function in this case becomes somewhat more complex \u2014 the function must return a value proportional to the time interval between its previous and current calls. Measuring this time interval requires utilizing certain hardware resources of the target processor. In most cases, any hardware timer 3 that allows reading its timer register 4 is suitable for this. The scale of the value returned by the time_interval() function must be coordinated with the profiling period so that the sum of all values returned by this function for any process over the profiling period does not exceed \\(2^{32}-1\\) \u2014 see \"Listing 3. Time Interval Measurement Function\". 01 template < typename T > 02 uint32_t process_profiler < T >:: time_interval () 03 { 04 static uint32_t cycles ; 05 06 uint32_t cyc = rpa ( GTMR_CNT0_REG ); 07 uint32_t res = cyc - cycles ; 08 cycles = cyc ; 09 10 return res ; 11 } Listing 3. Time Interval Measurement Function In this example, a hardware processor clock cycle counter is used to measure time intervals. The processor operates at a frequency of 400 MHz, corresponding to a clock period of 2.5 ns. The profiling period is chosen to be 1 s. The ratio of the periods is such that the counter can reach the following value during the profiling period: \\[ N = \\frac{2}{5 \\cdot 10^{-9}} = 400 000 000 \\tag{2} \\] This value is significantly less than \\(2^{32}-1\\) , so no additional actions are necessary. Otherwise, it would be necessary to modify the function code to ensure the specified condition is met. Organizing the period for collecting information about the relative active time of processes and the method for displaying the profiling results are the user's responsibility. For convenience, a user-defined class can be created to simplify usage by adding a function to display the results \u2014 see \"Listing 4. User Profiler Class\". 01 class ProcProfiler : public process_profiler < float > 02 { 03 public : 04 ProcProfiler () {} 05 void get_results (); 06 }; 07 void ProcProfiler :: get_results () 08 { 09 print ( \" \\n ------------------------------ \\n \" ); 10 print ( \" Pr | CPU, %% | Slack | Name \\n \" ); 11 print ( \"------------------------------ \\n \" ); 12 13 # if scmRTOS_DEBUG_ENABLE == 1 14 for ( uint_fast8_t i = OS :: PROCESS_COUNT ; i ; ) 15 { 16 -- i ; 17 float proc_busy ; 18 if constexpr ( std :: is_integral_v < proc_profiler_data_t > ) 19 proc_busy = proc_profiler . get_result ( i ) / 100.0 ; 20 else 21 proc_busy = proc_profiler . get_result ( i ); 22 23 print ( \" %d | %7.4f | %4d | %s \\n \" , i , proc_busy , 24 OS :: get_proc ( i ) -> stack_slack () * sizeof ( stack_item_t ), 25 OS :: get_proc ( i ) -> name () ); 26 } 27 # endif 28 29 print ( \"------------------------------ \\n\\n \" ); 30 } Listing 4. User Profiler Class Finally, all that remains is to create an object of the class and ensure the periodic calling of the process_data() function: ProcProfiler proc_profiler ; ... ... proc_profiler . process_data (); // periodic call approx every 1 second ... This access must be made atomic to prevent corruption of the algorithm due to the possibility of asynchronous changes to the counter values when the advance_counters() function is called. \u21a9 In this case, this coefficient is 10000, which sets the resolution to 1/10000, corresponding to 0.01%. \u21a9 Some processors, for example, Blackfin or Cortex-A, have a dedicated hardware counter for processor clock cycles, which increments on every clock cycle, allowing for very simple organization of time interval measurement. \u21a9 For instance, the WatchDog Timer of the MSP430 MCU, which is quite suitable for use as a system timer, is not suitable for measuring time intervals because it does not allow the program to access its counting register. \u21a9","title":"Process Performance Profiling"},{"location":"src/profiler/#extension-developmentprocess-profiler","text":"","title":"Extension Development:Process Profiler"},{"location":"src/profiler/#purpose","text":"The process profiler is an object that performs the collection of information about the relative active time of system processes, processes this information, and has an interface through which a user program can access the profiling results. Information about the relative process execution time can be collected in different ways \u2013 in particular, by sampling the current active process and by measuring process execution time. Essentially, the profiler class itself can be the same, with the choice of implementation for both methods made by organizing how the profiler interacts with OS objects and uses the processor's hardware resources. The implementation of the profiler class itself requires access to the internals of the OS, but all these needs can be satisfied by the operating system's standard facilities, which are provided to the user for such purposes. Thus, the active process time profiler can be implemented as an OS extension. The goal of this example is to show how to create a useful tool that extends the functional capabilities of the operating system without modifying the OS source code. Additional requirements: The developed class must not impose restrictions on how the profiler is used \u2013 i.e., the information collection period and the place of use must be entirely determined by the user; The implementation must be as resource-efficient as possible, both in terms of executable code size and performance, i.e., the use of floating-point calculations, in particular, must be excluded.","title":"Purpose"},{"location":"src/profiler/#implementation","text":"The profiler itself performs two main functions \u2013 collecting information about the relative active time of processes and processing this information to obtain results. Estimating the process execution time can be implemented based on a counter that accumulates this information. Accordingly, for all system processes, an array of such counters is required. An array of variables storing the profiling results is also required. Thus, the profiler must contain two arrays of variables: a function for updating the counters according to process activity, a function for processing the counter values and saving the results, and a function for accessing the profiling results. To increase flexibility of use, the base of the profiler is implemented as a template \u2013 see \"Listing 1. Profiler\". 01 template < typename T > 02 class process_profiler : public OS :: TKernelAgent 03 { 04 uint32_t time_interval (); 05 public : 06 INLINE process_profiler (); 07 08 INLINE void advance_counters () 09 { 10 uint32_t elapsed = time_interval (); 11 counters [ cur_proc_priority () ] += elapsed ; 12 } 13 14 INLINE T get_result ( uint_fast8_t index ) { return result [ index ]; } 15 INLINE void process_data (); 16 17 protected : 18 volatile uint32_t counters [ OS :: PROCESS_COUNT ]; 19 T result [ OS :: PROCESS_COUNT ]; 20 }; Listing 1. Profiler The profiler is implemented as a template, whose parameter specifies the type of variables containing the counter and result values. This allows for selecting the most suitable option for a specific application. It is assumed that the template parameter will be a numeric type \u2014 for example, uint32_t or float . If the target platform has hardware floating-point support, choosing float will be preferable \u2014 such an implementation will likely be both faster and more compact. In the absence of such support, using integer types would be advisable. In addition to the above, there is a very important function time_interval() (4). The time_interval() function is defined by the user based on the available resources and the chosen method for collecting process execution time information. The call to the advance_counters() function must be organized by the user, and the call site is determined by the chosen profiling method \u2014 statistical or measurement-based. The algorithm for processing the collected information results in normalizing the counter values accumulated over the measurement period \u2014 see \"Listing 2. Processing Profiling Results\". 01 template < typename T > 02 void process_profiler < T >:: process_data () 03 { 04 // Use cache to make critical section fast as possible 05 uint32_t counters_cache [ OS :: PROCESS_COUNT ]; 06 07 { 08 CritSect cs ; 09 for ( uint_fast8_t i = 0 ; i < OS :: PROCESS_COUNT ; ++ i ) 10 { 11 counters_cache [ i ] = counters [ i ]; 12 counters [ i ] = 0 ; 13 } 14 } 15 16 uint32_t sum = 0 ; 17 for ( uint_fast8_t i = 0 ; i < OS :: PROCESS_COUNT ; ++ i ) 18 { 19 sum += counters_cache [ i ]; 20 } 21 22 for ( uint_fast8_t i = 0 ; i < OS :: PROCESS_COUNT ; ++ i ) 23 { 24 if constexpr ( std :: is_integral_v < T > ) 25 { 26 result [ i ] = static_cast < uint64_t > ( counters_cache [ i ]) * 10000 / sum ; 27 } 28 else 29 { 30 result [ i ] = static_cast < T > ( counters_cache [ i ]) / sum * 100 ; 31 } 32 } 33 } Listing 2. Processing Profiling Results The provided code, in particular, shows how the result processing is selected depending on the template parameter type (24). To avoid blocking interrupts for a significant amount of time while accessing the counters array 1 , this array is copied into a temporary array, which is then used for further data processing. When an integer type is chosen as the template parameter, the resulting profiling resolution is one hundredth of a percent, and the final results are stored in hundredths of a percent. This is implemented by normalizing the value of each counter, previously multiplied by a coefficient defining the result resolution 2 , relative to the sum of the values of all counters. From these circumstances follows a natural limitation on the maximum value of the counter used in the calculations. For example, if the type of variables serving as the profiler's counters is a 32-bit unsigned integer, which can represent numbers in the range \\(0..2^{32}-1 = 0..4294967295\\) , and the calculations involve multiplication by a coefficient of 10000, then to prevent overflow during calculations, the counter value must not exceed: \\[ N_{max} = \\frac{2^{32} - 1}{10000} = \\frac{4294967295}{10000} = 429496 \\tag{1} \\] The resulting value is relatively small, so to extend this limitation, the calculations are performed with 64-bit precision \u2014 the counter value is cast to a 64-bit unsigned integer (26). The user must also ensure that no counter overflow occurs during the profiling period, i.e., the accumulated value in any counter does not exceed \\(2^{32}-1\\) . This requirement is met by coordinating the profiling period and the resolution of the value returned by the time_interval() function. The profiler is integrated into the project by including the header file profiler.h in the project's configuration file scmRTOS_extensions.h .","title":"Implementation"},{"location":"src/profiler/#usage","text":"","title":"Usage"},{"location":"src/profiler/#statistical-method","text":"In the case of the statistical method, the call to the advance_counters() function should be placed in code that gains control periodically at equal time intervals \u2014 for example, in an interrupt handler of a timer; in scmRTOS , the system timer interrupt handler is well-suited for this purpose. In this case, the call to advance_counters() is placed in the user-defined system timer hook, whose invocation must be enabled during configuration. The time_interval() function in this case must always return 1.","title":"Statistical Method"},{"location":"src/profiler/#measurement-method","text":"When choosing the measurement-based profiling method, the call to the advance_counters() function must occur during context switches. This can be achieved by placing its call in the user-defined context switch interrupt hook. The implementation of the time_interval() function in this case becomes somewhat more complex \u2014 the function must return a value proportional to the time interval between its previous and current calls. Measuring this time interval requires utilizing certain hardware resources of the target processor. In most cases, any hardware timer 3 that allows reading its timer register 4 is suitable for this. The scale of the value returned by the time_interval() function must be coordinated with the profiling period so that the sum of all values returned by this function for any process over the profiling period does not exceed \\(2^{32}-1\\) \u2014 see \"Listing 3. Time Interval Measurement Function\". 01 template < typename T > 02 uint32_t process_profiler < T >:: time_interval () 03 { 04 static uint32_t cycles ; 05 06 uint32_t cyc = rpa ( GTMR_CNT0_REG ); 07 uint32_t res = cyc - cycles ; 08 cycles = cyc ; 09 10 return res ; 11 } Listing 3. Time Interval Measurement Function In this example, a hardware processor clock cycle counter is used to measure time intervals. The processor operates at a frequency of 400 MHz, corresponding to a clock period of 2.5 ns. The profiling period is chosen to be 1 s. The ratio of the periods is such that the counter can reach the following value during the profiling period: \\[ N = \\frac{2}{5 \\cdot 10^{-9}} = 400 000 000 \\tag{2} \\] This value is significantly less than \\(2^{32}-1\\) , so no additional actions are necessary. Otherwise, it would be necessary to modify the function code to ensure the specified condition is met. Organizing the period for collecting information about the relative active time of processes and the method for displaying the profiling results are the user's responsibility. For convenience, a user-defined class can be created to simplify usage by adding a function to display the results \u2014 see \"Listing 4. User Profiler Class\". 01 class ProcProfiler : public process_profiler < float > 02 { 03 public : 04 ProcProfiler () {} 05 void get_results (); 06 }; 07 void ProcProfiler :: get_results () 08 { 09 print ( \" \\n ------------------------------ \\n \" ); 10 print ( \" Pr | CPU, %% | Slack | Name \\n \" ); 11 print ( \"------------------------------ \\n \" ); 12 13 # if scmRTOS_DEBUG_ENABLE == 1 14 for ( uint_fast8_t i = OS :: PROCESS_COUNT ; i ; ) 15 { 16 -- i ; 17 float proc_busy ; 18 if constexpr ( std :: is_integral_v < proc_profiler_data_t > ) 19 proc_busy = proc_profiler . get_result ( i ) / 100.0 ; 20 else 21 proc_busy = proc_profiler . get_result ( i ); 22 23 print ( \" %d | %7.4f | %4d | %s \\n \" , i , proc_busy , 24 OS :: get_proc ( i ) -> stack_slack () * sizeof ( stack_item_t ), 25 OS :: get_proc ( i ) -> name () ); 26 } 27 # endif 28 29 print ( \"------------------------------ \\n\\n \" ); 30 } Listing 4. User Profiler Class Finally, all that remains is to create an object of the class and ensure the periodic calling of the process_data() function: ProcProfiler proc_profiler ; ... ... proc_profiler . process_data (); // periodic call approx every 1 second ... This access must be made atomic to prevent corruption of the algorithm due to the possibility of asynchronous changes to the counter values when the advance_counters() function is called. \u21a9 In this case, this coefficient is 10000, which sets the resolution to 1/10000, corresponding to 0.01%. \u21a9 Some processors, for example, Blackfin or Cortex-A, have a dedicated hardware counter for processor clock cycles, which increments on every clock cycle, allowing for very simple organization of time interval measurement. \u21a9 For instance, the WatchDog Timer of the MSP430 MCU, which is quite suitable for use as a system timer, is not suitable for measuring time intervals because it does not allow the program to access its counting register. \u21a9","title":"Measurement Method"}]}
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Kernel - scmRTOS</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Kernel";
        var mkdocs_page_input_path = "src/kernel.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
 <link href="../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: white; }</style> <script src="../../assets/javascripts/glightbox.min.js"></script></head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> scmRTOS
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Intro</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../..">Not a Preface</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../overview/">Overview</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">RTOS Components</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Kernel</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#general-information">General Information</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#tkernel-composition-and-operation">TKernel. Composition and Operation</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#composition">Composition</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#process-organization">Process Organization</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#control-transfer">Control Transfer</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#scheduler">Scheduler</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#scheduler-with-direct-control-transfer">Scheduler with Direct Control Transfer</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#scheduler-with-software-interrupt">Scheduler with Software Interrupt</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#pros-and-cons-of-control-transfer-methods">Pros and Cons of Control Transfer Methods</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#direct-control-transfer">Direct Control Transfer</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#software-interrupt-based-control-transfer">Software Interrupt-Based Control Transfer</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#conclusions">Conclusions</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#support-for-interprocess-communication">Support for Interprocess Communication</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#interrupts">Interrupts</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#usage-features-with-rtos-and-implementation">Usage Features with RTOS and Implementation</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#separate-interrupt-stack-and-nested-interrupts">Separate Interrupt Stack and Nested Interrupts</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#system-timer">System Timer</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#tkernelagent-and-extensions">TKernelAgent and Extensions</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#kernel-agent">Kernel Agent</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#extensions">Extensions</a>
    </li>
        </ul>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../processes/">Processes</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ipcs/">Interprocess Communications</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ports/">Ports</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Appendix</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../debug/">Debug</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../profiler/">Process Profiling</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../example-job-queue/">Example: Job Queue</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../glossary/">Glossary</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">scmRTOS</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">RTOS Components</li>
      <li class="breadcrumb-item active">Kernel</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="kernel">Kernel<a class="headerlink" href="#kernel" title="Permanent link">ðŸ”—</a></h1>
<hr />
<h2 id="general-information">General Information<a class="headerlink" href="#general-information" title="Permanent link">ðŸ”—</a></h2>
<p>The OS kernel performs:</p>
<ul>
<li>Process organization functions.</li>
<li>Scheduling at both process and interrupt levels.</li>
<li>Support for interprocess communication services.</li>
<li>System time support (system timer).</li>
<li>Extension support.</li>
</ul>
<p>The core of the system is the <code>TKernel</code> class, which includes all the necessary functions and data. For obvious reasons, there is only one instance of this class. Almost its entire implementation is private, and to allow access from certain OS parts that require kernel resources, the C++ "friend" mechanism is used â€” functions and classes granted such access are declared with the <code>friend</code> keyword.</p>
<p>It should be noted that in this context, the kernel refers not only to the <code>TKernel</code> object but also to the extension mechanism implemented as the <code>TKernelAgent</code> class. This class was specifically introduced to provide a base for building extensions. Looking ahead, all interprocess communication services in <strong>scmRTOS</strong> are implemented as such extensions. The <code>TKernelAgent</code> class is declared as a "friend" of <code>TKernel</code> and contains the minimal necessary set of protected functions to grant descendants access to kernel resources. Extensions are built by inheriting from <code>TKernelAgent</code>. For more details, see <a href="./#kernel-agent">TKernelAgent and Extensions</a>.</p>
<hr />
<h2 id="tkernel-composition-and-operation">TKernel. Composition and Operation<a class="headerlink" href="#tkernel-composition-and-operation" title="Permanent link">ðŸ”—</a></h2>
<h3 id="composition">Composition<a class="headerlink" href="#composition" title="Permanent link">ðŸ”—</a></h3>
<p>The <code>TKernel</code> class contains the following data members<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup>:</p>
<ul>
<li><code>CurProcPriority</code> â€” variable holding the priority number of the current active process. Used for quick access to the current process resources and for manipulating process status (both relative to the kernel and to interprocess communication services)<sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup>;</li>
<li><code>ReadyProcessMap</code> â€” map of processes ready for execution. Contains tags of ready processes: each bit corresponds to a specific process, with logical 1 indicating the process is ready<sup id="fnref:3"><a class="footnote-ref" href="#fn:3">3</a></sup>, and logical 0 indicating it is not;</li>
<li><code>ProcessTable</code> â€” array of pointers to processes registered in the system;</li>
<li><code>ISR_NestCount</code> â€” interrupt nesting counter variable. Incremented on each interrupt entry and decremented on each exit;</li>
<li><code>SysTickCount</code> â€” system timer tick (overflow) counter variable. Present only if this feature is enabled (via the corresponding macro in the configuration file);</li>
<li><code>SchedProcPriority</code>* â€” variable for storing the priority value of the process scheduled to receive control.</li>
</ul>
<h3 id="process-organization">Process Organization<a class="headerlink" href="#process-organization" title="Permanent link">ðŸ”—</a></h3>
<p>The process organization function reduces to registering created processes. In each process constructor, the kernel function <code>register_process(TBaseProcess *)</code> is called, which places the pointer to the passed process into the system <code>ProcessTable</code> (see below). The position in the table is determined by the process priority, which effectively serves as the table index. The process registration function code is shown in "Listing 1. Process Registration Function".</p>
<figure>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-0-1"><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a><span class="mi">1</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">OS</span><span class="o">::</span><span class="n">TKernel</span><span class="o">::</span><span class="n">register_process</span><span class="p">(</span><span class="n">OS</span><span class="o">::</span><span class="n">TBaseProcess</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
</span><span id="__span-0-2"><a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a><span class="mi">2</span><span class="w">    </span><span class="p">{</span>
</span><span id="__span-0-3"><a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a><span class="mi">3</span><span class="w">        </span><span class="n">ProcessTable</span><span class="p">[</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">Priority</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
</span><span id="__span-0-4"><a id="__codelineno-0-4" name="__codelineno-0-4" href="#__codelineno-0-4"></a><span class="mi">4</span><span class="w">    </span><span class="p">}</span>
</span></code></pre></div>
<figcaption>
<p>Listing 1. Process Registration Function</p>
</figcaption>
</figure>
<p>The next system function is the actual OS startup. The system startup function code is shown in "Listing 2. OS Startup Function".</p>
<figure>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-1-1"><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span class="mi">1</span><span class="w">    </span><span class="n">INLINE</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">OS</span><span class="o">::</span><span class="n">run</span><span class="p">()</span>
</span><span id="__span-1-2"><a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a><span class="mi">2</span><span class="w">    </span><span class="p">{</span>
</span><span id="__span-1-3"><a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a><span class="mi">3</span><span class="w">        </span><span class="n">stack_item_t</span><span class="w"> </span><span class="o">*</span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Kernel</span><span class="p">.</span><span class="n">ProcessTable</span><span class="p">[</span><span class="n">pr0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">StackPointer</span><span class="p">;</span>
</span><span id="__span-1-4"><a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a><span class="mi">4</span><span class="w">        </span><span class="n">os_start</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
</span><span id="__span-1-5"><a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a><span class="mi">5</span><span class="w">    </span><span class="p">}</span>
</span></code></pre></div>
<figcaption>
<p>Listing 2. OS Startup Function</p>
</figcaption>
</figure>
<p>As seen, the actions are extremely simple: the stack pointer of the highest-priority process is retrieved from the process table (line 3), and the system is started (line 4) by calling the low-level <code>os_start()</code> function, passing it the retrieved stack pointer of the highest-priority process.</p>
<p>From this moment, the OS begins operating in normal mode â€” control is transferred between processes according to their priorities, events, and the user program.</p>
<h3 id="control-transfer">Control Transfer<a class="headerlink" href="#control-transfer" title="Permanent link">ðŸ”—</a></h3>
<p>Control transfer can occur in two ways:</p>
<ul>
<li>The process voluntarily yields control when it has nothing more to do (for now), or as a result of its work, it needs to engage in interprocess communication with other processes (acquire a mutual exclusion semaphore (<code>OS::TMutex</code>), or, after signaling an event flag (<code>OS::TEventFlag</code>), notify the kernel, which must then perform (if necessary) process rescheduling.</li>
<li>Control is taken from the process by the kernel due to an interrupt triggered by some event; if a higher-priority process was waiting for that event, control is given to it, and the interrupted process waits until the higher-priority one completes its task and yields control<sup id="fnref:4"><a class="footnote-ref" href="#fn:4">4</a></sup>.</li>
</ul>
<p>In the first case, rescheduling is synchronous relative to program execution flow&nbsp;â€“ performed in the scheduler code. In the second case, it is asynchronous upon event occurrence.</p>
<p>Control transfer itself can be organized in several ways. One is direct transfer by calling a low-level<sup id="fnref:5"><a class="footnote-ref" href="#fn:5">5</a></sup> context switcher function from the scheduler<sup id="fnref:6"><a class="footnote-ref" href="#fn:6">6</a></sup>. Another is by triggering a special software interrupt where the context switch occurs. <strong>scmRTOS</strong> supports both methods. Each has advantages and disadvantages, discussed in detail below.</p>
<h3 id="scheduler">Scheduler<a class="headerlink" href="#scheduler" title="Permanent link">ðŸ”—</a></h3>
<p>The scheduler source code is in the <code>sched()</code> function, see "Listing 3. Scheduler".</p>
<p>There are two variants: one for direct control transfer (<code>scmRTOS_CONTEXT_SWITCH_SCHEME == 0</code>), the other for software interrupt-based transfer.</p>
<p>Note that scheduling from the main program level is done via the <code>scheduler()</code> function, which calls the actual scheduler only if not invoked from an interrupt:</p>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-2-1"><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a><span class="n">INLINE</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">scheduler</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">ISR_NestCount</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">sched</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
</span></code></pre></div>
<p>With proper use of OS services, this situation should not occur, as scheduling from interrupts should use specialized versions of functions (names suffixed with <code>_isr</code>) designed for interrupt level.</p>
<p>For example, to signal an event flag from an interrupt, the user should use <code>signal_isr()</code><sup id="fnref:7"><a class="footnote-ref" href="#fn:7">7</a></sup> instead. However, using the non-_isr version won't cause a fatal error&nbsp;â€“ the scheduler simply won't be called, and despite the event arriving in the interrupt, no control transfer occurs, even if it was due.</p>
<p>Control transfer happens only at the next rescheduling call, which occurs when the destructor of a <code>TISRW/TISRW_SS</code> object executes. Thus, <code>scheduler()</code> provides protection against program crashes from careless service use or services lacking <code>_isr</code> versions â€” e.g., <code>channel::push()</code>.</p>
<figure>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-3-1"><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a><span class="mo">01</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">OS</span><span class="o">::</span><span class="n">TKernel</span><span class="o">::</span><span class="n">update_sched_prio</span><span class="p">()</span>
</span><span id="__span-3-2"><a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a><span class="mo">02</span><span class="w">    </span><span class="p">{</span>
</span><span id="__span-3-3"><a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a><span class="mo">03</span><span class="w">        </span><span class="kt">uint_fast8_t</span><span class="w"> </span><span class="n">NextPrty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">highest_priority</span><span class="p">(</span><span class="n">ReadyProcessMap</span><span class="p">);</span>
</span><span id="__span-3-4"><a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a><span class="mo">04</span><span class="w">    </span>
</span><span id="__span-3-5"><a id="__codelineno-3-5" name="__codelineno-3-5" href="#__codelineno-3-5"></a><span class="mo">05</span><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">NextPrty</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CurProcPriority</span><span class="p">)</span>
</span><span id="__span-3-6"><a id="__codelineno-3-6" name="__codelineno-3-6" href="#__codelineno-3-6"></a><span class="mo">06</span><span class="w">        </span><span class="p">{</span>
</span><span id="__span-3-7"><a id="__codelineno-3-7" name="__codelineno-3-7" href="#__codelineno-3-7"></a><span class="mo">07</span><span class="w">            </span><span class="n">SchedProcPriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NextPrty</span><span class="p">;</span>
</span><span id="__span-3-8"><a id="__codelineno-3-8" name="__codelineno-3-8" href="#__codelineno-3-8"></a><span class="mi">08</span><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
</span><span id="__span-3-9"><a id="__codelineno-3-9" name="__codelineno-3-9" href="#__codelineno-3-9"></a><span class="mi">09</span><span class="w">        </span><span class="p">}</span>
</span><span id="__span-3-10"><a id="__codelineno-3-10" name="__codelineno-3-10" href="#__codelineno-3-10"></a><span class="mi">10</span><span class="w">    </span>
</span><span id="__span-3-11"><a id="__codelineno-3-11" name="__codelineno-3-11" href="#__codelineno-3-11"></a><span class="mi">11</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
</span><span id="__span-3-12"><a id="__codelineno-3-12" name="__codelineno-3-12" href="#__codelineno-3-12"></a><span class="mi">12</span><span class="w">    </span><span class="p">}</span>
</span><span id="__span-3-13"><a id="__codelineno-3-13" name="__codelineno-3-13" href="#__codelineno-3-13"></a>
</span><span id="__span-3-14"><a id="__codelineno-3-14" name="__codelineno-3-14" href="#__codelineno-3-14"></a><span class="mi">13</span><span class="w">    </span><span class="err">#</span><span class="k">if</span><span class="w"> </span><span class="n">scmRTOS_CONTEXT_SWITCH_SCHEME</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span>
</span><span id="__span-3-15"><a id="__codelineno-3-15" name="__codelineno-3-15" href="#__codelineno-3-15"></a><span class="mi">14</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">TKernel</span><span class="o">::</span><span class="n">sched</span><span class="p">()</span>
</span><span id="__span-3-16"><a id="__codelineno-3-16" name="__codelineno-3-16" href="#__codelineno-3-16"></a><span class="mi">15</span><span class="w">    </span><span class="p">{</span>
</span><span id="__span-3-17"><a id="__codelineno-3-17" name="__codelineno-3-17" href="#__codelineno-3-17"></a><span class="mi">16</span><span class="w">        </span><span class="kt">uint_fast8_t</span><span class="w"> </span><span class="n">NextPrty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">highest_priority</span><span class="p">(</span><span class="n">ReadyProcessMap</span><span class="p">);</span>
</span><span id="__span-3-18"><a id="__codelineno-3-18" name="__codelineno-3-18" href="#__codelineno-3-18"></a><span class="mi">17</span><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">NextPrty</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">CurProcPriority</span><span class="p">)</span>
</span><span id="__span-3-19"><a id="__codelineno-3-19" name="__codelineno-3-19" href="#__codelineno-3-19"></a><span class="mi">18</span><span class="w">        </span><span class="p">{</span>
</span><span id="__span-3-20"><a id="__codelineno-3-20" name="__codelineno-3-20" href="#__codelineno-3-20"></a><span class="mi">19</span><span class="w">        </span><span class="err">#</span><span class="k">if</span><span class="w"> </span><span class="n">scmRTOS_CONTEXT_SWITCH_USER_HOOK_ENABLE</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>
</span><span id="__span-3-21"><a id="__codelineno-3-21" name="__codelineno-3-21" href="#__codelineno-3-21"></a><span class="mi">20</span><span class="w">            </span><span class="n">context_switch_user_hook</span><span class="p">();</span>
</span><span id="__span-3-22"><a id="__codelineno-3-22" name="__codelineno-3-22" href="#__codelineno-3-22"></a><span class="mi">21</span><span class="w">        </span><span class="err">#</span><span class="n">endif</span>
</span><span id="__span-3-23"><a id="__codelineno-3-23" name="__codelineno-3-23" href="#__codelineno-3-23"></a><span class="mi">22</span><span class="w">    </span>
</span><span id="__span-3-24"><a id="__codelineno-3-24" name="__codelineno-3-24" href="#__codelineno-3-24"></a><span class="mi">23</span><span class="w">            </span><span class="n">stack_item_t</span><span class="o">*</span><span class="w">  </span><span class="n">Next_SP</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">ProcessTable</span><span class="p">[</span><span class="n">NextPrty</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">StackPointer</span><span class="p">;</span>
</span><span id="__span-3-25"><a id="__codelineno-3-25" name="__codelineno-3-25" href="#__codelineno-3-25"></a><span class="mi">24</span><span class="w">            </span><span class="n">stack_item_t</span><span class="o">**</span><span class="w"> </span><span class="n">Curr_SP_addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">ProcessTable</span><span class="p">[</span><span class="n">CurProcPriority</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">StackPointer</span><span class="p">);</span>
</span><span id="__span-3-26"><a id="__codelineno-3-26" name="__codelineno-3-26" href="#__codelineno-3-26"></a><span class="mi">25</span><span class="w">            </span><span class="n">CurProcPriority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NextPrty</span><span class="p">;</span>
</span><span id="__span-3-27"><a id="__codelineno-3-27" name="__codelineno-3-27" href="#__codelineno-3-27"></a><span class="mi">26</span><span class="w">            </span><span class="n">os_context_switcher</span><span class="p">(</span><span class="n">Curr_SP_addr</span><span class="p">,</span><span class="w"> </span><span class="n">Next_SP</span><span class="p">);</span>
</span><span id="__span-3-28"><a id="__codelineno-3-28" name="__codelineno-3-28" href="#__codelineno-3-28"></a><span class="mi">27</span><span class="w">        </span><span class="p">}</span>
</span><span id="__span-3-29"><a id="__codelineno-3-29" name="__codelineno-3-29" href="#__codelineno-3-29"></a><span class="mi">28</span><span class="w">    </span><span class="p">}</span>
</span><span id="__span-3-30"><a id="__codelineno-3-30" name="__codelineno-3-30" href="#__codelineno-3-30"></a><span class="mi">29</span><span class="w">    </span><span class="err">#</span><span class="k">else</span>
</span><span id="__span-3-31"><a id="__codelineno-3-31" name="__codelineno-3-31" href="#__codelineno-3-31"></a><span class="mi">30</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">TKernel</span><span class="o">::</span><span class="n">sched</span><span class="p">()</span>
</span><span id="__span-3-32"><a id="__codelineno-3-32" name="__codelineno-3-32" href="#__codelineno-3-32"></a><span class="mi">31</span><span class="w">    </span><span class="p">{</span>
</span><span id="__span-3-33"><a id="__codelineno-3-33" name="__codelineno-3-33" href="#__codelineno-3-33"></a><span class="mi">32</span><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">update_sched_prio</span><span class="p">())</span>
</span><span id="__span-3-34"><a id="__codelineno-3-34" name="__codelineno-3-34" href="#__codelineno-3-34"></a><span class="mi">33</span><span class="w">        </span><span class="p">{</span>
</span><span id="__span-3-35"><a id="__codelineno-3-35" name="__codelineno-3-35" href="#__codelineno-3-35"></a><span class="mi">34</span><span class="w">            </span><span class="n">raise_context_switch</span><span class="p">();</span>
</span><span id="__span-3-36"><a id="__codelineno-3-36" name="__codelineno-3-36" href="#__codelineno-3-36"></a><span class="mi">35</span><span class="w">            </span><span class="k">do</span>
</span><span id="__span-3-37"><a id="__codelineno-3-37" name="__codelineno-3-37" href="#__codelineno-3-37"></a><span class="mi">36</span><span class="w">            </span><span class="p">{</span>
</span><span id="__span-3-38"><a id="__codelineno-3-38" name="__codelineno-3-38" href="#__codelineno-3-38"></a><span class="mi">37</span><span class="w">                </span><span class="n">enable_context_switch</span><span class="p">();</span>
</span><span id="__span-3-39"><a id="__codelineno-3-39" name="__codelineno-3-39" href="#__codelineno-3-39"></a><span class="mi">38</span><span class="w">                </span><span class="n">DUMMY_INSTR</span><span class="p">();</span>
</span><span id="__span-3-40"><a id="__codelineno-3-40" name="__codelineno-3-40" href="#__codelineno-3-40"></a><span class="mi">39</span><span class="w">                </span><span class="n">disable_context_switch</span><span class="p">();</span>
</span><span id="__span-3-41"><a id="__codelineno-3-41" name="__codelineno-3-41" href="#__codelineno-3-41"></a><span class="mi">40</span><span class="w">            </span><span class="p">}</span>
</span><span id="__span-3-42"><a id="__codelineno-3-42" name="__codelineno-3-42" href="#__codelineno-3-42"></a><span class="mi">41</span><span class="w">            </span><span class="k">while</span><span class="p">(</span><span class="n">CurProcPriority</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SchedProcPriority</span><span class="p">);</span><span class="w"> </span><span class="c1">// until context switch done</span>
</span><span id="__span-3-43"><a id="__codelineno-3-43" name="__codelineno-3-43" href="#__codelineno-3-43"></a><span class="mi">42</span><span class="w">        </span><span class="p">}</span>
</span><span id="__span-3-44"><a id="__codelineno-3-44" name="__codelineno-3-44" href="#__codelineno-3-44"></a><span class="mi">43</span><span class="w">    </span><span class="p">}</span>
</span><span id="__span-3-45"><a id="__codelineno-3-45" name="__codelineno-3-45" href="#__codelineno-3-45"></a><span class="mi">44</span><span class="w">    </span><span class="err">#</span><span class="n">endif</span><span class="w"> </span><span class="c1">// scmRTOS_CONTEXT_SWITCH_SCHEME</span>
</span></code></pre></div>
<figcaption>
<p>Listing 3. Scheduler</p>
</figcaption>
</figure>
<h4 id="scheduler-with-direct-control-transfer">Scheduler with Direct Control Transfer<a class="headerlink" href="#scheduler-with-direct-control-transfer" title="Permanent link">ðŸ”—</a></h4>
<p>All actions inside the scheduler must be non-interruptible, so the function code executes in a critical section. However, since the scheduler is always called with interrupts disabled, no explicit critical section is needed.</p>
<p>First, the priority of the highest-priority ready-to-run process is computed (by analyzing the ready process map <code>ReadyProcessMap</code>).</p>
<p>The found priority is compared to the current process priority. If they match, the current process is the highest-priority ready-to-run one, no transfer is needed, and execution continues in the current process.</p>
<p>If they differ, a higher-priority ready-to-run process has appeared, and control must transfer to it via context switch. The current process context is saved to its stack, and the next process context is restored from its stack. These platform-dependent actions are performed in the low-level (assembly) <code>os_context_switcher()</code> function called from the scheduler (line 26). It receives two parameters:</p>
<ul>
<li>Address of the current process stack pointer, where the pointer itself will be stored after saving the current context (line 24);</li>
<li>Stack pointer of the next process (line 23).</li>
</ul>
<p>When implementing the low-level context switcher, pay attention to the platform and compiler calling conventions and parameter passing.</p>
<h4 id="scheduler-with-software-interrupt">Scheduler with Software Interrupt<a class="headerlink" href="#scheduler-with-software-interrupt" title="Permanent link">ðŸ”—</a></h4>
<p>This variant differs significantly from the above. The main difference is that the actual context switch occurs not by directly calling the context switcher but by triggering a special software interrupt where the switch happens. This approach has nuances and requires special measures to prevent system integrity violations.</p>
<p>The primary challenge in implementing this control transfer method is that the scheduler code and the software interrupt handler code are not strictly continuous or "atomic"&nbsp;â€“ an interrupt can occur between them, potentially triggering another rescheduling and causing an overlap that corrupts the control transfer process. To avoid this collision, the rescheduling control transfer process is divided into two "atomic" operations that can be safely separated.</p>
<p>The first operation is, as before, computing the priority of the highest-priority ready-to-run processâ€”via the call to <code>update_sched_prio()</code> (line 01)â€”and checking whether rescheduling is necessary (line 32). If it is, the priority value of the next process is stored in the <code>SchedProcPriority</code> variable (line 07), and the software context switch interrupt is raised (line 34). The program then enters a loop waiting for the context switch to occur (line 35).</p>
<p>This hides a rather subtle point. Why not, for example, simply implement the interrupt-enabled window with a pair of dummy instructions (to give the processor hardware time to actually trigger the interrupt)? Such an implementation conceals a hard-to-detect error, as follows.</p>
<p>If, at the moment interrupts are enabledâ€”which in this OS version is implemented by globally enabling interrupts (line 37)â€”one or more other interrupts are pending in addition to the software interrupt, and some of them have higher priority than the software context switch interrupt, control will naturally transfer to the handler of the corresponding interrupt. Upon completion, execution returns to the interrupted program. At this point, in the main program (i.e., inside the scheduler function), the processor may execute one or more instructions<sup id="fnref:8"><a class="footnote-ref" href="#fn:8">8</a></sup> before the next interrupt can be serviced.</p>
<p>The program could then reach the code that disables context switching, resulting in interrupts being globally disabled and preventing the software interrupt (where the context switch occurs) from executing. This means control would remain in the current process, even though it should have been transferred to the system (and other processes) until the event awaited by the current process occurs. This is nothing less than a violation of system integrity and can lead to a wide variety of unpredictable negative consequences.</p>
<p>Clearly, such a situation must not arise. Therefore, instead of a few dummy instructions in the interrupt-enabled window, a context switch wait loop is used. No matter how many interrupts are queued, program control does not proceed beyond this loop until the actual context switch has occurred.</p>
<p>To make this mechanism work, a criterion is needed to confirm that rescheduling has actually taken place. This criterion is the equality of the kernel variables <code>CurProcPriority</code> and <code>SchedProcPriority</code>. These variables become equal (i.e., the current priority value matches the scheduled one) only after the context switch has been performed.</p>
<p>As can be seen, no updates are made here to variables holding stack pointers or the current priority value. All such actions are performed later during the actual context switch by calling the special kernel function <code>os_context_switch_hook()</code>.</p>
<p>One might ask: why all this complexity? To answer, consider a scenario where, in the software interrupt case, the scheduler implementation remained the same as in the direct context switcher callâ€”only instead of:</p>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-4-1"><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a><span class="n">os_context_switcher</span><span class="p">(</span><span class="n">Curr_SP_addr</span><span class="p">,</span><span class="w"> </span><span class="n">Next_SP</span><span class="p">);</span>
</span></code></pre></div>
<p>we have<sup id="fnref:9"><a class="footnote-ref" href="#fn:9">9</a></sup>:</p>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-5-1"><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a><span class="n">raise_context_switch</span><span class="p">();</span>
</span><span id="__span-5-2"><a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a><span class="o">&lt;</span><span class="n">wait_for_context_switch_done</span><span class="o">&gt;</span><span class="p">;</span>
</span></code></pre></div>
<p>Now imagine a situation where, at the moment interrupts are enabled, one or more other interrupts are pending, at least one of which is higher priority than the software context switch interrupt, and the handler for that higher-priority pending interrupt calls one of the interprocess communication service functions. What happens then?</p>
<p>The scheduler would be invoked again, triggering another process rescheduling. However, since the previous rescheduling was not completedâ€”i.e., processes were not actually switched, contexts were not physically saved and restoredâ€”the new rescheduling would simply overwrite the variables holding the current and next process pointers.</p>
<p>Moreover, when determining the need for rescheduling, the value of <code>CurProcPriority</code> would be used, which is effectively incorrect because it holds the priority of the process scheduled from the previous scheduler invocation. In short, rescheduling operations would overlap, violating system integrity.</p>
<p>Therefore, it is critical that the actual update of <code>CurProcPriority</code> and the process context switch be "atomic"â€”inseparable and not interrupted by other code related to process scheduling. In the direct context switcher call variant, this rule is inherently satisfied: the entire scheduler operates in a critical section, and the context switcher is called directly from there.</p>
<p>In the variant with software interrupt, context scheduling and switching can be "separated" in time. Therefore, the actual switching and updating of the current priority occur directly during the execution of the software interrupt handler<sup id="fnref:10"><a class="footnote-ref" href="#fn:10">10</a></sup>. In it, immediately after saving the context of the current process, the function <code>os_context_switch_hook()</code> is called (where the value of <code>CurProcPriority</code> is actually updated), and the stack pointer of the current process is passed to <code>os_context_switch_hook()</code>, where it is saved in the current process object. The stack pointer of the next process is then retrieved and returned from the function, which is necessary for restoring the context of that process and subsequently transferring control to it.</p>
<p>To avoid degrading performance characteristics in interrupt handlers, there is a special lightweight embedded version of the scheduler used by some member functions of service objects, optimized for use in ISRs. The code for this scheduler version is shown in "Listing 4. Scheduler variant optimized for use in ISR".</p>
<figure>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-6-1"><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a><span class="mo">01</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">OS</span><span class="o">::</span><span class="n">TKernel</span><span class="o">::</span><span class="n">sched_isr</span><span class="p">()</span>
</span><span id="__span-6-2"><a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a><span class="mo">02</span><span class="w">    </span><span class="p">{</span>
</span><span id="__span-6-3"><a id="__codelineno-6-3" name="__codelineno-6-3" href="#__codelineno-6-3"></a><span class="mo">03</span><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">update_sched_prio</span><span class="p">())</span>
</span><span id="__span-6-4"><a id="__codelineno-6-4" name="__codelineno-6-4" href="#__codelineno-6-4"></a><span class="mo">04</span><span class="w">        </span><span class="p">{</span>
</span><span id="__span-6-5"><a id="__codelineno-6-5" name="__codelineno-6-5" href="#__codelineno-6-5"></a><span class="mo">05</span><span class="w">            </span><span class="n">raise_context_switch</span><span class="p">();</span>
</span><span id="__span-6-6"><a id="__codelineno-6-6" name="__codelineno-6-6" href="#__codelineno-6-6"></a><span class="mo">06</span><span class="w">        </span><span class="p">}</span>
</span><span id="__span-6-7"><a id="__codelineno-6-7" name="__codelineno-6-7" href="#__codelineno-6-7"></a><span class="mo">07</span><span class="w">    </span><span class="p">}</span>
</span></code></pre></div>
<figcaption>
<p>Listing 4. Scheduler variant optimized for use in ISR  </p>
</figcaption>
</figure>
<p>When selecting an interrupt handler for context switching, preference should be given to one with the lowest priority (in the case of a priority interrupt controller). This avoids unnecessary rescheduling and context switches if multiple interrupts occur in succession.</p>
<h3 id="pros-and-cons-of-control-transfer-methods">Pros and Cons of Control Transfer Methods<a class="headerlink" href="#pros-and-cons-of-control-transfer-methods" title="Permanent link">ðŸ”—</a></h3>
<p>Both methods have their advantages and disadvantages. The strengths of one control transfer method are the weaknesses of the other, and vice versa.</p>
<h4 id="direct-control-transfer">Direct Control Transfer<a class="headerlink" href="#direct-control-transfer" title="Permanent link">ðŸ”—</a></h4>
<p>The main advantage of direct control transfer is that it does not require a special software interrupt in the target MCU&nbsp;â€“ not all MCUs have this hardware capability. A secondary minor benefit is slightly higher performance compared to the software interrupt variant, as the latter incurs additional overhead for activating the context switch interrupt handler, the wait cycle for context switching, and the call to <code>os_context_switch_hook()</code>.</p>
<p>However, the direct control transfer variant has a significant drawback: when the scheduler is called from an interrupt handler, the compiler is forced to save the "local context" (scratch registers of the processor) due to the call to a non-inlined context switch function, which introduces overhead that can be substantial compared to the rest of the ISR code. The negative aspect here is that saving these registers may be entirely unnecessaryâ€”after all, in that function<sup id="fnref:11"><a class="footnote-ref" href="#fn:11">11</a></sup>, which causes them to be saved, these registers are not used. Therefore, if there are no further calls to non-inlined functions, the code for saving and restoring this group of registers turns out to be redundant.</p>
<h4 id="software-interrupt-based-control-transfer">Software Interrupt-Based Control Transfer<a class="headerlink" href="#software-interrupt-based-control-transfer" title="Permanent link">ðŸ”—</a></h4>
<p>This variant avoids the aforementioned drawback. Since the ISR itself executes normally without rescheduling from within it, saving the "local context" is also not performed, significantly reducing overhead and improving system performance. To avoid spoiling the picture by calling a non-inlined member function of an interprocess communication service object, it is recommended to use special lightweight, inlinable versions of such functionsâ€”for more details, see <a href="../ipcs/">the Interprocess Communication section</a>.</p>
<p>The main disadvantage of software interrupt-based control transfer is that not all hardware platforms support software interrupts. In such cases, one of the unused hardware interrupts can be used as a software interrupt. Unfortunately, this introduces some lack of universality&nbsp;â€“ it is not known in advance whether a particular hardware interrupt will be needed in a given project. Therefore, if the processor does not specifically provide a suitable interrupt, the choice of context switch interrupt is delegated (from the port level) to the project level, and the user must write the corresponding code<sup id="fnref:12"><a class="footnote-ref" href="#fn:12">12</a></sup> themselves.</p>
<p>When using software interrupt-based control transfer, the expression "The kernel takes control away from processes" fully reflects the situation.</p>
<h4 id="conclusions">Conclusions<a class="headerlink" href="#conclusions" title="Permanent link">ðŸ”—</a></h4>
<p>Given the above analysis of the advantages and disadvantages of both control transfer methods, the general recommendation is as follows: if the target platform provides a suitable interrupt for implementing context switching, it makes sense to use this variant, especially if the size of the "local context" is sufficiently large.</p>
<p>Using direct control transfer is justified when it is truly impossible to use a software interruptâ€”for example, when the target platform does not support such an interrupt, and using a hardware interrupt as a software one is impossible for one reason or another, or if the performance characteristics with this control transfer variant prove better due to lower overhead in organizing context switches, while saving/restoring the "local context" does not introduce noticeable overhead due to its small size<sup id="fnref:13"><a class="footnote-ref" href="#fn:13">13</a></sup>.</p>
<h3 id="support-for-interprocess-communication">Support for Interprocess Communication<a class="headerlink" href="#support-for-interprocess-communication" title="Permanent link">ðŸ”—</a></h3>
<p>Support for interprocess communication boils down to providing a set of functions for monitoring process states, as well as granting access to rescheduling mechanisms for the OS components&nbsp;â€“ interprocess communication services. For more details on this, see <a href="../ipcs/">the Interprocess Communication section</a>.</p>
<h3 id="interrupts">Interrupts<a class="headerlink" href="#interrupts" title="Permanent link">ðŸ”—</a></h3>
<h4 id="usage-features-with-rtos-and-implementation">Usage Features with RTOS and Implementation<a class="headerlink" href="#usage-features-with-rtos-and-implementation" title="Permanent link">ðŸ”—</a></h4>
<p>An occurring interrupt can serve as a source of an event that requires handling by one or more processes. To minimize (and ensure determinism of) the response time to the event, process rescheduling is used when necessary, transferring control to the highest-priority process that is ready-to-run.</p>
<p>The code of any interrupt handler that uses interprocess communication services must call the function <code>isr_enter()</code> at the beginning, which increments the variable <code>ISR_NestCount</code>, and call the function <code>isr_exit()</code> at the end, which decrements <code>ISR_NestCount</code> and determines the interrupt nesting level (in the case of nested interrupts) based on its value. When <code>ISR_NestCount</code> reaches zero, it indicates a return from the interrupt handler to the main program, and <code>isr_exit()</code> performs process rescheduling (if required) by invoking the interrupt-level scheduler.</p>
<p>To simplify usage and improve portability, the code executed at the entry and exit of interrupt handlers is placed in the constructor and destructor, respectively, of a special wrapper class <code>TISRW</code>. An object of this type must be used within the interrupt handler<sup id="fnref:14"><a class="footnote-ref" href="#fn:14">14</a></sup>. It is sufficient to create an object of this type in the interrupt handler code; the compiler will handle the rest automatically. Importantly, the declaration of this object must precede the first use of any interprocess communication service functions.</p>
<p>It should be noted that if a non-inlinable function is called within an interrupt handler, the compiler will save the "local context"â€”the scratch<sup id="fnref:15"><a class="footnote-ref" href="#fn:15">15</a></sup> registers<sup id="fnref:16"><a class="footnote-ref" href="#fn:16">16</a></sup>. Therefore, it is advisable to avoid calls to non-inlinable functions from interrupt handlers, as even partial context saving degrades both execution speed and code size<sup id="fnref:17"><a class="footnote-ref" href="#fn:17">17</a></sup>. For this reason, in the current version of <strong>scmRTOS</strong>, some interprocess communication objects have been augmented with special lightweight functions designed for use in interrupt handlers. These functions are inlinable and employ a lightweight version of the scheduler, which is also inlinable. For more details, see <a href="../ipcs/">the Interprocess Communication Services section</a>.</p>
<h4 id="separate-interrupt-stack-and-nested-interrupts">Separate Interrupt Stack and Nested Interrupts<a class="headerlink" href="#separate-interrupt-stack-and-nested-interrupts" title="Permanent link">ðŸ”—</a></h4>
<p>Another aspect related to interrupts in a preemptive RTOS is the use of a separate stack for interrupt handlers. As is well known, when an interrupt occurs and control is transferred to its handler, the program uses the stack of the interrupted process. This stack must be large enough to satisfy the needs of both the process itself and any interrupt handler. Moreover, it must accommodate the combined worst-case requirementsâ€”for example, when the process code has reached its peak stack usage and an interrupt occurs at that moment, with its handler also consuming additional stack space. The stack size must be sufficient to prevent overflow even in this scenario.</p>
<p>Clearly, the above considerations apply to all processes in the system. If interrupt handlers consume a significant amount of stack space, the stack sizes of all processes must be increased by a corresponding amount. This leads to higher memory overhead. In the case of nested interrupts, the situation becomes dramatically worse.</p>
<p>To mitigate this effect, the processor's stack pointer is switched to a dedicated interrupt stack upon entry into an interrupt handler. This effectively decouples the process stacks from the interrupt stack, eliminating the need to reserve additional memory in each process stack for interrupt handler operation.</p>
<p>The implementation of a separate interrupt stack is handled at the port level. Some processors provide hardware support for switching the stack pointer to the interrupt stack, making this feature efficient and safe<sup id="fnref:18"><a class="footnote-ref" href="#fn:18">18</a></sup>.</p>
<p>Nested interruptsâ€”those whose handlers can interrupt not only the main program but also other interrupt handlersâ€”have specific usage characteristics. Understanding these is essential for effective and safe application of the mechanism. When the processor has a priority-based interrupt controller supporting multiple priority levels, handling nested interrupts is relatively straightforward. Potential dangerous situations when enabling nesting are typically accounted for by the processor designers, and the interrupt controller prevents issues such as those described below.</p>
<p>In processors with a single-level interrupt system, the typical implementation automatically disables interrupts globally upon any interrupt occurrence&nbsp;â€“ for reasons of simplicity and safety. In other words, nested interrupts are not supported. To enable nesting, it is sufficient to globally re-enable interrupts, which are usually disabled by hardware when control is transferred to the handler. However, this can lead to a situation where an already executing interrupt handler is invoked again&nbsp;â€“ if the interrupt request for the same source remains pending<sup id="fnref:19"><a class="footnote-ref" href="#fn:19">19</a></sup>.</p>
<p>This is generally an erroneous situation that must be avoided. To prevent it, one must clearly understand both the processor's operational specifics and its current "context"<sup id="fnref:20"><a class="footnote-ref" href="#fn:20">20</a></sup>, and write code very carefully: before globally enabling interrupts, disable the activation of the interrupt whose handler is already running (to avoid re-entry into the same handler), and upon completion, remember to restore the processor's control resources to their original state before the nesting manipulations.</p>
<p>Based on the above, the following recommendation can be made.</p>
<div class="admonition error">
<p class="admonition-title"><strong>WARNING</strong></p>
<p>Despite the apparent advantages of a separate interrupt stack, it is not recommended on processors lacking hardware support for switching the stack pointer to the interrupt stack.
This is due to additional overhead from manual stack switching, poor portabilityâ€”any non-standard extensions are a source of problemsâ€”and the fact that direct manipulation of the stack pointer can cause collisions with local object addressing. For example, the compiler, seeing the body of the interrupt handler, allocates<sup id="fnref:21"><a class="footnote-ref" href="#fn:21">21</a></sup> memory for local objects on the stackâ€”and does so before calling<sup id="fnref:22"><a class="footnote-ref" href="#fn:22">22</a></sup> the wrapper constructor. As a result, after switching the stack pointer to the interrupt stack, the previously allocated memory will physically reside elsewhere, causing the program to malfunction, while the compiler cannot detect this issue.
Similarly, nested interrupts are not recommended on processors without hardware support for them. Such interrupts require careful handling and usually additional maintenanceâ€”for example, blocking the interrupt source to prevent re-invocation of the same handler when interrupts are enabled.</p>
</div>
<p>Brief conclusion: The motivation for using a separate interrupt stack correlates with the use of nested interruptsâ€”since nesting significantly increases stack consumption in interrupt handlers, imposingâ€”in the absence of a separate interrupt stackâ€”additional requirements on process stack sizes<sup id="fnref:23"><a class="footnote-ref" href="#fn:23">23</a></sup>.</p>
<div class="admonition tip">
<p class="admonition-title"><strong>TIP</strong></p>
<p>When using a preemptive RTOS, it is possible to structure the program so that interrupt handlers serve only as event sources, with all event processing moved to the process level. This keeps interrupt handlers small and fast, in turn eliminating the need for both a separate interrupt stack and nested interrupt support. In this case, the interrupt handler body can be comparable in size to the overhead of switching to a separate interrupt stack and enabling nesting.</p>
</div>
<p>This approach is precisely what is recommended when the processor lacks hardware support for switching to a separate interrupt stack and does not have an interrupt controller with hardware nested interrupt support.</p>
<p>It should be noted that a priority-based preemptive RTOS is, in a sense, analogous to a multi-level priority interrupt controllerâ€”it provides the ability to distribute code execution according to importance/urgency. For this reason, in most cases there is no need to place event-processing code at the interrupt level even when such a hardware controller is present; instead, use interrupts solely as event sources<sup id="fnref:24"><a class="footnote-ref" href="#fn:24">24</a></sup> and move their processing to the process level. This is the recommended programming style.</p>
<h3 id="system-timer">System Timer<a class="headerlink" href="#system-timer" title="Permanent link">ðŸ”—</a></h3>
<p>The system timer is used to generate specific time intervals required for process operation, including support for timeouts.</p>
<p>Typically, one of the processor's hardware timers is used as the system timer<sup id="fnref:25"><a class="footnote-ref" href="#fn:25">25</a></sup>.</p>
<p>The system timer functionality is implemented in the kernel function <code>system_timer()</code>. The code for this function is shown in "Listing 5. System Timer".</p>
<figure>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-8-1"><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a><span class="mo">01</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">OS</span><span class="o">::</span><span class="n">TKernel</span><span class="o">::</span><span class="n">system_timer</span><span class="p">()</span>
</span><span id="__span-8-2"><a id="__codelineno-8-2" name="__codelineno-8-2" href="#__codelineno-8-2"></a><span class="mo">02</span><span class="w">    </span><span class="p">{</span>
</span><span id="__span-8-3"><a id="__codelineno-8-3" name="__codelineno-8-3" href="#__codelineno-8-3"></a><span class="mo">03</span><span class="w">        </span><span class="n">SYS_TIMER_CRIT_SECT</span><span class="p">();</span>
</span><span id="__span-8-4"><a id="__codelineno-8-4" name="__codelineno-8-4" href="#__codelineno-8-4"></a><span class="mo">04</span><span class="w">    </span><span class="err">#</span><span class="k">if</span><span class="w"> </span><span class="n">scmRTOS_SYSTEM_TICKS_ENABLE</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>
</span><span id="__span-8-5"><a id="__codelineno-8-5" name="__codelineno-8-5" href="#__codelineno-8-5"></a><span class="mo">05</span><span class="w">        </span><span class="n">SysTickCount</span><span class="o">++</span><span class="p">;</span>
</span><span id="__span-8-6"><a id="__codelineno-8-6" name="__codelineno-8-6" href="#__codelineno-8-6"></a><span class="mo">06</span><span class="w">    </span><span class="err">#</span><span class="n">endif</span>
</span><span id="__span-8-7"><a id="__codelineno-8-7" name="__codelineno-8-7" href="#__codelineno-8-7"></a><span class="mo">07</span><span class="w">    </span>
</span><span id="__span-8-8"><a id="__codelineno-8-8" name="__codelineno-8-8" href="#__codelineno-8-8"></a><span class="mi">08</span><span class="w">    </span><span class="err">#</span><span class="k">if</span><span class="w"> </span><span class="n">scmRTOS_PRIORITY_ORDER</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span>
</span><span id="__span-8-9"><a id="__codelineno-8-9" name="__codelineno-8-9" href="#__codelineno-8-9"></a><span class="mi">09</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">uint_fast8_t</span><span class="w"> </span><span class="n">BaseIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</span><span id="__span-8-10"><a id="__codelineno-8-10" name="__codelineno-8-10" href="#__codelineno-8-10"></a><span class="mi">10</span><span class="w">    </span><span class="err">#</span><span class="k">else</span>
</span><span id="__span-8-11"><a id="__codelineno-8-11" name="__codelineno-8-11" href="#__codelineno-8-11"></a><span class="mi">11</span><span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">uint_fast8_t</span><span class="w"> </span><span class="n">BaseIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</span><span id="__span-8-12"><a id="__codelineno-8-12" name="__codelineno-8-12" href="#__codelineno-8-12"></a><span class="mi">12</span><span class="w">    </span><span class="err">#</span><span class="n">endif</span>
</span><span id="__span-8-13"><a id="__codelineno-8-13" name="__codelineno-8-13" href="#__codelineno-8-13"></a><span class="mi">13</span><span class="w">    </span>
</span><span id="__span-8-14"><a id="__codelineno-8-14" name="__codelineno-8-14" href="#__codelineno-8-14"></a><span class="mi">14</span><span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">uint_fast8_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BaseIndex</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">PROCESS_COUNT</span><span class="mi">-1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">BaseIndex</span><span class="p">);</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span id="__span-8-15"><a id="__codelineno-8-15" name="__codelineno-8-15" href="#__codelineno-8-15"></a><span class="mi">15</span><span class="w">        </span><span class="p">{</span>
</span><span id="__span-8-16"><a id="__codelineno-8-16" name="__codelineno-8-16" href="#__codelineno-8-16"></a><span class="mi">16</span><span class="w">            </span><span class="n">TBaseProcess</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ProcessTable</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span id="__span-8-17"><a id="__codelineno-8-17" name="__codelineno-8-17" href="#__codelineno-8-17"></a><span class="mi">17</span><span class="w">    </span>
</span><span id="__span-8-18"><a id="__codelineno-8-18" name="__codelineno-8-18" href="#__codelineno-8-18"></a><span class="mi">18</span><span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">Timeout</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
</span><span id="__span-8-19"><a id="__codelineno-8-19" name="__codelineno-8-19" href="#__codelineno-8-19"></a><span class="mi">19</span><span class="w">            </span><span class="p">{</span>
</span><span id="__span-8-20"><a id="__codelineno-8-20" name="__codelineno-8-20" href="#__codelineno-8-20"></a><span class="mi">20</span><span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="o">--</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">Timeout</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
</span><span id="__span-8-21"><a id="__codelineno-8-21" name="__codelineno-8-21" href="#__codelineno-8-21"></a><span class="mi">21</span><span class="w">                </span><span class="p">{</span>
</span><span id="__span-8-22"><a id="__codelineno-8-22" name="__codelineno-8-22" href="#__codelineno-8-22"></a><span class="mi">22</span><span class="w">                    </span><span class="n">set_process_ready</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">Priority</span><span class="p">);</span>
</span><span id="__span-8-23"><a id="__codelineno-8-23" name="__codelineno-8-23" href="#__codelineno-8-23"></a><span class="mi">23</span><span class="w">                </span><span class="p">}</span>
</span><span id="__span-8-24"><a id="__codelineno-8-24" name="__codelineno-8-24" href="#__codelineno-8-24"></a><span class="mi">24</span><span class="w">            </span><span class="p">}</span>
</span><span id="__span-8-25"><a id="__codelineno-8-25" name="__codelineno-8-25" href="#__codelineno-8-25"></a><span class="mi">25</span><span class="w">        </span><span class="p">}</span>
</span><span id="__span-8-26"><a id="__codelineno-8-26" name="__codelineno-8-26" href="#__codelineno-8-26"></a><span class="mi">26</span><span class="w">    </span><span class="p">}</span>
</span></code></pre></div>
<figcaption>
<p>Listing 5. System Timer  </p>
</figcaption>
</figure>
<p>As can be seen from the source code, the actions are very straightforward:</p>
<ol>
<li>If the tick counter is enabled, the tick counter variable is incremented (line 5).</li>
<li>Then, in a loop, the timeout values of all registered processes are checked. If the checked value is not zero<sup id="fnref:26"><a class="footnote-ref" href="#fn:26">26</a></sup>, it is decremented and tested for zero. When it reaches zero (after decrement), meaning the process timeout has expired, the process is marked as ready-to-run.</li>
</ol>
<p>Since this function is called inside the timer interrupt handler, upon returning to the main program (as described earlier), control will be transferred to the highest-priority ready-to-run process. Thus, if the timeout of a process with higher priority than the interrupted one has expired, that process will receive control after exiting the interrupt. This is achieved through the scheduler (see above).</p>
<div class="admonition info">
<p class="admonition-title"><strong>NOTE</strong></p>
<p>Some RTOSes provide recommendations for the system tick duration, most commonly suggesting a range of 10<sup id="fnref:28"><a class="footnote-ref" href="#fn:28">27</a></sup>â€“100 ms. This may be appropriate for those systems. The trade-off here is between minimizing overhead from system timer interrupts and achieving finer time resolution.</p>
<p>Given that <strong>scmRTOS</strong> targets small microcontrollers operating in real-time environments, and considering that execution overhead<sup id="fnref:29"><a class="footnote-ref" href="#fn:29">28</a></sup> is very low, the recommended system tick period is 1â€“10 ms.</p>
<p>An analogy can be drawn with other domains where smaller objects typically operate at higher frequencies: for example, a mouse's heartbeat is much faster than a human's, and a human's is faster than an elephant's, with agility being inversely related. A similar trend exists in engineering, so it is reasonable to expect shorter tick periods on smaller processors than on larger onesâ€”in larger systems, overhead is generally higher due to greater loading of the more powerful processor and, consequently, reduced responsiveness.</p>
</div>
<hr />
<p><a name="kernel-agent"></a></p>
<h2 id="tkernelagent-and-extensions">TKernelAgent and Extensions<a class="headerlink" href="#tkernelagent-and-extensions" title="Permanent link">ðŸ”—</a></h2>
<h3 id="kernel-agent">Kernel Agent<a class="headerlink" href="#kernel-agent" title="Permanent link">ðŸ”—</a></h3>
<p>The <code>TKernelAgent</code> class is a specialized mechanism designed to provide controlled access to kernel resources when developing extensions to the operating system's functionality.</p>
<p>The overall concept is as follows: creating any functional extension for the OS requires access to certain kernel resources&nbsp;â€“ such as the variable holding the priority of the active process or the system process map. Granting direct access to these internal structures would be unwise, as it violates the security model of object-oriented design<sup id="fnref:30"><a class="footnote-ref" href="#fn:30">29</a></sup>. This could lead to negative consequences, such as program instability due to insufficient coding discipline or loss of compatibility if the internal kernel representation changes.</p>
<p>To address this, an approach based on a dedicated classâ€”the kernel agentâ€”is proposed. It restricts access through a documented interface, allowing extensions to be created in a formalized, simpler, and safer manner.</p>
<p>The code for the kernel agent class is shown in "Listing 6. TKernelAgent".</p>
<figure>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-9-1"><a id="__codelineno-9-1" name="__codelineno-9-1" href="#__codelineno-9-1"></a><span class="mo">01</span><span class="w">    </span><span class="k">class</span><span class="w"> </span><span class="nc">TKernelAgent</span>
</span><span id="__span-9-2"><a id="__codelineno-9-2" name="__codelineno-9-2" href="#__codelineno-9-2"></a><span class="mo">02</span><span class="w">    </span><span class="p">{</span>
</span><span id="__span-9-3"><a id="__codelineno-9-3" name="__codelineno-9-3" href="#__codelineno-9-3"></a><span class="mo">03</span><span class="w">        </span><span class="n">INLINE</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">TBaseProcess</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cur_proc</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Kernel</span><span class="p">.</span><span class="n">ProcessTable</span><span class="p">[</span><span class="n">cur_proc_priority</span><span class="p">()];</span><span class="w"> </span><span class="p">}</span>
</span><span id="__span-9-4"><a id="__codelineno-9-4" name="__codelineno-9-4" href="#__codelineno-9-4"></a><span class="mo">04</span>
</span><span id="__span-9-5"><a id="__codelineno-9-5" name="__codelineno-9-5" href="#__codelineno-9-5"></a><span class="mo">05</span><span class="w">    </span><span class="k">protected</span><span class="o">:</span>
</span><span id="__span-9-6"><a id="__codelineno-9-6" name="__codelineno-9-6" href="#__codelineno-9-6"></a><span class="mo">06</span><span class="w">        </span><span class="n">TKernelAgent</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
</span><span id="__span-9-7"><a id="__codelineno-9-7" name="__codelineno-9-7" href="#__codelineno-9-7"></a><span class="mo">07</span><span class="w">        </span><span class="n">INLINE</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">uint_fast8_t</span><span class="w"> </span><span class="k">const</span><span class="w">   </span><span class="o">&amp;</span><span class="w"> </span><span class="n">cur_proc_priority</span><span class="p">()</span><span class="w">       </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Kernel</span><span class="p">.</span><span class="n">CurProcPriority</span><span class="p">;</span><span class="w">  </span><span class="p">}</span>
</span><span id="__span-9-8"><a id="__codelineno-9-8" name="__codelineno-9-8" href="#__codelineno-9-8"></a><span class="mi">08</span><span class="w">        </span><span class="n">INLINE</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">TProcessMap</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ready_process_map</span><span class="p">()</span><span class="w">       </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Kernel</span><span class="p">.</span><span class="n">ReadyProcessMap</span><span class="p">;</span><span class="w">  </span><span class="p">}</span>
</span><span id="__span-9-9"><a id="__codelineno-9-9" name="__codelineno-9-9" href="#__codelineno-9-9"></a><span class="mi">09</span><span class="w">        </span><span class="n">INLINE</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="n">timeout_t</span><span class="w">   </span><span class="o">&amp;</span><span class="w"> </span><span class="n">cur_proc_timeout</span><span class="p">()</span><span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">cur_proc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Timeout</span><span class="p">;</span><span class="w">     </span><span class="p">}</span>
</span><span id="__span-9-10"><a id="__codelineno-9-10" name="__codelineno-9-10" href="#__codelineno-9-10"></a><span class="mi">10</span><span class="w">        </span><span class="n">INLINE</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">reschedule</span><span class="p">()</span><span class="w">                                </span><span class="p">{</span><span class="w"> </span><span class="n">Kernel</span><span class="p">.</span><span class="n">scheduler</span><span class="p">();</span><span class="w">             </span><span class="p">}</span>
</span><span id="__span-9-11"><a id="__codelineno-9-11" name="__codelineno-9-11" href="#__codelineno-9-11"></a><span class="mi">11</span>
</span><span id="__span-9-12"><a id="__codelineno-9-12" name="__codelineno-9-12" href="#__codelineno-9-12"></a><span class="mi">12</span><span class="w">        </span><span class="n">INLINE</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">set_process_ready</span><span class="w">   </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint_fast8_t</span><span class="w"> </span><span class="n">pr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Kernel</span><span class="p">.</span><span class="n">set_process_ready</span><span class="p">(</span><span class="n">pr</span><span class="p">);</span><span class="w">   </span><span class="p">}</span>
</span><span id="__span-9-13"><a id="__codelineno-9-13" name="__codelineno-9-13" href="#__codelineno-9-13"></a><span class="mi">13</span><span class="w">         </span><span class="n">INLINE</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">set_process_unready</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint_fast8_t</span><span class="w"> </span><span class="n">pr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Kernel</span><span class="p">.</span><span class="n">set_process_unready</span><span class="p">(</span><span class="n">pr</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
</span><span id="__span-9-14"><a id="__codelineno-9-14" name="__codelineno-9-14" href="#__codelineno-9-14"></a><span class="mi">14</span><span class="w"> </span>
</span><span id="__span-9-15"><a id="__codelineno-9-15" name="__codelineno-9-15" href="#__codelineno-9-15"></a><span class="mi">15</span><span class="w">     </span><span class="err">#</span><span class="k">if</span><span class="w"> </span><span class="n">scmRTOS_DEBUG_ENABLE</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>
</span><span id="__span-9-16"><a id="__codelineno-9-16" name="__codelineno-9-16" href="#__codelineno-9-16"></a><span class="mi">16</span><span class="w">         </span><span class="n">INLINE</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">TService</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">cur_proc_waiting_for</span><span class="p">()</span><span class="w">     </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">cur_proc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">WaitingFor</span><span class="p">;</span><span class="w">  </span><span class="p">}</span>
</span><span id="__span-9-17"><a id="__codelineno-9-17" name="__codelineno-9-17" href="#__codelineno-9-17"></a><span class="mi">17</span><span class="w">     </span><span class="err">#</span><span class="n">endif</span>
</span><span id="__span-9-18"><a id="__codelineno-9-18" name="__codelineno-9-18" href="#__codelineno-9-18"></a><span class="mi">18</span><span class="w"> </span>
</span><span id="__span-9-19"><a id="__codelineno-9-19" name="__codelineno-9-19" href="#__codelineno-9-19"></a><span class="mi">19</span><span class="w">     </span><span class="err">#</span><span class="k">if</span><span class="w"> </span><span class="n">scmRTOS_PROCESS_RESTART_ENABLE</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span>
</span><span id="__span-9-20"><a id="__codelineno-9-20" name="__codelineno-9-20" href="#__codelineno-9-20"></a><span class="mi">20</span><span class="w">         </span><span class="n">INLINE</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span>
</span><span id="__span-9-21"><a id="__codelineno-9-21" name="__codelineno-9-21" href="#__codelineno-9-21"></a><span class="mi">21</span><span class="w">         </span><span class="n">TProcessMap</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">cur_proc_waiting_map</span><span class="p">()</span><span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">cur_proc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">WaitingProcessMap</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</span><span id="__span-9-22"><a id="__codelineno-9-22" name="__codelineno-9-22" href="#__codelineno-9-22"></a><span class="mi">22</span><span class="w">     </span><span class="err">#</span><span class="n">endif</span>
</span><span id="__span-9-23"><a id="__codelineno-9-23" name="__codelineno-9-23" href="#__codelineno-9-23"></a><span class="mi">23</span><span class="w">     </span><span class="p">};</span><span class="w">                                                                                         </span>
</span></code></pre></div>
<figcaption>
<p>Listing 6. TKernelAgent  </p>
</figcaption>
</figure>
<p>As can be seen from the code, the class is defined in such a way that instances of it cannot be created. This is intentional: <code>TKernelAgent</code> is designed to serve as a base for building extensions. Its primary role is to provide a documented interface to kernel resources. Therefore, its functionality becomes available only through derived classes, which represent the actual extensions.</p>
<p>An example of using <code>TKernelAgent</code> will be discussed in more detail below when describing the base class for interprocess communication services&nbsp;â€“ <code>TService</code>.</p>
<p>The entire interface consists of inline functions, which in most cases allows extensions to be implemented without sacrificing performance compared to direct access to kernel resources.</p>
<h3 id="extensions">Extensions<a class="headerlink" href="#extensions" title="Permanent link">ðŸ”—</a></h3>
<p>The kernel agent class described above enables the creation of additional features that extend the OS capabilities. The methodology for creating such extensions is straightforward: simply declare a class derived from <code>TKernelAgent</code> and define its contents. Such classes are referred to as <strong>operating system extensions</strong>.</p>
<p>The layout of the OS kernel code is organized so that class declarations and definitions of certain class member functions are separated into the header file <code>os_kernel.h</code>. This allows a user-defined class to have access to all kernel type definitions while simultaneously making the user-defined class visible to member functions of kernel classes&nbsp;â€“ for example, in the scheduler and the system timer function<sup id="fnref:31"><a class="footnote-ref" href="#fn:31">30</a></sup>.</p>
<p>Extensions are integrated using the configuration file <code>scmRTOS_extensions.h</code>, which is included in <code>os_kernel.h</code> between the kernel type definitions and their member function implementations. This makes it possible to place the extension class definition in a separate user header file and include it in the project by adding it to <code>scmRTOS_extensions.h</code>. Once done, the extension is ready for use according to its intended purpose.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Objects marked with â€˜*â€™ are present only in the variant using software interrupt-based control transfer.&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Ideologically, using a pointer to the process might seem more correct for these purposes, but analysis showed no performance gain, and the pointer size is typically larger than an integer variable for storing priority.&#160;<a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>The process may be active (executing) or inactive (waiting for control) â€” the latter occurs when there is another ready process with higher priority.&#160;<a class="footnote-backref" href="#fnref:3" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:4">
<p>This higher-priority process may in turn be interrupted by an even higher-priority one, and so on, until the highest-priority process is reached â€” it can only be (temporarily) interrupted by an interrupt handler, but upon return, control always goes back to it. Thus, the highest-priority process cannot be preempted by any other process. Upon exiting an interrupt handler, control always passes to the highest-priority ready-to-run process.&#160;<a class="footnote-backref" href="#fnref:4" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:5">
<p>Usually implemented in assembly.&#160;<a class="footnote-backref" href="#fnref:5" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:6">
<p>Or upon interrupt handler exit â€” depending on whether the transfer is synchronous or asynchronous.&#160;<a class="footnote-backref" href="#fnref:6" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:7">
<p>All interrupt handlers using interprocess communication services must declare a <code>TISRW</code> object before any interprocess communication service function call (i.e., where scheduling may occur). This object must be declared before the first OS service use.&#160;<a class="footnote-backref" href="#fnref:7" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
<li id="fn:8">
<p>This is a common property of many processorsâ€”after returning from an interrupt, transitioning to the next interrupt handler is not possible immediately in the same machine cycle but only after one or more cycles.&#160;<a class="footnote-backref" href="#fnref:8" title="Jump back to footnote 8 in the text">&#8617;</a></p>
</li>
<li id="fn:9">
<p>Here, <code>&lt;wait_for_context_switch_done&gt;</code> represents all the code ensuring the context switch, starting from enabling interrupts.&#160;<a class="footnote-backref" href="#fnref:9" title="Jump back to footnote 9 in the text">&#8617;</a></p>
</li>
<li id="fn:10">
<p>This software interrupt handler is always implemented in assembly and is also platform-dependent, so its code is not provided here.&#160;<a class="footnote-backref" href="#fnref:10" title="Jump back to footnote 10 in the text">&#8617;</a></p>
</li>
<li id="fn:11">
<p><div class="language-cpp highlight"><pre><span></span><code><span id="__span-7-1"><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a><span class="n">os_context_switcher</span><span class="p">(</span><span class="n">stack_item_t</span><span class="w"> </span><span class="o">**</span><span class="n">Curr_SP</span><span class="p">,</span><span class="w"> </span><span class="n">stack_item_t</span><span class="w"> </span><span class="o">*</span><span class="n">Next_SP</span><span class="p">)</span>
</span></code></pre></div>&#160;<a class="footnote-backref" href="#fnref:11" title="Jump back to footnote 11 in the text">&#8617;</a></p>
</li>
<li id="fn:12">
<p>The <strong>scmRTOS</strong> distribution is offered with several working usage examples, where all the code for organizing and configuring the software interrupt is present. Thus, the user can simply modify this code to suit their project's needs or use it as-is if everything fits.&#160;<a class="footnote-backref" href="#fnref:12" title="Jump back to footnote 12 in the text">&#8617;</a></p>
</li>
<li id="fn:13">
<p>For example, on <strong>MSP430</strong>/IAR, the "local context" consists of just 4 registers.&#160;<a class="footnote-backref" href="#fnref:13" title="Jump back to footnote 13 in the text">&#8617;</a></p>
</li>
<li id="fn:14">
<p>The aforementioned functions <code>isr_enter()</code> and <code>isr_exit()</code> are member functions of this wrapper class.&#160;<a class="footnote-backref" href="#fnref:14" title="Jump back to footnote 14 in the text">&#8617;</a></p>
</li>
<li id="fn:15">
<p>Typically, the compiler divides processor registers into two groups: scratch and preserved. Scratch registers are those that any function may use without prior saving. Preserved registers are those whose values must be saved if the function needs to use them (the function must save the value before use and restore it afterward). In some cases, preserved registers are referred to as local; in the context discussed here, these terms are synonymous.&#160;<a class="footnote-backref" href="#fnref:15" title="Jump back to footnote 15 in the text">&#8617;</a></p>
</li>
<li id="fn:16">
<p>The proportion of these registers (relative to the total number) varies across platforms. For example, when using EWAVR, they account for roughly half of all registers; with EW430, less than half. In the case of VisualDSP++/<strong>Blackfin</strong>, the proportion of these registers is large, but on this platform, stack sizes are generally large enough that this is not a major concern.&#160;<a class="footnote-backref" href="#fnref:16" title="Jump back to footnote 16 in the text">&#8617;</a></p>
</li>
<li id="fn:17">
<p>Unfortunately, when using the direct control transfer scheme, a non-inlinable context switch function is called, so the overhead of saving scratch registers cannot be avoided in this case.&#160;<a class="footnote-backref" href="#fnref:17" title="Jump back to footnote 17 in the text">&#8617;</a></p>
</li>
<li id="fn:18">
<p>In such cases, this mechanism is the only one implemented in the port, and there is no need for a separate implementation of the <code>TISRW_SS</code> wrapper class.&#160;<a class="footnote-backref" href="#fnref:18" title="Jump back to footnote 18 in the text">&#8617;</a></p>
</li>
<li id="fn:19">
<p>This may occur, for example, due to events triggering the interrupt too frequently or because the interrupt flag was not cleared, continuing to assert the request.&#160;<a class="footnote-backref" href="#fnref:19" title="Jump back to footnote 19 in the text">&#8617;</a></p>
</li>
<li id="fn:20">
<p>Here, "context" refers to the logical and semantic environment in which this part of the program executes.&#160;<a class="footnote-backref" href="#fnref:20" title="Jump back to footnote 20 in the text">&#8617;</a></p>
</li>
<li id="fn:21">
<p>More preciselyâ€”reserves. This is typically done by modifying the stack pointer.&#160;<a class="footnote-backref" href="#fnref:21" title="Jump back to footnote 21 in the text">&#8617;</a></p>
</li>
<li id="fn:22">
<p>And it has every right to do so.&#160;<a class="footnote-backref" href="#fnref:22" title="Jump back to footnote 22 in the text">&#8617;</a></p>
</li>
<li id="fn:23">
<p>Moreover, each process must have a stack large enough to cover both its own needs and the stack consumption of interrupt handlers, including the full nesting hierarchy.&#160;<a class="footnote-backref" href="#fnref:23" title="Jump back to footnote 23 in the text">&#8617;</a></p>
</li>
<li id="fn:24">
<p>Making interrupt handlers as simple, short, and fast as possible.&#160;<a class="footnote-backref" href="#fnref:24" title="Jump back to footnote 24 in the text">&#8617;</a></p>
</li>
<li id="fn:25">
<p>The simplest timer (without advanced features) is suitable for this purpose. The only fundamental requirement is that it must be capable of generating periodic interrupts at equal intervals&nbsp;â€“ for example, an overflow interrupt. It is also desirable to have the ability to control the overflow period in order to select an appropriate system tick frequency.&#160;<a class="footnote-backref" href="#fnref:25" title="Jump back to footnote 25 in the text">&#8617;</a></p>
</li>
<li id="fn:26">
<p>This indicates that the process is waiting with a timeout.&#160;<a class="footnote-backref" href="#fnref:26" title="Jump back to footnote 26 in the text">&#8617;</a></p>
</li>
<li id="fn:28">
<p>For example, how would one implement dynamic LED display multiplexing with such a period when it is known that, for comfortable viewing with four digits, the digit refresh period must not exceed 5 ms?&#160;<a class="footnote-backref" href="#fnref:28" title="Jump back to footnote 27 in the text">&#8617;</a></p>
</li>
<li id="fn:29">
<p>Due to the small number of processes and the simple, fast scheduler.&#160;<a class="footnote-backref" href="#fnref:29" title="Jump back to footnote 28 in the text">&#8617;</a></p>
</li>
<li id="fn:30">
<p>Principles of encapsulation and abstraction.&#160;<a class="footnote-backref" href="#fnref:30" title="Jump back to footnote 29 in the text">&#8617;</a></p>
</li>
<li id="fn:31">
<p>In user hooks.&#160;<a class="footnote-backref" href="#fnref:31" title="Jump back to footnote 30 in the text">&#8617;</a></p>
</li>
</ol>
</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../overview/" class="btn btn-neutral float-left" title="Overview"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../processes/" class="btn btn-neutral float-right" title="Processes">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../overview/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../processes/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../js/mathjax.js"></script>
      <script src="../../js/mathjax/tex-mml-chtml.js"></script>
      <script src="../../js/wavedrom.min.js"></script>
      <script src="../../js/wavedrom_loader.js"></script>
      <script src="../../js/wavedrom.unpkg.js"></script>
      <script src="../../js/wavedrom_skin_default.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

<script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
</script></body>
</html>
